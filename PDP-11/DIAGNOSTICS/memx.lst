       1                                .title	Memory Exerciser Diagnostic Test
       2                                
       3                                ; (C) 2010-2016 Donald North. All rights reserved.
       4                                
       5                                .include "mac/stddef.mac"
       1                                ;================================================================================
       2                                ; stddef.mac - standard definitions
       3                                ; (C) 2009 Donald North. All rights reserved.
       4                                ;================================================================================
       5                                .macro	align	arg1
      16                                ;================================================================================
      17                                .macro	savreg	arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8
      28                                ;================================================================================
      29                                .macro	resreg	arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8
      40                                ;================================================================================
      41                                .macro	call	proc
      44                                .macro	return
      47                                .macro	calls	proc arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8 arg9 arg10 arg11 arg12 arg13 arg14 arg15 arg16
      67                                ;================================================================================
      68                                .macro	jeq	label ?a1
      73                                .macro	jne	label ?a1
      78                                .macro	jpl	label ?a1
      83                                .macro	jmi	label ?a1
      88                                .macro	jlo	label ?a1
      93                                .macro	jhis	label ?a1
      98                                .macro	jlos	label ?a1
     103                                .macro	jhi	label ?a1
     108                                .macro	jlt	label ?a1
     113                                .macro	jge	label ?a1
     118                                .macro	jle	label ?a1
     123                                .macro	jgt	label ?a1
     128                                .macro	jcc	label ?a1
     133                                .macro	jcs	label ?a1
     138                                .macro	jvc	label ?a1
     143                                .macro	jvs	label ?a1
     148                                ;================================================================================
     149                                .macro	printf	arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8 arg9 arg10 arg11 arg12 arg13 arg14 arg15 arg16
     152                                .macro	sprintf	arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8 arg9 arg10 arg11 arg12 arg13 arg14 arg15 arg16
     155                                ;================================================================================
     156                                .macro	ipl	lvl
     161                                ;================================================================================
     162                                .macro	trapcatcher	list ?a1 ?a2 ?a3 ?a4
     176                                ;================================================================================
     177        000001                  tst$no	= 1
     178                                .macro	test	title
     198                                ;================================================================================
     199                                ; end of stddef.mac
     200                                ;================================================================================
     200                                
       6                                
       7                                ; --------------------------------------------------------------------------------
       8                                
       9                                .sbttl	general definitions
      10                                
      11        000000                  fails	=0			; 1 for force fails, 0 for normal
      12                                
      13                                .include "mac/bits.mac"
       1                                ;================================================================================
       2                                ; bits.mac - standard bit definitions
       3                                ;================================================================================
       4                                
       5                                ;  system global fixed addresses
       6                                
       7        177776                  psw	==177776		; processor status word
       8                                
       9        165144                  console	==165144		; console routine start
      10                                
      11        177570                  swireg	==177570		; console switch register
      12        177570                  dpyreg	==swireg		; console display register
      13                                
      14        177560                  ttrcsr	==177560		; console serial device
      15        177562                  ttrbuf	==ttrcsr+2		;
      16        177564                  ttxcsr	==ttrcsr+4		;
      17        177566                  ttxbuf	==ttrcsr+6		;
      18                                
      19                                ; common values
      20                                
      21        000015                  cr	=015			; ascii CR
      22        000012                  lf	=012			; ascii LF
      23                                
      24        000001                  bit00	=000001			; bit positions
      25        000002                  bit01	=000002			;
      26        000004                  bit02	=000004			;
      27        000010                  bit03	=000010			;
      28        000020                  bit04	=000020			;
      29        000040                  bit05	=000040			;
      30        000100                  bit06	=000100			;
      31        000200                  bit07	=000200			;
      32        000400                  bit08	=000400			;
      33        001000                  bit09	=001000			;
      34        002000                  bit10	=002000			;
      35        004000                  bit11	=004000			;
      36        010000                  bit12	=010000			;
      37        020000                  bit13	=020000			;
      38        040000                  bit14	=040000			;
      39        100000                  bit15	=100000			;
      40                                	
      41        000001                  bit0	=bit00			; also
      42        000002                  bit1	=bit01			;
      43        000004                  bit2	=bit02			;
      44        000010                  bit3	=bit03			;
      45        000020                  bit4	=bit04			;
      46        000040                  bit5	=bit05			;
      47        000100                  bit6	=bit06			;
      48        000200                  bit7	=bit07			;
      49        000400                  bit8	=bit08			;
      50        001000                  bit9	=bit09			;
      51                                
      52                                ;================================================================================
      53                                ; end of bits.mac
      54                                ;================================================================================
      54                                
      14                                
      15                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      16                                
      17                                .sbttl	memory definitions
      18                                
      19        177572                  mmr0	=177572			; mem mgt sr#0 ... error/status, enable
      20        177574                  mmr1	=177574			; mem mgt sr#1 ... register modifications
      21        177576                  mmr2	=177576			; mem mgt sr#2 ... virtual address
      22        172516                  mmr3	=172516			; mem mgt sr#3 ... ispace, 22b, map enables
      23                                
      24        172340                  kpar	=172340			; mem mgt kernel page addr reg base
      25        172300                  kpdr	=172300			; mem mgt kernel page desc reg base
      26                                
      27        177746                  ccsr	=177746			; cache control register ... cache force miss
      28                                
      29        000000                  pgprg	=0			; first program page
      30        000001                  pgprgn	=1			; number of 8KB program pages
      31        000006                  pgtst	=6			; memory test page
      32        000007                  pgios	=7			; i/o page
      33                                
      34        020000                  pgszby	=8192.			; size of a page, bytes
      35        000200                  pgszbl	=128.			; size of a page, blocks
      36        000100                  blszby	=64.			; size of a block, bytes
      37        000200                  blszio	=8.*<1024./blszby>	; size of 8KB I/O page, blocks
      38        010000                  blszum	=256.*<1024./blszby>	; size of 256K U/B map, blocks
      39                                	
      40        000000                  blmn	=0.			; min memory block number we can test
      41        007577                  blmx18	=4095.-blszio		; max memory block number we can test, 18b mode, minus I/O page
      42        167777                  blmx22	=65535.-blszum		; max memory block number we can test, 22b mode, minus U/B map
      43                                
      44        077406                  pgrw	=077406			; PDR value for a full size r/w page
      45        077400                  pgnone	=077400			; PDR value for a full size missing page
      46                                
      47        140000                  tstmin	=pgtst*pgszby		; test block, address base
      48        140077                  tstmax	=tstmin+blszby-1	; test block, address max
      49        000040                  tstwc	=blszby/2		; test block, size in words
      50        172354                  tstpar	=kpar+<pgtst*2>		; ptr to KPAR for block number
      51                                
      52        172100                  mcr0	=172100			; memory control csr base
      53                                
      54                                ; --------------------------------------------------------------------------------
      55                                
      56                                .sbttl	low memory
      57                                
      58                                	.enabl	ama			; change all mode 67 references to 37
      59                                
      60 000000                         	.asect				; absolute load image
      61                                
      62        000046                  	.=46
      63 000046 000000                  	.word	0			; not used
      64        000052                  	.=52
      65 000052 000000                  	.word	0			; run options
      66                                
      67        000200                  	.=200
      68 000200 000137  002200          	jmp	@#start			; standard diag entry
      69                                
      70                                ; --------------------------------------------------------------------------------
      71                                
      72                                .sbttl	global variables
      73                                
      74        002000                  	.=2000
      75 002000 177777                  stack:	.word	-1			; top of stack
      76 002002 000000                  optswi:	.word	0			; option switches, bit0 = run with ECC enabled
      77 002004 000024                  numpas:	.word	20.			; number of passes to run
      78 002006 000000                  blmin:	.word	blmn			; set to blmn
      79 002010 007577                  blmax:	.word	blmx18			; set to either blmx18/blmx22
      80 002012 000000                  membl:	.word	0			; memory size in blocks
      81 002014 000000                  membyl:	.word	0			; memory size in bytes, lsb
      82 002016 000000                  membyh:	.word	0			; memory size in bytes, msb
      83 002020 000000                  blbeg:	.word	0			; begin block number for tests
      84 002022 000000                  blend:	.word	0			; end   block number for tests
      85 002024 001777                  blmsk:	.word	1777			; 16K device boundary address mask
      86 002026 000000                  protmn:	.word	0			; begin block number of protected space
      87 002030 000177                  protmx:	.word	<pgprgn*pgszbl>-1	; end block number of protected space
      88 002032 000000                  mcrmsk:	.word	0			; bitmask of mcsr's that exist
      89 002034 000000                  flg22b:	.word	0			; set nonzero for 22b system
      90 002036 000000                  errors:	.word	0			; count errors
      91 002040 000000                  passes:	.word	0			; count passes
      92 002042 000000                  testno:	.word	0			; current test number
      93        002044                  phyadr:	.blkw	2			; physical address of error
      94                                	.even
      95                                
      96                                ; --------------------------------------------------------------------------------
      97                                
      98                                .sbttl	program start
      99                                
     100 002050                         	align	7			; pc alignment
       9                                .list
     101                                
     102 002200 012706  002000          start:	mov	#stack,sp		; setup a stack
     103 002204 000005                  	reset				; reset the world
     104                                
     105 002206                         	trapcatcher <2,200,206,400>	; setup a trapcatcher in low vector space
       1 002206 012700  002236          	mov	#32770$,r0    		; ptr to table
       2 002212 012001                  32768$:	mov	(r0)+,r1		; start addr
       3 002214 100415                  	bmi	32771$			; done?
       4 002216 012002                  	mov	(r0)+,r2		; end addr
       5 002220 010161  177776          32769$:	mov	r1,-2(r1)		; point vector at next word
       6 002224 005011                  	clr	(r1)			; <0> which is a halt
       7 002226 022121                  	cmp	(r1)+,(r1)+		; add four to ptr
       8 002230 020102                  	cmp	r1,r2			; reached end?
       9 002232 003772                  	ble	32769$			; not yet
      10 002234 000766                  	br	32768$			; more
      11 002236 000002  000200  000206  32770$:	.word	2,200,206,400, -1
         002244 000400  177777          
      12 002250 000240                  32771$:	nop				; placeholder
     106                                
     107 002252                         	printf	#msg1			; say hello
       1 002252                         	calls	printf #msg1               
       8                                .list
       9 002252 012746  007726          	mov	#msg1,-(sp)
       1                                .list
       2 002256                         	call	printf
       1 002256 004737  010766          	jsr	pc,printf
       3 002262 062706  000002          	add	#2,sp
      18                                .list
     108                                
     109 002266 005037  002036          	clr	errors			; none yet
     110 002272 005037  002040          	clr	passes			; ditto
     111                                
     112                                	; test for memmgt, exit if none available
     113                                
     114 002276 012700  177572          	mov	#mmr0,r0		; main memmgt control
     115 002302                         	call	adrchk			; check if exists
       1 002302 004737  010714          	jsr	pc,adrchk
     116 002306 103440                  	bcs	99$			; br if OK
     117                                
     118 002310                         	printf	#70$			; print a message
       1 002310                         	calls	printf #70$               
       8                                .list
       9 002310 012746  002330          	mov	#70$,-(sp)
       1                                .list
       2 002314                         	call	printf
       1 002314 004737  010766          	jsr	pc,printf
       3 002320 062706  000002          	add	#2,sp
      18                                .list
     119 002324 000137  007700          	jmp	exit			; just exit	
     120                                
     121 002330    015     012     124  70$:	.asciz	<cr><lf>"This diagnostic requires memory management"<cr><lf>
         002333    150     151     163  
         002336    040     144     151  
         002341    141     147     156  
         002344    157     163     164  
         002347    151     143     040  
         002352    162     145     161  
         002355    165     151     162  
         002360    145     163     040  
         002363    155     145     155  
         002366    157     162     171  
         002371    040     155     141  
         002374    156     141     147  
         002377    145     155     145  
         002402    156     164     015  
         002405    012     000          
     122 002407    000                  	.even
     123                                
     124 002410 000240                  99$:	nop
     125                                
     126                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     127                                
     128                                .sbttl	setup/enable memory management
     129                                
     130 002412 012701  172300          enmmgt:	mov	#kpdr,r1		; base register
     131 002416 012702  000010          	mov	#8.,r2			; number of reg pairs
     132 002422 005061  000040          1$:	clr	kpar-kpdr(r1)		; init KPAR[n]
     133 002426 012721  077400          	mov	#pgnone,(r1)+		; init KPDR[n]
     134 002432 077205                  	sob	r2,1$			; loop over all pairs
     135                                
     136 002434 012701  172300          	mov	#kpdr+<2*pgprg>,r1	; ptr to first base register
     137 002440 012702  000001          	mov	#pgprgn,r2		; number of program pages
     138 002444 012703  000000          	mov	#0, r3			; first physical block address
     139 002450 010361  000040          2$:	mov	r3,kpar-kpdr(r1)	; init KPAR[n]
     140 002454 012721  077406          	mov	#pgrw,(r1)+		; init KPDR[n] as r/w page
     141 002460 062703  000200          	add	#pgszbl,r3		; incr physical block address
     142 002464 077207                  	sob	r2,2$			; loop over all pages
     143                                
     144 002466 010337  172354          	mov	r3,@#kpar+<pgtst*2>	; map test page to physical 8KB
     145 002472 012737  077406  172314  	mov	#pgrw,@#kpdr+<pgtst*2>	; full page, r/w access
     146                                
     147 002500 012737  177600  172356  	mov	#511.*pgszbl,@#kpar+<pgios*2> ; map iopage to physical last page
     148 002506 012737  077406  172316  	mov	#pgrw,@#kpdr+<pgios*2>	; full page, r/w access
     149                                
     150 002514 012737  000000  002034  	mov	#0,flg22b		; set 18b flag
     151 002522 012737  007577  002010  	mov	#blmx18,blmax		; set maximum block number, 18b
     152                                
     153 002530 032737  170000  172356  	bit	#170000,@#kpar+<pgios*2> ; could we set the 22b physical addr bits?
     154 002536 001420                  	beq	5$			; br if not, 18b system
     155                                
     156 002540 012700  177746          	mov	#ccsr,r0		; cache control register
     157 002544                         	call	adrchk			; check if exists
       1 002544 004737  010714          	jsr	pc,adrchk
     158 002550 103002                  	bcc	4$			; br if not
     159 002552 012710  000014          	mov	#bit3+bit2,(r0)		; force miss high/low (disable cache)
     160                                
     161 002556 012737  177777  002034  4$:	mov	#-1,flg22b		; set 22b flag
     162 002564 012737  167777  002010  	mov	#blmx22,blmax		; set maximum block number, 22b
     163 002572 012737  000020  172516  	mov	#bit4,@#mmr3		; enable 22b mem mgt mode	
     164                                
     165 002600 012737  000001  177572  5$:	mov	#bit0,@#mmr0		; turn on mem mgt, hope we don't die...
     166                                
     167                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     168                                
     169                                .sbttl	size physical memory
     170                                
     171 002606 013701  002006          msizer:	mov	blmin,r1		; first available physical block
     172 002612 012700  140000          	mov	#tstmin,r0		; test at this address
     173                                
     174 002616 010137  172354          1$:	mov	r1,@#tstpar		; point test page at physical page
     175 002622                         	call	adrchk			; test the address in R0, may fail
       1 002622 004737  010714          	jsr	pc,adrchk
     176 002626 103005                  	bcc	2$			; br if not there
     177 002630 005201                  	inc	r1			; bump to next block
     178 002632 020137  002010          	cmp	r1,blmax		; hit end of blocks?
     179 002636 001367                  	bne	1$			; not yet, keep looping
     180 002640 005201                  	inc	r1			; no trap, point at next block
     181                                
     182 002642 010137  002012          2$:	mov	r1,membl		; save number of memory blocks
     183                                
     184 002646 013700  002012          	mov	membl,r0		; size in blocks
     185 002652 070027  000100          	mul	#blszby,r0		; compute memory size, bytes
     186 002656 042700  177700          	bic	#^c77,r0		; max limit is 4096KB
     187 002662 010137  002014          	mov	r1,membyl		; size in bytes, lsb
     188 002666 010037  002016          	mov	r0,membyh		; size in bytes, msb
     189                                
     190 002672 013701  002012          	mov	membl,r1		; size in blocks, lsb
     191 002676 005000                  	clr	r0			; msb
     192 002700 071027  000020          	div	#16.,r0			; size in Kbytes
     193                                
     194 002704                         	printf	#msg4,r0,membyh,membyl	; format, size in KB, size msb, size lsb
       1 002704                         	calls	printf #msg4 r0 membyh membyl            
       8                                .list
       9 002704 013746  002014          	mov	membyl,-(sp)
      14                                .list
      15 002710 013746  002016          	mov	membyh,-(sp)
      20                                .list
      21 002714 010046                  	mov	r0,-(sp)
      26                                .list
      27 002716 012746  010033          	mov	#msg4,-(sp)
       1                                .list
       2 002722                         	call	printf
       1 002722 004737  010766          	jsr	pc,printf
       3 002726 062706  000010          	add	#10,sp
      18                                .list
     195                                
     196 002732 013737  002006  002020  	mov	blmin,blbeg		; min test block number
     197 002740 013737  002012  002022  	mov	membl,blend		; max test block number
     198 002746 005337  002022          	dec	blend			;
     199                                
     200 002752 013737  002006  002026  	mov	blmin, protmn		; begin block number of protected space
     201 002760 012737  000177  002030  	mov	#<pgprgn*pgszbl>-1,protmx ; end block number of protected space
     202                                
     203                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     204                                
     205                                .sbttl	determine number of memory control registers
     206                                
     207 002766 012700  172100          mcrdet:	mov	#mcr0,r0		; ptr to first memory csr
     208 002772 012701  000001          	mov	#bit0,r1		; bit mask counter
     209 002776 005002                  	clr	r2			; bitmask of csr found
     210 003000 012703  000020          	mov	#16.,r3			; maximum number of registers
     211 003004                         	printf	#msg5a			; memory control register header
       1 003004                         	calls	printf #msg5a               
       8                                .list
       9 003004 012746  010104          	mov	#msg5a,-(sp)
       1                                .list
       2 003010                         	call	printf
       1 003010 004737  010766          	jsr	pc,printf
       3 003014 062706  000002          	add	#2,sp
      18                                .list
     212                                
     213 003020                         1$:	call	adrchk			; check if (r0) exists
       1 003020 004737  010714          	jsr	pc,adrchk
     214 003024 103011                  	bcc	2$			; br if not
     215 003026 005010                  	clr	(r0)			; init a csr
     216 003030                         	printf	#msg5b,r0		; print register address
       1 003030                         	calls	printf #msg5b r0              
       8                                .list
       9 003030 010046                  	mov	r0,-(sp)
      14                                .list
      15 003032 012746  010141          	mov	#msg5b,-(sp)
       1                                .list
       2 003036                         	call	printf
       1 003036 004737  010766          	jsr	pc,printf
       3 003042 062706  000004          	add	#4,sp
      18                                .list
     217 003046 050102                  	bis	r1,r2			; indicate present
     218 003050 006301                  2$:	asl	r1			; shift mask left
     219 003052 062700  000002          	add	#2,r0			; bump pointer
     220 003056 077320                  	sob	r3,1$			; loop
     221                                
     222 003060 010237  002032          	mov	r2,mcrmsk		; save bitmask of memory csrs
     223 003064 001006                  	bne	3$			; br if at least one
     224 003066                         	printf	#msg5c			; message about none
       1 003066                         	calls	printf #msg5c               
       8                                .list
       9 003066 012746  010147          	mov	#msg5c,-(sp)
       1                                .list
       2 003072                         	call	printf
       1 003072 004737  010766          	jsr	pc,printf
       3 003076 062706  000002          	add	#2,sp
      18                                .list
     225 003102                         3$:	printf	#crlf			; done
       1 003102                         	calls	printf #crlf               
       8                                .list
       9 003102 012746  010157          	mov	#crlf,-(sp)
       1                                .list
       2 003106                         	call	printf
       1 003106 004737  010766          	jsr	pc,printf
       3 003112 062706  000002          	add	#2,sp
      18                                .list
     226                                
     227                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     228                                
     229                                .sbttl	set psw to zero
     230                                
     231 003116 005046                  	clr	-(sp)			; zap psw
     232 003120 012746  003126          	mov	#loop,-(sp)		; fake pc
     233 003124 000002                  	rti				; reload psw
     234                                
     235                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     236                                
     237 003126 000240                  loop:	nop				; next pass enters here
     238 003130 012737  000001  002042  	mov	#1,testno		; current test number
     239                                
     240                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     241                                
     242 003136                         	test	<constant data patterns>
       1                                .list
       2                                
       3                                	;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       4                                	.sbttl	Test1 - constant data patterns
       5                                	;------------------------------------------------------------
       6                                
       7                                test1:	; start of test
       8                                
       9 003136 022737  000001  002042  	cmp	#1,testno		; check for sequence error
      10 003144 001401                  	beq	.+4			; OK, skip over halt
      11 003146 000000                  	halt				; FATAL - SEQUENCE ERROR
      18                                .list
     243                                
     244 003150                         	printf	#70$,testno		; header message
       1 003150                         	calls	printf #70$ testno              
       8                                .list
       9 003150 013746  002042          	mov	testno,-(sp)
      14                                .list
      15 003154 012746  003540          	mov	#70$,-(sp)
       1                                .list
       2 003160                         	call	printf
       1 003160 004737  010766          	jsr	pc,printf
       3 003164 062706  000004          	add	#4,sp
      18                                .list
     245                                
     246 003170                         	call	disecc			; disable ecc
       1 003170 004737  010336          	jsr	pc,disecc
     247                                
     248 003174 012737  000141  003536  	mov	#<'a>,63$		; subtest index
     249 003202 012737  003512  003510  	mov	#61$,60$		; ptr to data table
     250 003210 013703  003510          1$:	mov	60$,r3			; get pattern address
     251 003214 011302                  	mov	(r3),r2			; get expected pattern
     252 003216                         	printf	#72$,testno,63$,r2,r2	; subheader message
       1 003216                         	calls	printf #72$ testno 63$ r2 r2           
       8                                .list
       9 003216 010246                  	mov	r2,-(sp)
      14                                .list
      15 003220 010246                  	mov	r2,-(sp)
      20                                .list
      21 003222 013746  003536          	mov	63$,-(sp)
      26                                .list
      27 003226 013746  002042          	mov	testno,-(sp)
      32                                .list
      33 003232 012746  003737          	mov	#72$,-(sp)
       1                                .list
       2 003236                         	call	printf
       1 003236 004737  010766          	jsr	pc,printf
       3 003242 062706  000012          	add	#12,sp
      18                                .list
     253                                
     254                                	; fill each block with a constant data pattern
     255                                
     256 003246 013705  002020          	mov	blbeg,r5		; starting block number
     257 003252                         10$:	call	adrtst			; check ok to test this block
       1 003252 004737  010312          	jsr	pc,adrtst
     258 003256 103016                  	bcc	12$			; br if not
     259 003260 010537  172354          	mov	r5,@#tstpar		; point mmu at test block
     260 003264 012704  140000          	mov	#tstmin,r4		; start block address
     261 003270 012703  000040          	mov	#tstwc,r3		; this many words
     262 003274 005102                  11$:	com	r2			; invert pattern
     263 003276 010214                  	mov	r2,(r4)			; write as a word
     264 003300 005102                  	com	r2			; back to normal
     265 003302 110224                  	movb	r2,(r4)+		; write first byte
     266 003304 000302                  	swab	r2			; flip
     267 003306 110224                  	movb	r2,(r4)+		; write second byte
     268 003310 000302                  	swab	r2			; back to normal
     269 003312 077310                  	sob	r3,11$			; loop for block size
     270 003314 005205                  12$:	inc	r5			; incr test block
     271 003316 020537  002022          	cmp	r5,blend		; at the end?
     272 003322 101753                  	blos	10$			; br if more to do
     273                                
     274                                	; check each block has its pattern
     275                                
     276 003324 013705  002020          	mov	blbeg,r5		; starting block number
     277 003330                         20$:	call	adrtst			; check ok to test this block
       1 003330 004737  010312          	jsr	pc,adrtst
     278 003334 103045                  	bcc	24$			; br if not
     279 003336 010537  172354          	mov	r5,@#tstpar		; point mmu at test block
     280 003342 012704  140000          	mov	#tstmin,r4		; start block address
     281 003346 012703  000040          	mov	#tstwc,r3		; this many words
     282 003352 012401                  21$:	mov	(r4)+,r1		; get block address
     283        000000                  .if ne fails
     284                                	cmp	#1,passes		; only fail on pass2
     285                                	bne	66$			; br if OK
     286                                	cmp	r4,#tstmin+74+2		; fail offset
     287                                	bne	66$			; br if not
     288                                	cmp	r5,#123456		; first fail block
     289                                	bne	66$			; br if not
     290                                	com	r1			; yes, fudge data
     291                                66$:	nop				; placeholder
     292                                .endc
     293 003354 020201                  	cmp	r2,r1			; compare expected:received
     294 003356 001433                  	beq	23$			; br if matches
     295                                
     296 003360 010446                  	mov	r4,-(sp)		; virtual address of error
     297 003362 162716  000002          	sub	#2,(sp)			; backup
     298 003366                         	call	adrxlt			; translate to physical
       1 003366 004737  010162          	jsr	pc,adrxlt
     299 003372                         	printf	#71$,testno,63$,phyadr+0,phyadr+2,r2,r1 ; format, test, addrhi/lo, exp, rcv
       1 003372                         	calls	printf #71$ testno 63$ phyadr+0 phyadr+2 r2 r1         
       8                                .list
       9 003372 010146                  	mov	r1,-(sp)
      14                                .list
      15 003374 010246                  	mov	r2,-(sp)
      20                                .list
      21 003376 013746  002046          	mov	phyadr+2,-(sp)
      26                                .list
      27 003402 013746  002044          	mov	phyadr+0,-(sp)
      32                                .list
      33 003406 013746  003536          	mov	63$,-(sp)
      38                                .list
      39 003412 013746  002042          	mov	testno,-(sp)
      44                                .list
      45 003416 012746  003603          	mov	#71$,-(sp)
       1                                .list
       2 003422                         	call	printf
       1 003422 004737  010766          	jsr	pc,printf
       3 003426 062706  000016          	add	#16,sp
      18                                .list
     300                                
     301 003432 005237  002036          22$:	inc	errors			; count errors
     302 003436 001775                  	beq	22$			;
     303 003440 053705  002024          	bis	blmsk,r5		; bump to last block...
     304 003444 000401                  	br	24$			; exit early...
     305                                
     306 003446 077337                  23$:	sob	r3,21$			; loop for block size
     307                                
     308 003450 005205                  24$:	inc	r5			; incr test block
     309 003452 020537  002022          	cmp	r5,blend		; at the end?
     310 003456 101724                  	blos	20$			; br if more to do
     311                                
     312 003460 005237  003536          	inc	63$			; bump index id
     313 003464 062737  000002  003510  	add	#2,60$			; bump ptr
     314 003472 022737  003536  003510  	cmp	#62$,60$		; end of table?
     315 003500 001243                  	bne	1$			; br if not yet
     316                                
     317 003502                         	call	enbecc			; check for errors, reenable ecc
       1 003502 004737  010420          	jsr	pc,enbecc
     318                                
     319 003506 000537                  	br	99$			; next test
     320                                
     321 003510 003512                  60$:	.word	61$			; ptr to data table
     322                                					;
     323 003512 000000                  61$:	.word	^b0000000000000000	;\
     324 003514 177777                  	.word	^b1111111111111111	; \
     325 003516 000377                  	.word	^b0000000011111111	; |
     326 003520 177400                  	.word	^b1111111100000000	; |
     327 003522 007417                  	.word	^b0000111100001111	; | -- table of patterns
     328 003524 170360                  	.word	^b1111000011110000	; |
     329 003526 031463                  	.word	^b0011001100110011	; |
     330 003530 146314                  	.word	^b1100110011001100	; |
     331 003532 052525                  	.word	^b0101010101010101	; /
     332 003534 125252                  	.word	^b1010101010101010	;/
     333                                62$:					;
     334                                					; end of table
     335        003536                  63$:	.blkw	1.			; subtest index
     336                                
     337 003540    015     012     124  70$:	.asciz	<cr><lf>"Test%d: constant data patterns"<cr><lf>
         003543    145     163     164  
         003546    045     144     072  
         003551    040     143     157  
         003554    156     163     164  
         003557    141     156     164  
         003562    040     144     141  
         003565    164     141     040  
         003570    160     141     164  
         003573    164     145     162  
         003576    156     163     015  
         003601    012     000          
     338 003603    124     145     163  71$:	.ascii	"Test%d%c: constant data patterns failure"<cr><lf>
         003606    164     045     144  
         003611    045     143     072  
         003614    040     143     157  
         003617    156     163     164  
         003622    141     156     164  
         003625    040     144     141  
         003630    164     141     040  
         003633    160     141     164  
         003636    164     145     162  
         003641    156     163     040  
         003644    146     141     151  
         003647    154     165     162  
         003652    145     015     012  
     339 003655    040     040     120  	.ascii	"  PhysAddr  Exp'ed  Rcv'ed"<cr><lf>
         003660    150     171     163  
         003663    101     144     144  
         003666    162     040     040  
         003671    105     170     160  
         003674    047     145     144  
         003677    040     040     122  
         003702    143     166     047  
         003705    145     144     015  
         003710    012                  
     340 003711    040     040     045  	.asciz	"  %.8lp  %.6o  %.6o"<cr><lf>
         003714    056     070     154  
         003717    160     040     040  
         003722    045     056     066  
         003725    157     040     040  
         003730    045     056     066  
         003733    157     015     012  
         003736    000                  
     341 003737    124     145     163  72$:	.asciz	"Test%d%c: data pattern %.6o (%.16b)"<cr><lf>
         003742    164     045     144  
         003745    045     143     072  
         003750    040     144     141  
         003753    164     141     040  
         003756    160     141     164  
         003761    164     145     162  
         003764    156     040     045  
         003767    056     066     157  
         003772    040     050     045  
         003775    056     061     066  
         004000    142     051     015  
         004003    012     000          
     342 004005    000                  	.even
     343                                
     344 004006 005237  002042          99$:	inc	testno			; count tests
     345                                
     346                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     347                                
     348 004012                         	test	<unique physical block select test>
       1                                .list
       2                                
       3                                	;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       4                                	.sbttl	Test2 - unique physical block select test
       5                                	;------------------------------------------------------------
       6                                
       7                                test2:	; start of test
       8                                
       9 004012 022737  000002  002042  	cmp	#2,testno		; check for sequence error
      10 004020 001401                  	beq	.+4			; OK, skip over halt
      11 004022 000000                  	halt				; FATAL - SEQUENCE ERROR
      18                                .list
     349                                
     350 004024                         	printf	#70$,testno		; header message
       1 004024                         	calls	printf #70$ testno              
       8                                .list
       9 004024 013746  002042          	mov	testno,-(sp)
      14                                .list
      15 004030 012746  004250          	mov	#70$,-(sp)
       1                                .list
       2 004034                         	call	printf
       1 004034 004737  010766          	jsr	pc,printf
       3 004040 062706  000004          	add	#4,sp
      18                                .list
     351                                
     352 004044                         	call	disecc			; disable ecc
       1 004044 004737  010336          	jsr	pc,disecc
     353                                
     354                                	; fill each block with its address
     355                                
     356 004050 013705  002020          	mov	blbeg,r5		; starting block number
     357 004054                         10$:	call	adrtst			; check ok to test this block
       1 004054 004737  010312          	jsr	pc,adrtst
     358 004060 103010                  	bcc	12$			; br if not
     359 004062 010537  172354          	mov	r5,@#tstpar		; point mmu at test block
     360 004066 012704  140000          	mov	#tstmin,r4		; start block address
     361 004072 012703  000040          	mov	#tstwc,r3		; this many words
     362 004076 010524                  11$:	mov	r5,(r4)+		; fill with block address
     363 004100 077302                  	sob	r3,11$			; loop for block size
     364 004102 005205                  12$:	inc	r5			; incr test block
     365 004104 020537  002022          	cmp	r5,blend		; at the end?
     366 004110 101761                  	blos	10$			; br if more to do
     367                                
     368                                	; check each block has its address
     369                                
     370 004112 013705  002020          	mov	blbeg,r5		; starting block number
     371 004116                         20$:	call	adrtst			; check ok to test this block
       1 004116 004737  010312          	jsr	pc,adrtst
     372 004122 103043                  	bcc	24$			; br if not
     373 004124 010537  172354          	mov	r5,@#tstpar		; point mmu at test block
     374 004130 012704  140000          	mov	#tstmin,r4		; start block address
     375 004134 012703  000040          	mov	#tstwc,r3		; this many words
     376 004140 012402                  21$:	mov	(r4)+,r2		; get block address
     377        000000                  .if ne fails
     378                                	cmp	#1,passes		; only fail on pass2
     379                                	bne	66$			; br if OK
     380                                	cmp	r4,#tstmin+4+2		; fail offset
     381                                	bne	66$			; br if not
     382                                	cmp	r5,#004321		; first fail block
     383                                	bne	66$			; br if not
     384                                	com	r2			; yes, fudge data
     385                                66$:	nop				; placeholder
     386                                .endc
     387 004142 020502                  	cmp	r5,r2			; compare expected:received
     388 004144 001431                  	beq	23$			; br if matches
     389                                
     390 004146 010446                  	mov	r4,-(sp)		; virtual address of error
     391 004150 162716  000002          	sub	#2,(sp)			; backup
     392 004154                         	call	adrxlt			; translate to physical
       1 004154 004737  010162          	jsr	pc,adrxlt
     393 004160                         	printf	#71$,testno,phyadr+0,phyadr+2,r5,r2 ; format, test, addrhi/lo, exp, rcv
       1 004160                         	calls	printf #71$ testno phyadr+0 phyadr+2 r5 r2          
       8                                .list
       9 004160 010246                  	mov	r2,-(sp)
      14                                .list
      15 004162 010546                  	mov	r5,-(sp)
      20                                .list
      21 004164 013746  002046          	mov	phyadr+2,-(sp)
      26                                .list
      27 004170 013746  002044          	mov	phyadr+0,-(sp)
      32                                .list
      33 004174 013746  002042          	mov	testno,-(sp)
      38                                .list
      39 004200 012746  004321          	mov	#71$,-(sp)
       1                                .list
       2 004204                         	call	printf
       1 004204 004737  010766          	jsr	pc,printf
       3 004210 062706  000014          	add	#14,sp
      18                                .list
     394                                
     395 004214 005237  002036          22$:	inc	errors			; count errors
     396 004220 001775                  	beq	22$			;
     397 004222 053705  002024          	bis	blmsk,r5		; bump to last block...
     398 004226 000401                  	br	24$			; exit early...
     399                                
     400 004230 077335                  23$:	sob	r3,21$			; loop for block size
     401                                
     402 004232 005205                  24$:	inc	r5			; incr test block
     403 004234 020537  002022          	cmp	r5,blend		; at the end?
     404 004240 101726                  	blos	20$			; br if more to do
     405                                
     406 004242                         	call	enbecc			; check for errors, reenable ecc
       1 004242 004737  010420          	jsr	pc,enbecc
     407                                
     408 004246 000505                  	br	99$			; next test
     409                                
     410 004250    015     012     124  70$:	.asciz	<cr><lf>"Test%d: unique physical block select"<cr><lf>
         004253    145     163     164  
         004256    045     144     072  
         004261    040     165     156  
         004264    151     161     165  
         004267    145     040     160  
         004272    150     171     163  
         004275    151     143     141  
         004300    154     040     142  
         004303    154     157     143  
         004306    153     040     163  
         004311    145     154     145  
         004314    143     164     015  
         004317    012     000          
     411 004321    124     145     163  71$:	.ascii	"Test%d: unique physical block select failure"<cr><lf>
         004324    164     045     144  
         004327    072     040     165  
         004332    156     151     161  
         004335    165     145     040  
         004340    160     150     171  
         004343    163     151     143  
         004346    141     154     040  
         004351    142     154     157  
         004354    143     153     040  
         004357    163     145     154  
         004362    145     143     164  
         004365    040     146     141  
         004370    151     154     165  
         004373    162     145     015  
         004376    012                  
     412 004377    040     040     120  	.ascii	"  PhysAddr  Exp'ed  Rcv'ed"<cr><lf>
         004402    150     171     163  
         004405    101     144     144  
         004410    162     040     040  
         004413    105     170     160  
         004416    047     145     144  
         004421    040     040     122  
         004424    143     166     047  
         004427    145     144     015  
         004432    012                  
     413 004433    040     040     045  	.asciz	"  %.8lp  %.6o  %.6o"<cr><lf>
         004436    056     070     154  
         004441    160     040     040  
         004444    045     056     066  
         004447    157     040     040  
         004452    045     056     066  
         004455    157     015     012  
         004460    000                  
     414 004461    000                  	.even
     415                                
     416 004462 005237  002042          99$:	inc	testno			; count tests
     417                                
     418                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     419                                
     420 004466                         	test	<unique physical block address test>
       1                                .list
       2                                
       3                                	;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       4                                	.sbttl	Test3 - unique physical block address test
       5                                	;------------------------------------------------------------
       6                                
       7                                test3:	; start of test
       8                                
       9 004466 022737  000003  002042  	cmp	#3,testno		; check for sequence error
      10 004474 001401                  	beq	.+4			; OK, skip over halt
      11 004476 000000                  	halt				; FATAL - SEQUENCE ERROR
      18                                .list
     421                                
     422 004500                         	printf	#70$,testno		; header message
       1 004500                         	calls	printf #70$ testno              
       8                                .list
       9 004500 013746  002042          	mov	testno,-(sp)
      14                                .list
      15 004504 012746  004716          	mov	#70$,-(sp)
       1                                .list
       2 004510                         	call	printf
       1 004510 004737  010766          	jsr	pc,printf
       3 004514 062706  000004          	add	#4,sp
      18                                .list
     423                                
     424 004520                         	call	disecc			; disable ecc
       1 004520 004737  010336          	jsr	pc,disecc
     425                                
     426                                	; iterate over all memory blocks
     427                                
     428 004524 013705  002020          	mov	blbeg,r5		; starting block number
     429 004530                         10$:	call	adrtst			; check ok to test this block
       1 004530 004737  010312          	jsr	pc,adrtst
     430 004534 103061                  	bcc	34$			; br if not
     431 004536 010537  172354          	mov	r5,@#tstpar		; point mmu at test block
     432                                
     433                                	; fill each word in the block with a unique pattern
     434                                
     435 004542 012704  140000          	mov	#tstmin,r4		; start block address
     436 004546 012703  000040          	mov	#tstwc,r3		; this many words
     437 004552 110324                  20$:	movb	r3,(r4)+		; fill low byte with count
     438 004554 005103                  	com	r3			; invert
     439 004556 110324                  	movb	r3,(r4)+		; fill low byte with ~count
     440 004560 005103                  	com	r3			; invert
     441 004562 077305                  	sob	r3,20$			; loop for block size
     442                                
     443                                	; now check the pattern is the same
     444                                
     445 004564 012704  140000          	mov	#tstmin,r4		; start block address
     446 004570 012703  000040          	mov	#tstwc,r3		; this many words
     447 004574 012402                  30$:	mov	(r4)+,r2		; get test data
     448 004576 005001                  	clr	r1			;    0|0
     449 004600 150301                  	bisb	r3,r1			;    0|cnt
     450 004602 105101                  	comb	r1			;    0|~cnt
     451 004604 000301                  	swab	r1			; ~cnt|0
     452 004606 150301                  	bisb	r3,r1			; ~cnt|cnt
     453        000000                  .if ne fails
     454                                	cmp	#1,passes		; only fail on pass2
     455                                	bne	66$			; br if OK
     456                                	cmp	r4,#tstmin+36+2		; fail offset
     457                                	bne	66$			; br if not
     458                                	cmp	r5,#000123		; first fail block
     459                                	bne	66$			; br if not
     460                                	com	r2			; yes, fudge data
     461                                66$:	nop				; placeholder
     462                                .endc
     463 004610 020102                  	cmp	r1,r2			; check matches
     464 004612 001431                  	beq	32$			; br if OK
     465                                
     466 004614 010446                  	mov	r4,-(sp)		; virtual address of error
     467 004616 162716  000002          	sub	#2,(sp)			; backup
     468 004622                         	call	adrxlt			; translate to physical
       1 004622 004737  010162          	jsr	pc,adrxlt
     469 004626                         	printf	#71$,testno,phyadr+0,phyadr+2,r1,r2 ; format, test, addrhi/lo, exp, rcv
       1 004626                         	calls	printf #71$ testno phyadr+0 phyadr+2 r1 r2          
       8                                .list
       9 004626 010246                  	mov	r2,-(sp)
      14                                .list
      15 004630 010146                  	mov	r1,-(sp)
      20                                .list
      21 004632 013746  002046          	mov	phyadr+2,-(sp)
      26                                .list
      27 004636 013746  002044          	mov	phyadr+0,-(sp)
      32                                .list
      33 004642 013746  002042          	mov	testno,-(sp)
      38                                .list
      39 004646 012746  004770          	mov	#71$,-(sp)
       1                                .list
       2 004652                         	call	printf
       1 004652 004737  010766          	jsr	pc,printf
       3 004656 062706  000014          	add	#14,sp
      18                                .list
     470                                
     471 004662 005237  002036          31$:	inc	errors			; count errors
     472 004666 001775                  	beq	31$			;
     473 004670 053705  002024          	bis	blmsk,r5		; bump to last block...
     474 004674 000401                  	br	34$			; exit early...
     475                                
     476 004676 077342                  32$:	sob	r3,30$			; loop for block size
     477                                
     478 004700 005205                  34$:	inc	r5			; incr test block
     479 004702 020537  002022          	cmp	r5,blend		; at the end?
     480 004706 101710                  	blos	10$			; br if more to do
     481                                
     482 004710                         	call	enbecc			; check for errors, reenable ecc
       1 004710 004737  010420          	jsr	pc,enbecc
     483                                
     484 004714 000506                  	br	99$			; next test
     485                                
     486 004716    015     012     124  70$:	.asciz	<cr><lf>"Test%d: unique physical block address"<cr><lf>
         004721    145     163     164  
         004724    045     144     072  
         004727    040     165     156  
         004732    151     161     165  
         004735    145     040     160  
         004740    150     171     163  
         004743    151     143     141  
         004746    154     040     142  
         004751    154     157     143  
         004754    153     040     141  
         004757    144     144     162  
         004762    145     163     163  
         004765    015     012     000  
     487 004770    124     145     163  71$:	.ascii	"Test%d: unique physical block address failure"<cr><lf>
         004773    164     045     144  
         004776    072     040     165  
         005001    156     151     161  
         005004    165     145     040  
         005007    160     150     171  
         005012    163     151     143  
         005015    141     154     040  
         005020    142     154     157  
         005023    143     153     040  
         005026    141     144     144  
         005031    162     145     163  
         005034    163     040     146  
         005037    141     151     154  
         005042    165     162     145  
         005045    015     012          
     488 005047    040     040     120  	.ascii	"  PhysAddr  Exp'ed  Rcv'ed"<cr><lf>
         005052    150     171     163  
         005055    101     144     144  
         005060    162     040     040  
         005063    105     170     160  
         005066    047     145     144  
         005071    040     040     122  
         005074    143     166     047  
         005077    145     144     015  
         005102    012                  
     489 005103    040     040     045  	.asciz	"  %.8lp  %.6o  %.6o"<cr><lf>
         005106    056     070     154  
         005111    160     040     040  
         005114    045     056     066  
         005117    157     040     040  
         005122    045     056     066  
         005125    157     015     012  
         005130    000                  
     490 005131    000                  	.even
     491                                
     492 005132 005237  002042          99$:	inc	testno			; count tests
     493                                
     494                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     495                                
     496 005136                         	test	<extended march c- data test>
       1                                .list
       2                                
       3                                	;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       4                                	.sbttl	Test4 - extended march c- data test
       5                                	;------------------------------------------------------------
       6                                
       7                                test4:	; start of test
       8                                
       9 005136 022737  000004  002042  	cmp	#4,testno		; check for sequence error
      10 005144 001401                  	beq	.+4			; OK, skip over halt
      11 005146 000000                  	halt				; FATAL - SEQUENCE ERROR
      18                                .list
     497                                
     498 005150                         	printf	#70$,testno		; header message
       1 005150                         	calls	printf #70$ testno              
       8                                .list
       9 005150 013746  002042          	mov	testno,-(sp)
      14                                .list
      15 005154 012746  006332          	mov	#70$,-(sp)
       1                                .list
       2 005160                         	call	printf
       1 005160 004737  010766          	jsr	pc,printf
       3 005164 062706  000004          	add	#4,sp
      18                                .list
     499                                
     500 005170                         	call	disecc			; disable ecc
       1 005170 004737  010336          	jsr	pc,disecc
     501                                
     502                                	; extended march c- data test:
     503                                	;
     504                                	;   ud(w0); u(r0,w1,r1); u(r1,w0); d(r0,w1); d(r1,w0); ud(r0)
     505                                
     506                                	; a: ud(w0) - address ascending (or descending) write zero
     507                                
     508 005174                         	printf	#71$,testno		; subheader
       1 005174                         	calls	printf #71$ testno              
       8                                .list
       9 005174 013746  002042          	mov	testno,-(sp)
      14                                .list
      15 005200 012746  006402          	mov	#71$,-(sp)
       1                                .list
       2 005204                         	call	printf
       1 005204 004737  010766          	jsr	pc,printf
       3 005210 062706  000004          	add	#4,sp
      18                                .list
     509 005214 013705  002020          	mov	blbeg,r5		; starting block number
     510 005220                         100$:	call	adrtst			; check ok to test this block
       1 005220 004737  010312          	jsr	pc,adrtst
     511 005224 103010                  	bcc	109$			; br if not
     512 005226 010537  172354          	mov	r5,@#tstpar		; point mmu at test block
     513 005232 012704  140000          	mov	#tstmin,r4		; start block address
     514 005236 012703  000040          	mov	#tstwc,r3		; this many words
     515 005242 005024                  101$:	clr	(r4)+			; write zero
     516 005244 077302                  	sob	r3,101$			; loop for block size
     517 005246 005205                  109$:	inc	r5			; incr test block
     518 005250 020537  002022          	cmp	r5,blend		; at the end?
     519 005254 101761                  	blos	100$			; br if more to do
     520                                
     521                                	; b: u(r0,w1,r1) - address ascending read zero, write one, read one
     522                                
     523 005256                         	printf	#72$,testno		; subheader
       1 005256                         	calls	printf #72$ testno              
       8                                .list
       9 005256 013746  002042          	mov	testno,-(sp)
      14                                .list
      15 005262 012746  006463          	mov	#72$,-(sp)
       1                                .list
       2 005266                         	call	printf
       1 005266 004737  010766          	jsr	pc,printf
       3 005272 062706  000004          	add	#4,sp
      18                                .list
     524 005276 013705  002020          	mov	blbeg,r5		; starting block number
     525 005302                         110$:	call	adrtst			; check ok to test this block
       1 005302 004737  010312          	jsr	pc,adrtst
     526 005306 103075                  	bcc	119$			; br if not
     527 005310 010537  172354          	mov	r5,@#tstpar		; point mmu at test block
     528 005314 012704  140000          	mov	#tstmin,r4		; start block address
     529 005320 012703  000040          	mov	#tstwc,r3		; this many words
     530 005324 012702  177777          	mov	#-1,r2			; write data
     531 005330 011400                  111$:	mov	(r4),r0			; read zero
     532 005332 010214                  	mov	r2,(r4)			; write one
     533 005334 012401                  	mov	(r4)+,r1		; read one
     534 005336 005700                  	tst	r0			; check zero
     535 005340 001426                  	beq	112$			; br if OK
     536 005342 010446                  	mov	r4,-(sp)		; virtual address of error
     537 005344 162716  000002          	sub	#2,(sp)			; backup
     538 005350                         	call	adrxlt			; translate to physical
       1 005350 004737  010162          	jsr	pc,adrxlt
     539 005354                         	printf	#77$,testno,#'b,phyadr+0,phyadr+2,#0,r0 ; format, test, subtest, addrhi/lo, exp, rcv
       1 005354                         	calls	printf #77$ testno #'b phyadr+0 phyadr+2 #0 r0         
       8                                .list
       9 005354 010046                  	mov	r0,-(sp)
      14                                .list
      15 005356 012746  000000          	mov	#0,-(sp)
      20                                .list
      21 005362 013746  002046          	mov	phyadr+2,-(sp)
      26                                .list
      27 005366 013746  002044          	mov	phyadr+0,-(sp)
      32                                .list
      33 005372 012746  000142          	mov	#'b,-(sp)
      38                                .list
      39 005376 013746  002042          	mov	testno,-(sp)
      44                                .list
      45 005402 012746  007153          	mov	#77$,-(sp)
       1                                .list
       2 005406                         	call	printf
       1 005406 004737  010766          	jsr	pc,printf
       3 005412 062706  000016          	add	#16,sp
      18                                .list
     540 005416 005101                  112$:	com	r1			; check one
     541 005420 001427                  	beq	113$			; br if OK
     542 005422 005101                  	com	r1			; restore r1
     543 005424 010446                  	mov	r4,-(sp)		; virtual address of error
     544 005426 162716  000002          	sub	#2,(sp)			; backup
     545 005432                         	call	adrxlt			; translate to physical
       1 005432 004737  010162          	jsr	pc,adrxlt
     546 005436                         	printf	#77$,testno,#'b,phyadr+0,phyadr+2,#-1,r1 ; format, test, subtest, addrhi/lo, exp, rcv
       1 005436                         	calls	printf #77$ testno #'b phyadr+0 phyadr+2 #-1 r1         
       8                                .list
       9 005436 010146                  	mov	r1,-(sp)
      14                                .list
      15 005440 012746  177777          	mov	#-1,-(sp)
      20                                .list
      21 005444 013746  002046          	mov	phyadr+2,-(sp)
      26                                .list
      27 005450 013746  002044          	mov	phyadr+0,-(sp)
      32                                .list
      33 005454 012746  000142          	mov	#'b,-(sp)
      38                                .list
      39 005460 013746  002042          	mov	testno,-(sp)
      44                                .list
      45 005464 012746  007153          	mov	#77$,-(sp)
       1                                .list
       2 005470                         	call	printf
       1 005470 004737  010766          	jsr	pc,printf
       3 005474 062706  000016          	add	#16,sp
      18                                .list
     547 005500 077365                  113$:	sob	r3,111$			; loop for block size
     548 005502 005205                  119$:	inc	r5			; incr test block
     549 005504 020537  002022          	cmp	r5,blend		; at the end?
     550 005510 101674                  	blos	110$			; br if more to do
     551                                
     552                                	; c: u(r1,w0) - address ascending read one, write zero
     553                                
     554 005512                         	printf	#73$,testno		; subheader
       1 005512                         	calls	printf #73$ testno              
       8                                .list
       9 005512 013746  002042          	mov	testno,-(sp)
      14                                .list
      15 005516 012746  006576          	mov	#73$,-(sp)
       1                                .list
       2 005522                         	call	printf
       1 005522 004737  010766          	jsr	pc,printf
       3 005526 062706  000004          	add	#4,sp
      18                                .list
     555 005532 013705  002020          	mov	blbeg,r5		; starting block number
     556 005536                         120$:	call	adrtst			; check ok to test this block
       1 005536 004737  010312          	jsr	pc,adrtst
     557 005542 103042                  	bcc	129$			; br if not
     558 005544 010537  172354          	mov	r5,@#tstpar		; point mmu at test block
     559 005550 012704  140000          	mov	#tstmin,r4		; start block address
     560 005554 012703  000040          	mov	#tstwc,r3		; this many words
     561 005560 011400                  121$:	mov	(r4),r0			; read one
     562 005562 005024                  	clr	(r4)+			; write zero
     563        000000                  .if ne fails
     564                                	cmp	#1,passes		; only fail on pass2
     565                                	bne	67$			; br if OK
     566                                	cmp	r4,#tstmin+16+2		; fail offset
     567                                	bne	67$			; br if not
     568                                	cmp	r5,#001234		; first fail block
     569                                	bne	67$			; br if not
     570                                	dec	r0			; yes, fudge data
     571                                67$:	nop				; placeholder
     572                                .endc
     573 005564 005100                  	com	r0			; zero -> one
     574 005566 001427                  	beq	122$			; br if OK
     575 005570 005100                  	com	r0			; restore r0
     576 005572 010446                  	mov	r4,-(sp)		; virtual address of error
     577 005574 162716  000002          	sub	#2,(sp)			; backup
     578 005600                         	call	adrxlt			; translate to physical
       1 005600 004737  010162          	jsr	pc,adrxlt
     579 005604                         	printf	#77$,testno,#'c,phyadr+0,phyadr+2,#-1,r0 ; format, test, subtest, addrhi/lo, exp, rcv
       1 005604                         	calls	printf #77$ testno #'c phyadr+0 phyadr+2 #-1 r0         
       8                                .list
       9 005604 010046                  	mov	r0,-(sp)
      14                                .list
      15 005606 012746  177777          	mov	#-1,-(sp)
      20                                .list
      21 005612 013746  002046          	mov	phyadr+2,-(sp)
      26                                .list
      27 005616 013746  002044          	mov	phyadr+0,-(sp)
      32                                .list
      33 005622 012746  000143          	mov	#'c,-(sp)
      38                                .list
      39 005626 013746  002042          	mov	testno,-(sp)
      44                                .list
      45 005632 012746  007153          	mov	#77$,-(sp)
       1                                .list
       2 005636                         	call	printf
       1 005636 004737  010766          	jsr	pc,printf
       3 005642 062706  000016          	add	#16,sp
      18                                .list
     580 005646 077334                  122$:	sob	r3,121$			; loop for block size
     581 005650 005205                  129$:	inc	r5			; incr test block
     582 005652 020537  002022          	cmp	r5,blend		; at the end?
     583 005656 101727                  	blos	120$			; br if more to do
     584                                
     585                                	; d: d(r0,w1) - address descending read zero, write one
     586                                
     587 005660                         	printf	#74$,testno		; subheader
       1 005660                         	calls	printf #74$ testno              
       8                                .list
       9 005660 013746  002042          	mov	testno,-(sp)
      14                                .list
      15 005664 012746  006674          	mov	#74$,-(sp)
       1                                .list
       2 005670                         	call	printf
       1 005670 004737  010766          	jsr	pc,printf
       3 005674 062706  000004          	add	#4,sp
      18                                .list
     588 005700 013705  002022          	mov	blend,r5		; ending block number
     589 005704                         130$:	call	adrtst			; check ok to test this block
       1 005704 004737  010312          	jsr	pc,adrtst
     590 005710 103041                  	bcc	139$			; br if not
     591 005712 010537  172354          	mov	r5,@#tstpar		; point mmu at test block
     592 005716 012704  140100          	mov	#tstmax+1,r4		; end block address
     593 005722 012703  000040          	mov	#tstwc,r3		; this many words
     594 005726 012702  177777          	mov	#-1,r2			; write data
     595 005732 014400                  131$:	mov	-(r4),r0		; read zero
     596 005734 010214                  	mov	r2,(r4)			; write one
     597        000000                  .if ne fails
     598                                	cmp	#1,passes		; only fail on pass2
     599                                	bne	66$			; br if OK
     600                                	cmp	r4,#tstmin+26+2		; fail offset
     601                                	bne	66$			; br if not
     602                                	cmp	r5,#012345		; first fail block
     603                                	bne	66$			; br if not
     604                                	inc	r0			; yes, fudge data
     605                                66$:	nop				; placeholder
     606                                .endc
     607 005736 005700                  	tst	r0			; check zero
     608 005740 001424                  	beq	132$			; br if OK
     609 005742 010446                  	mov	r4,-(sp)		; virtual address of error
     610 005744                         	call	adrxlt			; translate to physical
       1 005744 004737  010162          	jsr	pc,adrxlt
     611 005750                         	printf	#77$,testno,#'d,phyadr+0,phyadr+2,#0,r0 ; format, test, subtest, addrhi/lo, exp, rcv
       1 005750                         	calls	printf #77$ testno #'d phyadr+0 phyadr+2 #0 r0         
       8                                .list
       9 005750 010046                  	mov	r0,-(sp)
      14                                .list
      15 005752 012746  000000          	mov	#0,-(sp)
      20                                .list
      21 005756 013746  002046          	mov	phyadr+2,-(sp)
      26                                .list
      27 005762 013746  002044          	mov	phyadr+0,-(sp)
      32                                .list
      33 005766 012746  000144          	mov	#'d,-(sp)
      38                                .list
      39 005772 013746  002042          	mov	testno,-(sp)
      44                                .list
      45 005776 012746  007153          	mov	#77$,-(sp)
       1                                .list
       2 006002                         	call	printf
       1 006002 004737  010766          	jsr	pc,printf
       3 006006 062706  000016          	add	#16,sp
      18                                .list
     612 006012 077331                  132$:	sob	r3,131$			; loop for block size
     613 006014 005305                  139$:	dec	r5			; incr test block
     614 006016 020537  002020          	cmp	r5,blbeg		; at the begin
     615 006022 101330                  	bhi	130$			; br if more to do
     616                                
     617                                	; e: d(r1,w0) - address descending read one, write zero
     618                                
     619 006024                         	printf	#75$,testno		; subheader
       1 006024                         	calls	printf #75$ testno              
       8                                .list
       9 006024 013746  002042          	mov	testno,-(sp)
      14                                .list
      15 006030 012746  006773          	mov	#75$,-(sp)
       1                                .list
       2 006034                         	call	printf
       1 006034 004737  010766          	jsr	pc,printf
       3 006040 062706  000004          	add	#4,sp
      18                                .list
     620 006044 013705  002022          	mov	blend,r5		; ending block number
     621 006050                         140$:	call	adrtst			; check ok to test this block
       1 006050 004737  010312          	jsr	pc,adrtst
     622 006054 103040                  	bcc	149$			; br if not
     623 006056 010537  172354          	mov	r5,@#tstpar		; point mmu at test block
     624 006062 012704  140100          	mov	#tstmax+1,r4		; end block address
     625 006066 012703  000040          	mov	#tstwc,r3		; this many words
     626 006072 014400                  141$:	mov	-(r4),r0		; read one
     627 006074 005014                  	clr	(r4)			; write zero
     628 006076 005100                  	com	r0			; one -> zero
     629 006100 001425                  	beq	142$			; br if OK
     630 006102 005100                  	com	r0			; restore r0
     631 006104 010446                  	mov	r4,-(sp)		; virtual address of error
     632 006106                         	call	adrxlt			; translate to physical
       1 006106 004737  010162          	jsr	pc,adrxlt
     633 006112                         	printf	#77$,testno,#'e,phyadr+0,phyadr+2,#-1,r0 ; format, test, subtest, addrhi/lo, exp, rcv
       1 006112                         	calls	printf #77$ testno #'e phyadr+0 phyadr+2 #-1 r0         
       8                                .list
       9 006112 010046                  	mov	r0,-(sp)
      14                                .list
      15 006114 012746  177777          	mov	#-1,-(sp)
      20                                .list
      21 006120 013746  002046          	mov	phyadr+2,-(sp)
      26                                .list
      27 006124 013746  002044          	mov	phyadr+0,-(sp)
      32                                .list
      33 006130 012746  000145          	mov	#'e,-(sp)
      38                                .list
      39 006134 013746  002042          	mov	testno,-(sp)
      44                                .list
      45 006140 012746  007153          	mov	#77$,-(sp)
       1                                .list
       2 006144                         	call	printf
       1 006144 004737  010766          	jsr	pc,printf
       3 006150 062706  000016          	add	#16,sp
      18                                .list
     634 006154 077332                  142$:	sob	r3,141$			; loop for block size
     635 006156 005305                  149$:	dec	r5			; incr test block
     636 006160 020537  002020          	cmp	r5,blbeg		; at the begin
     637 006164 101331                  	bhi	140$			; br if more to do
     638                                
     639                                	; f: ud(r0) - address descending (or ascending) read zero
     640                                
     641 006166                         	printf	#76$,testno		; subheader
       1 006166                         	calls	printf #76$ testno              
       8                                .list
       9 006166 013746  002042          	mov	testno,-(sp)
      14                                .list
      15 006172 012746  007072          	mov	#76$,-(sp)
       1                                .list
       2 006176                         	call	printf
       1 006176 004737  010766          	jsr	pc,printf
       3 006202 062706  000004          	add	#4,sp
      18                                .list
     642 006206 013705  002022          	mov	blend,r5		; ending block number
     643 006212                         150$:	call	adrtst			; check ok to test this block
       1 006212 004737  010312          	jsr	pc,adrtst
     644 006216 103035                  	bcc	159$			; br if not
     645 006220 010537  172354          	mov	r5,@#tstpar		; point mmu at test block
     646 006224 012704  140100          	mov	#tstmax+1,r4		; end block address
     647 006230 012703  000040          	mov	#tstwc,r3		; this many words
     648 006234 014400                  151$:	mov	-(r4),r0		; read zero
     649 006236 001424                  	beq	152$			; br if OK
     650 006240 010446                  	mov	r4,-(sp)		; virtual address of error
     651 006242                         	call	adrxlt			; translate to physical
       1 006242 004737  010162          	jsr	pc,adrxlt
     652 006246                         	printf	#77$,testno,#'f,phyadr+0,phyadr+2,#0,r0 ; format, test, subtest, addrhi/lo, exp, rcv
       1 006246                         	calls	printf #77$ testno #'f phyadr+0 phyadr+2 #0 r0         
       8                                .list
       9 006246 010046                  	mov	r0,-(sp)
      14                                .list
      15 006250 012746  000000          	mov	#0,-(sp)
      20                                .list
      21 006254 013746  002046          	mov	phyadr+2,-(sp)
      26                                .list
      27 006260 013746  002044          	mov	phyadr+0,-(sp)
      32                                .list
      33 006264 012746  000146          	mov	#'f,-(sp)
      38                                .list
      39 006270 013746  002042          	mov	testno,-(sp)
      44                                .list
      45 006274 012746  007153          	mov	#77$,-(sp)
       1                                .list
       2 006300                         	call	printf
       1 006300 004737  010766          	jsr	pc,printf
       3 006304 062706  000016          	add	#16,sp
      18                                .list
     653 006310 077327                  152$:	sob	r3,151$			; loop for block size
     654 006312 005305                  159$:	dec	r5			; incr test block
     655 006314 020537  002020          	cmp	r5,blbeg		; at the begin
     656 006320 101334                  	bhi	150$			; br if more to do
     657                                
     658                                	; done
     659                                
     660 006322                         	call	enbecc			; check for errors, reenable ecc
       1 006322 004737  010420          	jsr	pc,enbecc
     661                                
     662 006326 000137  007320          	jmp	99$			; next test
     663                                
     664 006332    015     012     124  70$:	.asciz	<cr><lf>"Test%d: extended march c- data test"<cr><lf>
         006335    145     163     164  
         006340    045     144     072  
         006343    040     145     170  
         006346    164     145     156  
         006351    144     145     144  
         006354    040     155     141  
         006357    162     143     150  
         006362    040     143     055  
         006365    040     144     141  
         006370    164     141     040  
         006373    164     145     163  
         006376    164     015     012  
         006401    000                  
     665 006402    124     145     163  71$:	.asciz	"Test%da: u(w0) - address ascending; write zero"<cr><lf>
         006405    164     045     144  
         006410    141     072     040  
         006413    165     050     167  
         006416    060     051     040  
         006421    055     040     141  
         006424    144     144     162  
         006427    145     163     163  
         006432    040     141     163  
         006435    143     145     156  
         006440    144     151     156  
         006443    147     073     040  
         006446    167     162     151  
         006451    164     145     040  
         006454    172     145     162  
         006457    157     015     012  
         006462    000                  
     666 006463    124     145     163  72$:	.asciz	"Test%db: u(r0,w1,r1) - address ascending; read zero, write one, read one"<cr><lf>
         006466    164     045     144  
         006471    142     072     040  
         006474    165     050     162  
         006477    060     054     167  
         006502    061     054     162  
         006505    061     051     040  
         006510    055     040     141  
         006513    144     144     162  
         006516    145     163     163  
         006521    040     141     163  
         006524    143     145     156  
         006527    144     151     156  
         006532    147     073     040  
         006535    162     145     141  
         006540    144     040     172  
         006543    145     162     157  
         006546    054     040     167  
         006551    162     151     164  
         006554    145     040     157  
         006557    156     145     054  
         006562    040     162     145  
         006565    141     144     040  
         006570    157     156     145  
         006573    015     012     000  
     667 006576    124     145     163  73$:	.asciz	"Test%dc: u(r1,w0) - address ascending; read one, write zero"<cr><lf>
         006601    164     045     144  
         006604    143     072     040  
         006607    165     050     162  
         006612    061     054     167  
         006615    060     051     040  
         006620    055     040     141  
         006623    144     144     162  
         006626    145     163     163  
         006631    040     141     163  
         006634    143     145     156  
         006637    144     151     156  
         006642    147     073     040  
         006645    162     145     141  
         006650    144     040     157  
         006653    156     145     054  
         006656    040     167     162  
         006661    151     164     145  
         006664    040     172     145  
         006667    162     157     015  
         006672    012     000          
     668 006674    124     145     163  74$:	.asciz	"Test%dd: d(r0,w1) - address descending; read zero, write one"<cr><lf>
         006677    164     045     144  
         006702    144     072     040  
         006705    144     050     162  
         006710    060     054     167  
         006713    061     051     040  
         006716    055     040     141  
         006721    144     144     162  
         006724    145     163     163  
         006727    040     144     145  
         006732    163     143     145  
         006735    156     144     151  
         006740    156     147     073  
         006743    040     162     145  
         006746    141     144     040  
         006751    172     145     162  
         006754    157     054     040  
         006757    167     162     151  
         006762    164     145     040  
         006765    157     156     145  
         006770    015     012     000  
     669 006773    124     145     163  75$:	.asciz	"Test%de: d(r1,w0) - address descending; read one, write zero"<cr><lf>
         006776    164     045     144  
         007001    145     072     040  
         007004    144     050     162  
         007007    061     054     167  
         007012    060     051     040  
         007015    055     040     141  
         007020    144     144     162  
         007023    145     163     163  
         007026    040     144     145  
         007031    163     143     145  
         007034    156     144     151  
         007037    156     147     073  
         007042    040     162     145  
         007045    141     144     040  
         007050    157     156     145  
         007053    054     040     167  
         007056    162     151     164  
         007061    145     040     172  
         007064    145     162     157  
         007067    015     012     000  
     670 007072    124     145     163  76$:	.asciz	"Test%df: d(r0) - address descending; read zero"<cr><lf>
         007075    164     045     144  
         007100    146     072     040  
         007103    144     050     162  
         007106    060     051     040  
         007111    055     040     141  
         007114    144     144     162  
         007117    145     163     163  
         007122    040     144     145  
         007125    163     143     145  
         007130    156     144     151  
         007133    156     147     073  
         007136    040     162     145  
         007141    141     144     040  
         007144    172     145     162  
         007147    157     015     012  
         007152    000                  
     671 007153    124     145     163  77$:	.ascii	"Test%d%c: extended march c- data compare failure"<cr><lf>
         007156    164     045     144  
         007161    045     143     072  
         007164    040     145     170  
         007167    164     145     156  
         007172    144     145     144  
         007175    040     155     141  
         007200    162     143     150  
         007203    040     143     055  
         007206    040     144     141  
         007211    164     141     040  
         007214    143     157     155  
         007217    160     141     162  
         007222    145     040     146  
         007225    141     151     154  
         007230    165     162     145  
         007233    015     012          
     672 007235    040     040     120  	.ascii	"  PhysAddr  Exp'ed  Rcv'ed"<cr><lf>
         007240    150     171     163  
         007243    101     144     144  
         007246    162     040     040  
         007251    105     170     160  
         007254    047     145     144  
         007257    040     040     122  
         007262    143     166     047  
         007265    145     144     015  
         007270    012                  
     673 007271    040     040     045  	.asciz	"  %.8lp  %.6o  %.6o"<cr><lf>
         007274    056     070     154  
         007277    160     040     040  
         007302    045     056     066  
         007305    157     040     040  
         007310    045     056     066  
         007313    157     015     012  
         007316    000                  
     674 007317    000                  	.even
     675                                
     676 007320 005237  002042          99$:	inc	testno			; count tests
     677                                
     678                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     679                                
     680                                .sbttl	print end of pass message
     681                                
     682 007324 005237  002040          	inc	passes			; count passes
     683 007330                         	printf	#msg3,passes,errors	; format, passcount, errcount
       1 007330                         	calls	printf #msg3 passes errors             
       8                                .list
       9 007330 013746  002036          	mov	errors,-(sp)
      14                                .list
      15 007334 013746  002040          	mov	passes,-(sp)
      20                                .list
      21 007340 012746  007777          	mov	#msg3,-(sp)
       1                                .list
       2 007344                         	call	printf
       1 007344 004737  010766          	jsr	pc,printf
       3 007350 062706  000006          	add	#6,sp
      18                                .list
     684                                
     685                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     686                                
     687                                .sbttl	relocate program for next pass
     688                                
     689 007354 013700  002040          mreloc:	mov	 passes,r0		; get current pass number (0...)
     690 007360 005200                  	inc	 r0			; passcnt+1
     691 007362 042700  177777          	bic	 #^c0,r0		; do modulo 2 remainder (relocate every pass)
     692 007366 001135                  	bne	 99$			; don't do any relocation
     693                                
     694                                	; copy current program image space to relocated space
     695                                
     696 007370 012701  000200          	mov	#pgprgn*pgszbl,r1	; number of blocks to move (power of two)
     697 007374 074137  002026          	xor	r1,protmn		; new dest prot range low
     698 007400 074137  002030          	xor	r1,protmx		; new dest prot range high
     699                                
     700 007404 012701  000200          1$:	mov	#pgprgn*pgszbl,r1	; number of blocks to move (power of two)
     701 007410 013737  002026  172354  	mov	protmn,@#tstpar		; starting dest block address
     702 007416 005002                  	clr	r2			; starting source address
     703 007420 012703  000040          10$:	mov	#blszby/2,r3		; number of words to move
     704 007424 012704  140000          	mov	#tstmin,r4		; dest address
     705 007430 012224                  11$:	mov	(r2)+,(r4)+		; copy a word
     706 007432 077302                  	sob	r3,11$			; loop over a block
     707 007434 005237  172354          	inc	@#tstpar		; bump to next block
     708 007440 077111                  	sob	r1,10$			; loop over all blocks
     709                                
     710                                	; compare current program image space to relocated space
     711                                
     712 007442 012701  000200          	mov	#pgprgn*pgszbl,r1	; number of blocks to move (power of two)
     713 007446 013737  002026  172354  	mov	protmn,@#tstpar		; starting dest block address
     714 007454 005002                  	clr	r2			; starting source address
     715 007456 012703  000040          20$:	mov	#blszby/2,r3		; number of words to move
     716 007462 012704  140000          	mov	#tstmin,r4		; dest address
     717 007466 022224                  21$:	cmp	(r2)+,(r4)+		; copy a word
     718 007470 001345                  	bne	1$			; WHOOPS, error in copy, retry
     719 007472 077303                  	sob	r3,21$			; loop over a block
     720 007474 005237  172354          	inc	@#tstpar		; bump to next block
     721 007500 077112                  	sob	r1,20$			; loop over all blocks
     722                                
     723                                	; now relocate program via swapping KPARx contents
     724                                
     725 007502 012701  000200          	mov	#pgprgn*pgszbl,r1	; number of blocks to move (power of two)
     726 007506 012702  172340          	mov	#kpar+<2*pgprg>,r2	; ptr to first base register
     727 007512 012703  000001          	mov	#pgprgn,r3		; number of program pages
     728 007516 074122                  30$:	xor	r1,(r2)+		; swap address in KPAR[n]
     729 007520 077302                  	sob	r3,30$			; loop over all pages
     730                                
     731                                	; if we got here, it worked ok ... print a message
     732                                
     733 007522 013701  002026          	mov	protmn,r1		; address min low
     734 007526 005000                  	clr	r0			; zap high
     735 007530 073027  000006          	ashc	#6,r0			; shift left 6
     736                                
     737 007534 013703  002030          	mov	protmx,r3		; address max low
     738 007540 005002                  	clr	r2			; zap high
     739 007542 073227  000006          	ashc	#6,r2			; shift left 6
     740 007546 052703  000077          	bis	#blszby-1,r3		; up thru last block number
     741                                
     742 007552                         	printf	#70$,r0,r1,r2,r3	; format, min hi, min lo, max hi, max lo
       1 007552                         	calls	printf #70$ r0 r1 r2 r3           
       8                                .list
       9 007552 010346                  	mov	r3,-(sp)
      14                                .list
      15 007554 010246                  	mov	r2,-(sp)
      20                                .list
      21 007556 010146                  	mov	r1,-(sp)
      26                                .list
      27 007560 010046                  	mov	r0,-(sp)
      32                                .list
      33 007562 012746  007600          	mov	#70$,-(sp)
       1                                .list
       2 007566                         	call	printf
       1 007566 004737  010766          	jsr	pc,printf
       3 007572 062706  000012          	add	#12,sp
      18                                .list
     743                                
     744 007576 000431                  	br	99$			; next
     745                                
     746 007600    015     012     120  70$:	.asciz	<cr><lf>"Program relocated to %lp(8) - %lp(8) physical"<cr><lf>
         007603    162     157     147  
         007606    162     141     155  
         007611    040     162     145  
         007614    154     157     143  
         007617    141     164     145  
         007622    144     040     164  
         007625    157     040     045  
         007630    154     160     050  
         007633    070     051     040  
         007636    055     040     045  
         007641    154     160     050  
         007644    070     051     040  
         007647    160     150     171  
         007652    163     151     143  
         007655    141     154     015  
         007660    012     000          
     747                                	.even
     748                                
     749 007662 000240                  99$:	nop
     750                                
     751                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     752                                
     753                                .sbttl	all done - end of pass cleanup
     754                                
     755 007664 023737  002004  002040  done:	cmp	numpas,passes		; done
     756 007672 001402                  	beq	exit			; yes
     757 007674 000137  003126          	jmp	loop			; not yet
     758                                
     759 007700                         exit:	printf	#msg2			; say goodbye
       1 007700                         	calls	printf #msg2               
       8                                .list
       9 007700 012746  007763          	mov	#msg2,-(sp)
       1                                .list
       2 007704                         	call	printf
       1 007704 004737  010766          	jsr	pc,printf
       3 007710 062706  000002          	add	#2,sp
      18                                .list
     760 007714 005000                  	clr	r0			;
     761 007716 077001                  10$:	sob	r0,10$			; some delay
     762 007720 000005                  	reset				; zap the world
     763 007722 000137  165144          	jmp	@#console		; exit to console
     764                                
     765                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     766                                ; 
     767                                ; random status messages
     768                                ; 
     769 007726    015     012     015  msg1:	.asciz	<cr><lf><cr><lf>"Memory Exerciser v1.41"<cr><lf>
         007731    012     115     145  
         007734    155     157     162  
         007737    171     040     105  
         007742    170     145     162  
         007745    143     151     163  
         007750    145     162     040  
         007753    166     061     056  
         007756    064     061     015  
         007761    012     000          
     770 007763    015     012     107  msg2:	.asciz	<cr><lf>"Goodbye"<cr><lf>
         007766    157     157     144  
         007771    142     171     145  
         007774    015     012     000  
     771 007777    015     012     105  msg3:	.asciz	<cr><lf>"End pass %u. errors %u."<cr><lf>
         010002    156     144     040  
         010005    160     141     163  
         010010    163     040     045  
         010013    165     056     040  
         010016    145     162     162  
         010021    157     162     163  
         010024    040     045     165  
         010027    056     015     012  
         010032    000                  
     772 010033    015     012     104  msg4:	.asciz	<cr><lf>"Detected memory size is %dKB (%.6lp)"<cr><lf>
         010036    145     164     145  
         010041    143     164     145  
         010044    144     040     155  
         010047    145     155     157  
         010052    162     171     040  
         010055    163     151     172  
         010060    145     040     151  
         010063    163     040     045  
         010066    144     113     102  
         010071    040     050     045  
         010074    056     066     154  
         010077    160     051     015  
         010102    012     000          
     773 010104    015     012     115  msg5a:	.asciz	<cr><lf>"Memory Control registers: "
         010107    145     155     157  
         010112    162     171     040  
         010115    103     157     156  
         010120    164     162     157  
         010123    154     040     162  
         010126    145     147     151  
         010131    163     164     145  
         010134    162     163     072  
         010137    040     000          
     774 010141    040     045     056  msg5b:	.asciz	" %.6o"
         010144    066     157     000  
     775 010147    040     074     156  msg5c:	.asciz	" <none>"
         010152    157     156     145  
         010155    076     000          
     776 010157    015     012     000  crlf:	.asciz	<cr><lf>
     777                                	.even
     778                                
     779                                ; --------------------------------------------------------------------------------
     780                                ;
     781                                ; translate virtual address to physical in phyadr+0/+2
     782                                ;
     783                                ;	call:	mov	#addr,-(sp)	; virtual address, popped on return
     784                                ;		call	adrxlt
     785                                ;
     786 010162 010146                  adrxlt:	mov	r1,-(sp)		; save
     787 010164 010046                  	mov	r0,-(sp)		;
     788                                
     789 010166 016601  000006          	mov	6.(sp),r1		; default lsb
     790 010172 005000                  	clr	r0			; default msb
     791 010174 032737  000001  177572  	bit	#bit0,@#mmr0		; check if mmgt enabled
     792 010202 001420                  	beq	20$			; br if OFF
     793                                
     794 010204 073027  000003          	ashc	#3.,r0			; page number to R0<2:0>
     795 010210 006300                  	asl	r0			; R0*2, 0->C
     796 010212 016000  172340          	mov	kpar(r0),r0		; get base address of page
     797 010216 072127  177767          	ash	#-9.,r1			; block to R1<6:0>
     798 010222 060001                  	add	r0,r1			; add block to base
     799 010224 073027  000006          	ashc	#6.,r0			; base to R0/R1<21:06>
     800 010230 016646  000006          	mov	6.(sp),-(sp)		; duplicate VA<15:0>
     801 010234 042716  177700          	bic	#^c77,(sp)		; mask to DIB<5:0>
     802 010240 052601                  	bis	(sp)+,r1		; merge into PA<21:00>
     803 010242 000404                  	br	30$			; continue
     804                                
     805 010244 020127  160000          20$:	cmp	r1,#160000		; check for I/O page
     806 010250 103401                  	blo	30$			; br if not	
     807 010252 005100                  	com	r0			; yes, set bits
     808                                
     809 010254 042700  177700          30$:	bic	#^c77,r0		; mask to 22b physical
     810 010260 005737  002034          	tst	flg22b			; 22b mode ?
     811 010264 001002                  	bne	40$			; br if 22b
     812 010266 042700  177774          	bic	#^c3,r0			; mask to 18b physical
     813                                
     814 010272 010037  002044          40$:	mov	r0,phyadr+0		; store msb
     815 010276 010137  002046          	mov	r1,phyadr+2		; and lsb
     816                                
     817 010302 012600                  	mov	(sp)+,r0		; restore
     818 010304 012601                  	mov	(sp)+,r1		;
     819 010306 012616                  	mov	(sp)+,(sp)		; flush argument
     820 010310                         	return				; return
       1 010310 000207                  	rts	pc
     821                                
     822                                ; --------------------------------------------------------------------------------
     823                                ;
     824                                ; check block address valid for test
     825                                ;
     826                                ;	call:	mov	#addr,r5
     827                                ;		call	adrtst
     828                                ;		bcc	not_valid
     829                                ;		bcs	valid
     830                                ;
     831 010312 020537  002026          adrtst:	cmp	r5,protmn		; addr vs lowest
     832 010316 103405                  	blo	20$			; br if lower
     833 010320 020537  002030          	cmp	r5,protmx		; addr vs highest
     834 010324 101002                  	bhi	20$			; br if higher
     835 010326 000241                  	clc				; indicate not valid
     836 010330                         	return				; return
       1 010330 000207                  	rts	pc
     837 010332 000261                  20$:	sec				; indicate valid
     838 010334                         	return				; return
       1 010334 000207                  	rts	pc
     839                                
     840                                ; --------------------------------------------------------------------------------
     841                                ;
     842                                ; disable ecc routine
     843                                ;
     844                                ;	call:	call	disecc
     845                                ;
     846 010336 010446                  disecc:	mov	r4,-(sp)		; save registers
     847 010340 010346                  	mov	r3,-(sp)		;
     848                                
     849 010342 013704  002032          	mov	mcrmsk,r4		; bitmask of existing memory csr
     850 010346 012703  172100          	mov	#mcr0,r3		; addr of first csr
     851                                
     852 010352 005704                  10$:	tst	r4			; check any csrs left, zero to C
     853 010354 001416                  	beq	30$			; br if done
     854 010356 006004                  	ror	r4			; next csr exist?
     855 010360 103011                  	bcc	20$			; br if none
     856 010362 005013                  	clr	(r3)			; clear errors
     857 010364 032737  000001  002002  	bit	#bit0,optswi		; check if run with ecc enabled
     858 010372 001004                  	bne	20$			; br if yes
     859 010374 042713  140024          	bic	#bit15+bit14+bit4+bit2,(r3) ; clear error bit and ecc read mode
     860 010400 052713  000003          	bis	#bit1+bit0,(r3)		; disable correction, trap on error, clear flags
     861 010404 062703  000002          20$:	add	#2,r3			; bump addr
     862 010410 000760                  	br	10$			; loop
     863                                
     864 010412 012603                  30$:	mov	(sp)+,r3		; restore registers
     865 010414 012604                  	mov	(sp)+,r4		;
     866 010416                         	return				; return
       1 010416 000207                  	rts	pc
     867                                
     868                                ; --------------------------------------------------------------------------------
     869                                ;
     870                                ; check errors / enable ecc routine
     871                                ;
     872                                ;	call:	call	enbecc
     873                                ;
     874 010420 010446                  enbecc:	mov	r4,-(sp)		; save registers
     875 010422 010346                  	mov	r3,-(sp)		;
     876 010424 010246                  	mov	r2,-(sp)		;
     877 010426 010146                  	mov	r1,-(sp)		;
     878 010430 010046                  	mov	r0,-(sp)		;
     879                                
     880 010432 013704  002032          	mov	mcrmsk,r4		; bitmask of existing memory csr
     881 010436 012703  172100          	mov	#mcr0,r3		; addr of first csr
     882                                
     883 010442 005704                  10$:	tst	r4			; check any csrs left, zero to C
     884 010444 001444                  	beq	30$			; br if done
     885 010446 006004                  	ror	r4			; next csr exist?
     886 010450 103037                  	bcc	20$			; br if none
     887 010452 011302                  	mov	(r3),r2			; get current csr
     888 010454 032702  100020          	bit	#bit15+bit4,r2		; check for any errors
     889 010460 001431                  	beq	19$			; br if no errors
     890                                
     891 010462 010200                  	mov	r2,r0			; memory block
     892 010464 042700  170037          	bic	#170037,r0		; isolate A<17:11>
     893 010470 052713  040000          	bis	#bit14,(r3)		; select upper EUB
     894 010474 011301                  	mov	(r3),r1			;
     895 010476 042701  170037          	bic	#170037,r1		;
     896 010502 072127  000007          	ash	#7,r1			; isolate A<21:18>
     897 010506 050100                  	bis	r1,r0			; merge
     898 010510                         	printf	#71$,r3,r0,#0,r2	; format, csr addr, memory block, expected, received
       1 010510                         	calls	printf #71$ r3 r0 #0 r2           
       8                                .list
       9 010510 010246                  	mov	r2,-(sp)
      14                                .list
      15 010512 012746  000000          	mov	#0,-(sp)
      20                                .list
      21 010516 010046                  	mov	r0,-(sp)
      26                                .list
      27 010520 010346                  	mov	r3,-(sp)
      32                                .list
      33 010522 012746  010572          	mov	#71$,-(sp)
       1                                .list
       2 010526                         	call	printf
       1 010526 004737  010766          	jsr	pc,printf
       3 010532 062706  000012          	add	#12,sp
      18                                .list
     899                                
     900 010536 005237  002036          18$:	inc	errors			; count errors
     901 010542 001775                  	beq	18$			; not zero
     902                                
     903 010544 042713  157767          19$:	bic	#^c<bit13+bit3>,(r3)	; enable error correction, clear errors
     904 010550 062703  000002          20$:	add	#2,r3			; bump addr
     905 010554 000732                  	br	10$			; loop
     906                                
     907 010556 012600                  30$:	mov	(sp)+,r0		; restore registers
     908 010560 012601                  	mov	(sp)+,r1		;
     909 010562 012602                  	mov	(sp)+,r2		;
     910 010564 012603                  	mov	(sp)+,r3		;
     911 010566 012604                  	mov	(sp)+,r4		;
     912 010570                         	return				; return
       1 010570 000207                  	rts	pc
     913                                
     914 010572    115     145     155  71$:	.ascii	"Memory CSR Contents"<cr><lf>
         010575    157     162     171  
         010600    040     103     123  
         010603    122     040     103  
         010606    157     156     164  
         010611    145     156     164  
         010614    163     015     012  
     915 010617    040     040     103  	.ascii	"  CSRadr  MemBlk  Exp'ed  Rcv'ed"<cr><lf>
         010622    123     122     141  
         010625    144     162     040  
         010630    040     115     145  
         010633    155     102     154  
         010636    153     040     040  
         010641    105     170     160  
         010644    047     145     144  
         010647    040     040     122  
         010652    143     166     047  
         010655    145     144     015  
         010660    012                  
     916 010661    040     040     045  	.asciz	"  %.6o  %.6o  %.6o  %.6o"<cr><lf>
         010664    056     066     157  
         010667    040     040     045  
         010672    056     066     157  
         010675    040     040     045  
         010700    056     066     157  
         010703    040     040     045  
         010706    056     066     157  
         010711    015     012     000  
     917                                	.even
     918                                
     919                                .include "mac/adrchk.mac"
       1                                ;================================================================================
       2                                ; adrchk.mac - routine to check if a physical address exists
       3                                ; (C) 2009 Donald North. All rights reserved.
       4                                ;================================================================================
       5                                ;
       6                                ; address check routine
       7                                ;
       8                                ;	call:	mov	#addr,r0
       9                                ;		call	adrchk
      10                                ;		bcc	we_trapped
      11                                ;		bcs	no_trap
      12                                ;
      13 010714 010546                  adrchk::mov	r5,-(sp)		; save registers
      14                                
      15 010716 013746  000004          	mov	@#4,-(sp)		; save old vector
      16 010722 013746  000006          	mov	@#6,-(sp)		;
      17 010726 010605                  	mov	sp,r5			; save sp here
      18                                
      19 010730 012737  010750  000004  	mov	#1$,@#4  		; if we timeout go here
      20 010736 005037  000006          	clr	@#6			; next psw if we trap
      21                                
      22 010742 000241                  	clc				; C=0 means we trapped
      23 010744 005710                  	tst	(r0)			; test the address, may trap
      24 010746 000261                  	sec				; C=1 means no trap
      25                                
      26 010750 010506                  1$:	mov	r5,sp			; restore stack
      27 010752 012637  000006          	mov	(sp)+,@#6		; restore old vector
      28 010756 012637  000004          	mov	(sp)+,@#4		;
      29                                
      30 010762 012605                  	mov	(sp)+,r5		; restore registers
      31 010764                         	return				; done
       1 010764 000207                  	rts	pc
      32                                
      33                                ;================================================================================
      34                                ; end of adrchk.mac
      35                                ;================================================================================
      35                                
     920                                .include "mac/printf.mac"
       1                                ;================================================================================
       2                                ; printf.mac - printf routines for macro11 diagnostics
       3                                ; (C) 2009-2016 Donald North. All rights reserved.
       4                                ;================================================================================
       5                                
       6                                .if ndf ttxcsr
       7                                	
       8                                	; separate psect (if console registers not defined)
       9                                	.psect	printf
      10                                
      11                                	; external tty references
      12                                	.globl	ttxcsr, ttxbuf
      13                                
      14                                	; standard macro definitions
      15                                 	.include "mac/stddef.mac"
      16                                
      17                                pf.sep	=1 ; flag separate compilation
      18                                
      19                                .iff
      20                                
      21        000000                  pf.sep	=0 ; flag unified compilation (via include)
      22                                	
      23                                .endc
      24                                ; 
      25                                ; global registers:
      26                                ;
      27                                ;  R5 - frame pointer
      28                                ;  R4 - argument pointer
      29                                ;  R3 - format string pointer
      30                                ;  R2 - current format character
      31                                ;  R1 - temp
      32                                ;  R0 - temp
      33                                ;
      34                                ; note:	for 11/04-05-10 compatibility, do NOT use SXT/XOR/SOB and MUL/DIV/ASH/ASHC
      35                                ; 
      36                                ; offsets from frame pointer (r5):
      37                                ; 
      38        000012                  p.sr0	=+10.	; saved r0
      39        000010                  p.sr1	=+8.	; saved r1
      40        000006                  p.sr2	=+6.	; saved r2
      41        000004                  p.sr3	=+4.	; saved r3
      42        000002                  p.sr4	=+2.	; saved r4
      43        000000                  p.sr5	=+0.	; saved r5
      44        177777                  p.flg	=-1.	; format flags (byte)
      45        177776                  p.fil	=-2.	; fill character (byte)
      46        177774                  p.wid	=-4.	; format numeric width (word)
      47        177772                  p.pre	=-6.	; format numeric precision (word)
      48        177770                  p.len	=-8.	; number of digits generated (word)
      49        177766                  p.out	=-10.	; addr(char print routine)
      50        177764                  p.ptr	=-12.	; sprintf output buffer pointer
      51                                ; 
      52        000014                  n.last	=+12.	; number of bytes allocated on stack
      53        000016                  n.args	=+14.	; offset to first argument on stack
      54                                ; 
      55                                ; bits in p.flg byte:
      56                                ; 
      57        000001                  pf.ljus	=1	; set for left justified ('-' seen)
      58        000002                  pf.sign	=2	; set for sign requested ('+' seen)
      59        000004                  pf.altf	=4	; set for alt flag ('#' seen)
      60        000010                  pf.long	=10	; set for long value (%...l. seen)
      61        000020                  pf.nega	=20	; set for negative value (msb set)
      62                                
      63                                ; --------------------------------------------------------------------------------
      64                                ;
      65                                ; printf routine .. 'C' printf(format,arg1,arg2,..,argn) ..  called in 'C' style
      66                                ;
      67                                ;	call:	mov	argN,-(sp)
      68                                ;		...
      69                                ;		mov	arg2,-(sp)
      70                                ;		mov	arg1,-(sp)
      71                                ;		mov	format,-(sp)
      72                                ;		call	printf
      73                                ;		add	#2*N,sp
      74                                ;
      75 010766 010046                  printf::mov	r0,-(sp)		; save reg
      76 010770 010146                  	mov	r1,-(sp)		;
      77 010772 010246                  	mov	r2,-(sp)		;
      78 010774 010346                  	mov	r3,-(sp)		;
      79 010776 010446                  	mov	r4,-(sp)		;
      80 011000 010546                  	mov	r5,-(sp)		;
      81                                	
      82 011002 010605                  	mov	sp,r5			; frame pointer
      83 011004 162706  000014          	sub	#n.last,sp		; reserve space on stack
      84                                	
      85 011010 010504                  	mov	r5,r4			; get frame ptr
      86 011012 062704  000016          	add	#n.args,r4		; offset to first argument
      87                                	
      88 011016 012765  011032  177766  	mov	#1$,p.out(r5)		; character output routine
      89 011024 005065  177764          	clr	p.ptr(r5)		; bufptr not used here
      90                                	
      91 011030 000442                  	br	xprintf			; continue
      92                                
      93                                	; ---------------------------------------------------------
      94                                	
      95                                	; character output to console
      96                                	
      97 011032 105737  177564          1$:	tstb	@#ttxcsr		; check if ready
      98 011036 100375                  	bpl	1$			; not yet
      99 011040 110037  177566          	movb	r0,@#ttxbuf		; send character
     100 011044                         	return				; return
       1 011044 000207                  	rts	pc
     101                                	
     102                                ; --------------------------------------------------------------------------------
     103                                ;
     104                                ; sprintf routine .. 'C' sprintf(buffer,format,arg1,arg2,..,argn) ..  called in 'C' style
     105                                ;
     106                                ;	call:	mov	argN,-(sp)
     107                                ;		...
     108                                ;		mov	arg2,-(sp)
     109                                ;		mov	arg1,-(sp)
     110                                ;		mov	format,-(sp)
     111                                ;		mov	buffer,-(sp)
     112                                ;		call	sprintf
     113                                ;		add	#2*N,sp
     114                                ;
     115 011046 010046                  sprintf::mov	r0,-(sp)		; save reg
     116 011050 010146                  	mov	r1,-(sp)		;
     117 011052 010246                  	mov	r2,-(sp)		;
     118 011054 010346                  	mov	r3,-(sp)		;
     119 011056 010446                  	mov	r4,-(sp)		;
     120 011060 010546                  	mov	r5,-(sp)		;
     121                                	
     122 011062 010605                  	mov	sp,r5			; frame pointer
     123 011064 162706  000014          	sub	#n.last,sp		; reserve space on stack
     124                                	
     125 011070 010504                  	mov	r5,r4			; get frame ptr
     126 011072 062704  000016          	add	#n.args,r4		; offset to first argument
     127                                	
     128 011076 012765  011112  177766  	mov	#1$,p.out(r5)		; character output routine
     129 011104 012465  177764          	mov	(r4)+,p.ptr(r5)		; init bufptr from argument
     130                                	
     131 011110 000412                  	br	xprintf			; continue
     132                                
     133                                	; ---------------------------------------------------------
     134                                	
     135                                	; character output to buffer
     136                                	
     137 011112 110075  177764          1$:	movb	r0,@p.ptr(r5)		; store character
     138 011116 005265  177764          	inc	p.ptr(r5)		; bump pointer
     139 011122 105075  177764          	clrb	@p.ptr(r5)		; null terminate
     140 011126 016565  177764  000012  	mov	p.ptr(r5),p.sr0(r5)	; return updated ptr in saved r0
     141 011134                         	return				; return
       1 011134 000207                  	rts	pc
     142                                	
     143                                ; --------------------------------------------------------------------------------
     144                                
     145                                	; process main format
     146                                
     147 011136 012403                  xprintf:mov	(r4)+,r3		; prime format string pointer
     148                                
     149 011140                         1$:	call	900$			; get next format character
       1 011140 004737  012050          	jsr	pc,900$
     150 011144 120227  000045          	cmpb	r2,#<'%>		; hit a format flag?
     151 011150 001430                  	beq	10$			; yes, go process
     152 011152 120227  000134          	cmpb	r2,#<'\>		; hit an escape flag?
     153 011156 001404                  	beq	3$			; yes, go process
     154 011160 010200                  2$:	mov	r2,r0			; char to print
     155 011162                         	call	@p.out(r5)		; no, just print it
       1 011162 004775  177766          	jsr	pc,@p.out(r5)
     156 011166 000764                  	br	1$			; loop
     157                                
     158                                	; process escaped character \a .. \z
     159                                
     160 011170                         3$:	call	900$			; get the escaped character
       1 011170 004737  012050          	jsr	pc,900$
     161 011174 002771                  	blt	2$			; quick exit for [NUL-@] range
     162 011176 120227  000172          	cmpb	r2,#<'z>		;
     163 011202 003366                  	bgt	2$			; exit if [{-DEL]
     164 011204 120227  000141          	cmpb	r2,#<'a>		;
     165 011210 002005                  	bge	4$			; br if [a-z]	
     166 011212 120227  000132          	cmpb	r2,#<'Z>		;
     167 011216 003360                  	bgt	2$			; br if [[-`]
     168 011220 152702  000040          	bisb	#40,r2			; force to [a-z] range
     169 011224 116202  011745          4$:	movb	1000$-<'a>(r2),r2	; translate a..z to escaped
     170 011230 000753                  	br	2$			; go print
     171                                
     172                                	; process format flag %[-+]?(0?\d+([.]\d+)?)?[lh]?[iduscpxo]
     173                                
     174 011232 112765  000040  177776  10$:	movb	#<' >,p.fil(r5)		; blank fill
     175 011240 105065  177777          	clrb	p.flg(r5)		; clear flags
     176 011244 005065  177774          	clr	p.wid(r5)		; init width spec
     177 011250 005065  177772          	clr	p.pre(r5)		; init precision spec
     178 011254 005065  177770          	clr	p.len(r5)		; no digits yet
     179                                
     180 011260                         11$:	call	900$			; get next format character
       1 011260 004737  012050          	jsr	pc,900$
     181 011264 002045                  	bge	40$			; br if [A-DEL]
     182 011266 120227  000045          	cmpb	r2,#<'%>		; check for '%'
     183 011272 001732                  	beq	2$			; br if yes
     184                                
     185                                	; some character in range [NUL-@]
     186                                
     187 011274 120227  000055          	cmpb	r2,#<'->		; check for '-'
     188 011300 001004                  	bne	12$			; br if not
     189 011302 152765  000001  177777  	bisb	#pf.ljus,p.flg(r5)	; yes, set a flag
     190 011310 000763                  	br	11$			; loop
     191 011312 120227  000053          12$:	cmpb	r2,#<'+>		; check for '+'
     192 011316 001004                  	bne	13$			; br if not
     193 011320 152765  000002  177777  	bisb	#pf.sign,p.flg(r5)	; yes, set a flag
     194 011326 000754                  	br	11$			; loop
     195 011330 120227  000043          13$:	cmpb	r2,#<'#>		; check for '#'
     196 011334 001004                  	bne	20$			; br if not
     197 011336 152765  000004  177777  	bisb	#pf.altr,p.flg(r5)	; yes, set a flag
     198 011344 000745                  	br	11$			; loop
     199                                
     200 011346                         20$:	call	800$			; get a number if present
       1 011346 004737  011754          	jsr	pc,800$
     201 011352 010165  177774          	mov	r1,p.wid(r5)		; save number as width
     202                                
     203 011356 120227  000056          	cmpb	r2,#<'.>		; check for .
     204 011362 001006                  	bne	40$			; br if not, should be alpha
     205 011364                         	call	900$			; get next character
       1 011364 004737  012050          	jsr	pc,900$
     206                                
     207 011370                         	call	800$			; get a number if present
       1 011370 004737  011754          	jsr	pc,800$
     208 011374 010165  177772          	mov	r1,p.pre(r5)		; save number as precision
     209                                
     210                                	; flag is in range [A-Za-z]
     211                                
     212 011400 005000                  40$:	clr	r0			; zap numerics
     213 011402 005001                  	clr	r1			;
     214 011404 120227  000101          41$:	cmpb	r2,#<'A>		; check for [:-@]
     215 011410 002663                  	blt	2$			; br if yes
     216 011412 120227  000172          	cmpb	r2,#<'z>		; check for [{-DEL]
     217 011416 003260                  	bgt	2$			; br if yes
     218 011420 120227  000141          	cmpb	r2,#<'a>		; check for [a-z]
     219 011424 002003                  	bge	42$			; br if yes
     220 011426 120227  000132          	cmpb	r2,#<'Z>		; check for [A-Z]
     221 011432 003252                  	bgt	2$			; br if no
     222 011434 042702  000040          42$:	bic	#40,r2			; force to [a-z] to [A-Z] range
     223 011440 012401                  	mov	(r4)+,r1		; get the next value as lsb
     224 011442 006302                  	asl	r2			; char*2 for word offset
     225 011444 000172  011246          	jmp	@400$-<2*'A>(r2)	; dispatch
     226                                
     227                                400$:	;----	aaaa,bbbb,cccc,dddd,eeee,ffff,gggg,hhhh,iiii,jjjj,kkkk,llll,mmmm
     228 011450 011534  011740  011600  	.word	401$,470$,420$,430$,401$,401$,401$,401$,430$,401$,401$,405$,401$
         011456 011620  011534  011534  
         011464 011534  011534  011620  
         011472 011534  011534  011550  
         011500 011534                  
     229                                	;----	nnnn,oooo,pppp,qqqq,rrrr,ssss,tttt,uuuu,vvvv,wwww,xxxx,yyyy,zzzz
     230 011502 011534  011710  011710  	.word	401$,450$,450$,401$,401$,410$,401$,440$,401$,401$,460$,401$,401$
         011510 011534  011534  011566  
         011516 011534  011674  011534  
         011524 011534  011724  011534  
         011532 011534                  
     231                                
     232 011534 005744                  401$:	tst	-(r4)			; %<illegal>: backup argument pointer
     233 011536 005002                  	clr	r2			; zap
     234 011540 156302  177777          	bisb	-1(r3),r2		; retrieve last character
     235 011544 000137  011160          	jmp	2$			; just go print
     236                                
     237 011550                         405$:	call	900$			; %l: get next character
       1 011550 004737  012050          	jsr	pc,900$
     238 011554 152765  000010  177777  	bisb	#pf.long,p.flg(r5)	; indicate longword value
     239 011562 010100                  	mov	r1,r0			; copy 1st arg to msb
     240 011564 000707                  	br	41$			; and go parse next flag
     241                                
     242 011566 010102                  410$:	mov	r1,r2			; %s: get next arg as string address
     243 011570                         	call	prtstr			; print as a string
       1 011570 004737  012510          	jsr	pc,prtstr
     244 011574 000137  011140          	jmp	1$			; continue at the top
     245                                
     246 011600 005046                  420$:	clr	-(sp)			; %c: zap upper byte
     247 011602 110116                  	movb	r1,(sp)			; insert the character
     248 011604 010602                  	mov	sp,r2			; point at string
     249 011606                         	call	prtstr			; print as a string
       1 011606 004737  012510          	jsr	pc,prtstr
     250 011612 005726                  	tst	(sp)+			; flush temp string
     251 011614 000137  011140          	jmp	1$			; continue at the top
     252                                
     253 011620 012702  000012          430$:	mov	#10.,r2			; %d,%i: decimal radix
     254 011624 132765  000010  177777  	bitb	#pf.long,p.flg(r5)	; longword value?
     255 011632 001004                  	bne	431$			; br if yes
     256 011634 005000                  	clr	r0			; zap
     257 011636 005701                  	tst	r1			; no; test lsb sign
     258 011640 100001                  	bpl	431$			; br if plus/zero
     259 011642 005100                  	com	r0			; extend -1 to msb
     260 011644 005700                  431$:	tst	r0			; test msb sign
     261 011646 002006                  	bge	439$			; br if zero or positive
     262 011650 005400                  	neg	r0			; negative; make positive
     263 011652 005401                  	neg	r1			;
     264 011654 005600                  	sbc	r0			;
     265 011656 152765  000020  177777  	bisb	#pf.nega,p.flg(r5)	; set flag indicating negative
     266 011664                         439$:	call	prt32u			; print as unsigned decimal w/sign
       1 011664 004737  012140          	jsr	pc,prt32u
     267 011670 000137  011140          	jmp	1$			; continue at the top
     268                                
     269 011674 012702  000012          440$:	mov	#10.,r2			; %u: decimal radix
     270 011700                         	call	prt32u			; print as an unsigned decimal
       1 011700 004737  012140          	jsr	pc,prt32u
     271 011704 000137  011140          	jmp	1$			; continue at the top
     272                                
     273 011710 012702  000010          450$:	mov	#8.,r2			; %o,%p: octal radix
     274 011714                         	call	prt32u			; print as an unsigned hex
       1 011714 004737  012140          	jsr	pc,prt32u
     275 011720 000137  011140          	jmp	1$			; continue at the top
     276                                
     277 011724 012702  000020          460$:	mov	#16.,r2			; %x: hexadecimal radix
     278 011730                         	call	prt32u			; print as an unsigned hex
       1 011730 004737  012140          	jsr	pc,prt32u
     279 011734 000137  011140          	jmp	1$			; continue at the top
     280                                
     281 011740 012702  000002          470$:	mov	#2.,r2			; %b: binary radix
     282 011744                         	call	prt32u			; print as an unsigned binary
       1 011744 004737  012140          	jsr	pc,prt32u
     283 011750 000137  011140          	jmp	1$			; continue at the top
     284                                
     285                                	; ---------------------------------------------------------
     286                                	; get a number as '[0-9]+' or '*'
     287                                
     288 011754 120227  000052          800$:	cmpb	r2,#<'*>		; check for '*' indirection
     289 011760 001427                  	beq	880$			; br if yes
     290 011762 120227  000060          	cmpb	r2,#<'0>		; check for leading '0' character
     291 011766 001002                  	bne	810$			; br if not
     292 011770 110265  177776          	movb	r2,p.fil(r5)		; yes, set a flag
     293 011774 005001                  810$:	clr	r1			; number accumulated here
     294 011776 120227  000060          820$:	cmpb	r2,#<'0>		; check for '0'
     295 012002 002421                  	blt	890$			; br if less that a '0'
     296 012004 120227  000071          	cmpb	r2,#<'9>		; check for '9'
     297 012010 003016                  	bgt	890$			; br if greater than '9'
     298 012012 162702  000060          	sub	#<'0>,r2		; offset to range 0..9
     299 012016 006301                  	asl	r1			; number *= 2.
     300 012020 010100                  	mov	r1,r0			; (number*2.)
     301 012022 006300                  	asl	r0			; (number*4.)
     302 012024 006300                  	asl	r0			; (number*8.)
     303 012026 060001                  	add	r0,r1			; number = number*8. + number*2.
     304 012030 060201                  	add	r2,r1			; add in this digit
     305 012032                         	call	900$			; get next format character
       1 012032 004737  012050          	jsr	pc,900$
     306 012036 000757                  	br	820$			; and loop
     307 012040 012401                  880$:	mov	(r4)+,r1		; get next arg as number
     308 012042                         	call	900$			; get next character
       1 012042 004737  012050          	jsr	pc,900$
     309 012046                         890$:	return				; return
       1 012046 000207                  	rts	pc
     310                                
     311                                	; ---------------------------------------------------------
     312                                	; get next character (or exit) routine; result in r2
     313                                
     314 012050 112302                  900$:	movb	(r3)+,r2		; get next format character
     315 012052 042702  177600          	bic	#^c177,r2		; 7bit ascii only
     316 012056 001403                  	beq	990$			; end of string seen
     317 012060 120227  000101          	cmpb	r2,#<'A>		; check for [A-DEL]
     318 012064                         	return				; leave CC set with result
       1 012064 000207                  	rts	pc
     319                                
     320 012066 010506                  990$:	mov	r5,sp			; flush frame
     321 012070 012605                  	mov	(sp)+,r5		; restore reg
     322 012072 012604                  	mov	(sp)+,r4		;
     323 012074 012603                  	mov	(sp)+,r3		;
     324 012076 012602                  	mov	(sp)+,r2		;
     325 012100 012601                  	mov	(sp)+,r1		;
     326 012102 012600                  	mov	(sp)+,r0		;
     327 012104                         	return				; return
       1 012104 000207                  	rts	pc
     328                                
     329                                	; ---------------------------------------------------------
     330                                	; escaped character table
     331                                1000$:	;	aaa bbb ccc ddd eee fff ggg hhh iii jjj kkk lll mmm
     332                                	;	BEL  BS         ESC  FF
     333 012106    007     010     143  	.byte	007,010,143,144,033,014,147,150,151,152,153,154,155
         012111    144     033     014  
         012114    147     150     151  
         012117    152     153     154  
         012122    155                  
     334                                	;	nnn ooo ppp qqq rrr sss ttt uuu vvv www xxx yyy zzz
     335                                	;	 LF              CR      HT      VT
     336 012123    012     157     160  	.byte	012,157,160,161,015,163,011,165,013,167,170,172,172
         012126    161     015     163  
         012131    011     165     013  
         012134    167     170     172  
         012137    172                  
     337                                	; ---------------------------------------------------------
     338                                
     339                                ; --------------------------------------------------------------------------------
     340                                ;
     341                                ; digit print routine .. print a 32b value as unsigned digits
     342                                ;
     343                                ;	call:	mov	datahi,r0
     344                                ;		mov	datalo,r1
     345                                ;		mov	#radix,r2 ; 2. or 8. or 10. or 16.
     346                                ;		call	prt32u
     347                                ;
     348                                ;		r0 - data msb      (not saved)
     349                                ;		r1 - data lsb      (not saved)
     350                                ;		r2 - radix         (not saved)
     351                                ;		r3 - ptr to format     (saved)
     352                                ;		r4 - ptr to arglist    (saved) [input not used]
     353                                ;		r5 - ptr to flags      (saved)
     354                                ;
     355 012140 010346                  prt32u:	mov	r3,-(sp)		; save regs we use
     356 012142 010446                  	mov	r4,-(sp)		;
     357                                
     358                                	; render all the digits onto the stack (lsd first, msd last)
     359                                
     360 012144 005046                  	clr	-(sp)			; zero flag
     361 012146 010246                  1$:	mov	r2,-(sp)		; radix lsb
     362 012150 005046                  	clr	-(sp)			;   and msb
     363 012152 010146                  	mov	r1,-(sp)		; number lsb
     364 012154 010046                  	mov	r0,-(sp)		;    and msb
     365 012156                         	call	uldiv			; get quo and rem
       1 012156 004737  012756          	jsr	pc,uldiv
     366 012162 016602  000006          	mov	6.(sp),r2		; restore radix from stack
     367 012166 062706  000010          	add	#8.,sp			; flush args
     368 012172 062703  000060          	add	#<'0>,r3		; make rem lsb a digit
     369 012176 020327  000071          	cmp	r3,#<'9>		; still a valid digit?
     370 012202 003402                  	ble	2$			; br if yes
     371 012204 062703  000007          	add	#<'A>-<':>,r3		; offset to 'A...'Z range
     372 012210 010346                  2$:	mov	r3,-(sp)		; save
     373 012212 005265  177770          	inc	p.len(r5)		; count digits
     374 012216 005701                  	tst	r1			; any lsb left?
     375 012220 001352                  	bne	1$			; br if yes
     376 012222 005700                  	tst	r0			; any msb left?
     377 012224 001350                  	bne	1$			; br if yes
     378                                
     379                                	; check if we generated the minimum number of digits requested
     380                                
     381 012226 026565  177770  177772  10$:	cmp	p.len(r5),p.pre(r5)	; compare length to precision
     382 012234 103005                  	bhis	20$			; br we're OK
     383 012236 012746  000060          	mov	#<'0>,-(sp)		; nope, add another digit
     384 012242 005265  177770          	inc	p.len(r5)		; count digits
     385 012246 000767                  	br	10$			; and loop	
     386                                
     387                                	; check for options (#) flag
     388                                
     389 012250 132765  000004  177777  20$:	bitb	#pf.altf,p.flg(r5)	; check for options flag
     390 012256 001422                  	beq	30$			; br if not set
     391 012260 020227  000020          	cmp	r2,#16.			; radix 16?
     392 012264 001407                  	beq	21$			; br if yes
     393 012266 020227  000010          	cmp	r2,#8.			; radix 8?
     394 012272 001014                  	bne	30$			; br if not
     395 012274 022716  000060          	cmp	#<'0>,(sp)		; first digit already zero?
     396 012300 001411                  	beq	30$			; yes, no need to add
     397 012302 000404                  	br	22$			; no, add a leading zero
     398 012304 012746  000170          21$:	mov	#<'x>,-(sp)		; add a '0x' prefix
     399 012310 005265  177770          	inc	p.len(r5)		; count it
     400 012314 012746  000060          22$:	mov	#<'0>,-(sp)		;
     401 012320 005265  177770          	inc	p.len(r5)		; count it
     402                                
     403                                	; check if we need a sign (+/-/none)
     404                                
     405 012324 132765  000020  177777  30$:	bitb	#pf.nega,p.flg(r5)	; was original value negative?
     406 012332 001403                  	beq	31$			; br if not
     407 012334 012746  000055          	mov	#<'->,-(sp)		; minus sign
     408 012340 000406                  	br	32$			;
     409 012342 132765  000002  177777  31$:	bitb	#pf.sign,p.flg(r5)	; sign always requested?
     410 012350 001404                  	beq	50$			; br if not
     411 012352 012746  000053          	mov	#<'+>,-(sp)		; plus sign
     412 012356 005265  177770          32$:	inc	p.len(r5)		; count all chars generated
     413                                
     414                                	; processing for right justification
     415                                
     416 012362 132765  000001  177777  50$:	bitb	#pf.ljus,p.flg(r5)	; check left-justify flag
     417 012370 001020                  	bne	70$			; br if left justified
     418 012372 116501  177776          	movb	p.fil(r5),r1		; get fill character
     419 012376 026565  177770  177774  51$:	cmp	p.len(r5),p.wid(r5)	; compare length to width
     420 012404 103012                  	bhis	70$			; br if we're OK
     421 012406 011600                  	mov	(sp),r0			; copy last character
     422 012410 010146                  	mov	r1,-(sp)		; add a fill character
     423 012412 020100                  	cmp	r1,r0			; check fill/last char order
     424 012414 101403                  	blos	52$			; br if order OK
     425 012416 010016                  	mov	r0,(sp)			; copy sign/last char
     426 012420 010166  000002          	mov	r1,2(sp)		; insert fill after sign
     427 012424 005265  177770          52$:	inc	p.len(r5)		; count it
     428 012430 000762                  	br	51$			; loop
     429                                
     430                                	; print all digits in order (sign..msd..lsd)
     431                                
     432 012432 005001                  70$:	clr	r1			; count characters output
     433 012434 012600                  71$:	mov	(sp)+,r0		; get a digit
     434 012436 001404                  	beq	80$			; br if no more
     435 012440                         	call	@p.out(r5)		; print it
       1 012440 004775  177766          	jsr	pc,@p.out(r5)
     436 012444 005201                  	inc	r1			; count it
     437 012446 000772                  	br	71$			; loop
     438                                
     439                                	; processing for left justification
     440                                
     441 012450 132765  000001  177777  80$:	bitb	#pf.ljus,p.flg(r5)	; check left-justify flag
     442 012456 001411                  	beq	90$			; br if is right justified
     443 012460 012700  000040          	mov	#<' >,r0		; space fill on right
     444 012464 020165  177774          81$:	cmp	r1,p.wid(r5)		; compare length to width
     445 012470 103004                  	bhis	90$			; br we're OK
     446 012472                         	call	@p.out(r5)		; print it
       1 012472 004775  177766          	jsr	pc,@p.out(r5)
     447 012476 005201                  	inc	r1			; count characters
     448 012500 000771                  	br	81$			; and loop	
     449                                
     450                                	; and done
     451                                
     452 012502 012604                  90$:	mov	(sp)+,r4		; restore regs
     453 012504 012603                  	mov	(sp)+,r3		;
     454 012506                         	return				; return
       1 012506 000207                  	rts	pc
     455                                
     456                                ; --------------------------------------------------------------------------------
     457                                ;
     458                                ; asciz string print routine
     459                                ;
     460                                ;	call:	mov	#strptr,r2
     461                                ;		call	prtstr
     462                                ;
     463                                ;		r0 - temp          (not saved)
     464                                ;		r1 - temp          (not saved)
     465                                ;		r2 - ptr to string (not saved)
     466                                ;		r3 - ptr to format     (saved) [input not used]
     467                                ;		r4 - ptr to arglist    (saved) [input not used]
     468                                ;		r5 - ptr to flags      (saved)
     469                                ;
     470 012510 010346                  prtstr:	mov	r3,-(sp)		; save regs
     471 012512 010446                  	mov	r4,-(sp)		;
     472                                
     473                                	; compute length of string
     474                                
     475 012514 010203                  	mov	r2,r3			; copy ptr to string
     476 012516 105723                  1$:	tstb	(r3)+			; check a byte
     477 012520 001376                  	bne	1$			; br if more string
     478 012522 160203                  	sub	r2,r3			; compute length
     479 012524 005303                  	dec	r3			; minus the trailing null	
     480                                
     481                                	; set precision to length if precision is zero
     482                                
     483 012526 005765  177772          	tst	p.pre(r5)		; check requested precision
     484 012532 001002                  	bne	20$			; br if nonzero
     485 012534 010365  177772          	mov	r3,p.pre(r5)		; else set to string length
     486 012540 020365  177772          20$:	cmp	r3,p.pre(r5)		; compare actual length to precision
     487 012544 101402                  	blos	50$			; br if actual <= precision
     488 012546 016503  177772          	mov	p.pre(r5),r3		; else set actual to precision
     489                                
     490                                	; processing for right justification
     491                                
     492 012552 132765  000001  177777  50$:	bitb	#pf.ljus,p.flg(r5)	; check left-justify flag
     493 012560 001002                  	bne	70$			; br if left justified
     494 012562                         	call	100$			; do fill
       1 012562 004737  012630          	jsr	pc,100$
     495                                
     496                                	; print string 
     497                                
     498 012566 010301                  70$:	mov	r3,r1			; copy length
     499 012570 001406                  	beq	80$			; br if no characters
     500 012572 112200                  71$:	movb	(r2)+,r0		; get a character
     501 012574 001404                  	beq	80$			; br if no characters
     502 012576                         	call	@p.out(r5)		; print it
       1 012576 004775  177766          	jsr	pc,@p.out(r5)
     503 012602 005301                  	dec	r1			; count
     504 012604 001372                  	bne	71$			; loop
     505                                
     506                                	; processing for left justification
     507                                
     508 012606 132765  000001  177777  80$:	bitb	#pf.ljus,p.flg(r5)	; check left-justify flag
     509 012614 001402                  	beq	90$			; br if is right justified
     510 012616                         	call	100$			; do fill
       1 012616 004737  012630          	jsr	pc,100$
     511                                
     512                                	; and done
     513                                
     514 012622 012604                  90$:	mov	(sp)+,r4		; restore
     515 012624 012603                  	mov	(sp)+,r3		;
     516 012626                         	return				; return
       1 012626 000207                  	rts	pc
     517                                
     518                                	; ----------------------------------------------------
     519                                	; generate fill characters
     520                                
     521 012630 016501  177774          100$:	mov	p.wid(r5),r1		; requested width
     522 012634 160301                  	sub	r3,r1			; subtract string width
     523 012636 101406                  	blos	102$			; br if no fill needed
     524 012640 116500  177776          	movb	p.fil(r5),r0		; get fill character
     525 012644                         101$:	call	@p.out(r5)		; print a fill character
       1 012644 004775  177766          	jsr	pc,@p.out(r5)
     526 012650 005301                  	dec	r1			; count
     527 012652 001374                  	bne	101$			; loop
     528 012654                         102$:	return				; done
       1 012654 000207                  	rts	pc
     529                                
     530                                ; --------------------------------------------------------------------------------
     531                                
     532                                .include "mac/muldiv.mac"
       1                                ;=================================================================================
       2                                ; muldiv.mac - 32b mul/div routines for macro11 diagnostics
       3                                ; (C) 2009-2016 Donald North. All rights reserved.
       4                                ;=================================================================================
       5                                
       6                                ; --------------------------------------------------------------------------------
       7                                ;
       8                                ; unsigned 32b * 32b => 32b multiplication
       9                                ; 
      10                                ; from the 2.9BSD stdio C lib, using simple shift/add algorithm
      11                                ; 
      12                                ;	call:	mov	#b.lo,-(sp)
      13                                ;		mov	#b.hi,-(sp)
      14                                ;		mov	#a.lo,-(sp)
      15                                ;		mov	#a.hi,-(sp)
      16                                ;		call	ulmul
      17                                ;		add	#8.,sp
      18                                ;		mov	r1,q.lo
      19                                ;		mov	r0,q.hi
      20                                ;
      21 012656 010246                  ulmul::	mov	r2,-(sp)		; save
      22 012660 010346                  	mov	r3,-(sp)		;
      23 012662 010446                  	mov	r4,-(sp)		;
      24 012664 010546                  	mov	r5,-(sp)		;
      25                                
      26 012666 016605  000020          	mov	8.+8.(sp),r5		; b.lo
      27 012672 016604  000016          	mov	6.+8.(sp),r4		; b.hi
      28 012676 016603  000014          	mov	4.+8.(sp),r3		; a.lo
      29 012702 016602  000012          	mov	2.+8.(sp),r2		; a.hi
      30 012706 005001                  	clr	r1			; q.lo
      31 012710 005000                  	clr	r0			; q.hi
      32                                
      33 012712 000241                  1$:	clc				; shiftin zeroes
      34 012714 006004                  	ror	r4			; shift multiplier right one
      35 012716 006005                  	ror	r5			;
      36 012720 103003                  	bcc	2$			; br if shifted out a zero
      37 012722 060301                  	add	r3,r1			; else add multiplicand to product
      38 012724 005500                  	adc	r0			; propagate C
      39 012726 060200                  	add	r2,r0			;
      40 012730 006303                  2$:	asl	r3			; shift multiplicant left one
      41 012732 006102                  	rol	r2			;
      42 012734 005704                  	tst	r4			; any high multiplier bits left?
      43 012736 001365                  	bne	1$			; br if yes
      44 012740 005705                  	tst	r5			; any low multiplier bits left?
      45 012742 001363                  	bne	1$			; br if yes
      46                                
      47 012744 012605                  	mov	(sp)+,r5		; restore
      48 012746 012604                  	mov	(sp)+,r4		;
      49 012750 012603                  	mov	(sp)+,r3		;
      50 012752 012602                  	mov	(sp)+,r2		;
      51 012754                         	return				; done
       1 012754 000207                  	rts	pc
      52                                
      53                                ; --------------------------------------------------------------------------------
      54                                ;
      55                                ; unsigned 32b / 32b => 32b, 32b division with remainder
      56                                ; 
      57                                ; from Hennessey & Patterson Appendix A
      58                                ;
      59                                ;	call:	mov	#den.lo,-(sp)	; 8.(sp)
      60                                ;		mov	#den.hi,-(sp)	; 6.(sp)
      61                                ;		mov	#num.lo,-(sp)	; 4.(sp)
      62                                ;		mov	#num.hi,-(sp)	; 2.(sp)
      63                                ;		call	uldiv
      64                                ;		add	#8.,sp
      65                                ;		mov	r3,rem.lo
      66                                ;		mov	r2,rem.hi
      67                                ;		mov	r1,quo.lo
      68                                ;		mov	r0,quo.hi
      69                                ;
      70 012756 010446                  uldiv::	mov	r4,-(sp)		; save
      71 012760 010546                  	mov	r5,-(sp)		;
      72                                
      73 012762 016601  000010          	mov	4.+4.(sp),r1		; num.lo
      74 012766 016600  000006          	mov	2.+4.(sp),r0		; num.hi
      75                                
      76 012772 005005                  	clr	r5			; tmp.lo
      77 012774 005004                  	clr	r4			; tmp.hi
      78                                
      79 012776 012746  000037          	mov	#31.,-(sp)		; bit count
      80                                
      81 013002 006301                  1$:	asl	r1			; (tmp,num) <<= 1
      82 013004 006100                  	rol	r0			;
      83 013006 006105                  	rol	r5			;
      84 013010 006104                  	rol	r4			;
      85                                
      86 013012 010503                  	mov	r5,r3			; rem = tmp - den
      87 013014 010402                  	mov	r4,r2			;
      88 013016 166603  000016          	sub	8.+6.(sp),r3		;
      89 013022 005602                  	sbc	r2			;
      90 013024 166602  000014          	sub	6.+6.(sp),r2		;
      91                                
      92 013030 100403                  	bmi	2$			; br if rem < 0
      93                                
      94 013032 005201                  	inc	r1			; quo |= 1
      95 013034 010305                  	mov	r3,r5			; tmp = rem
      96 013036 010204                  	mov	r2,r4			;
      97                                
      98 013040 005316                  2$:	dec	(sp)			; count bits
      99 013042 002357                  	bge	1$			; loop if more
     100 013044 005726                  	tst	(sp)+			; flush counter
     101                                
     102 013046 005702                  	tst	r2			; test for rem < 0
     103 013050 002005                  	bge	3$			; br if not
     104                                
     105 013052 066603  000014          	add	8.+4.(sp),r3		; rem += den correction
     106 013056 005502                  	adc	r2			;
     107 013060 066602  000012          	add	6.+4.(sp),r2		;
     108                                
     109 013064 012605                  3$:	mov	(sp)+,r5		; restore
     110 013066 012604                  	mov	(sp)+,r4		;
     111 013070                         	return				; done
       1 013070 000207                  	rts	pc
     112                                
     113                                ; --------------------------------------------------------------------------------
     114                                ;
     115                                ; signed 32b / 32b => 32b, 32b division with remainder
     116                                ; 
     117                                ;	call:	mov	#den.lo,-(sp)	; 8.(sp)
     118                                ;		mov	#den.hi,-(sp)	; 6.(sp)
     119                                ;		mov	#num.lo,-(sp)	; 4.(sp)
     120                                ;		mov	#num.hi,-(sp)	; 2.(sp)
     121                                ;		call	sldiv
     122                                ;		add	#8.,sp
     123                                ;		mov	r3,rem.lo
     124                                ;		mov	r2,rem.hi
     125                                ;		mov	r1,quo.lo
     126                                ;		mov	r0,quo.hi
     127                                ;
     128 013072 010446                  sldiv::	mov	r4,-(sp)		; save
     129                                
     130 013074 016603  000012          	mov	8.+2.(sp),r3		; den.lo
     131 013100 016602  000010          	mov	6.+2.(sp),r2		; den.hi
     132 013104 016601  000006          	mov	4.+2.(sp),r1		; num.lo
     133 013110 016600  000004          	mov	2.+2.(sp),r0		; num.hi
     134                                
     135 013114 005004                  	clr	r4			; pos
     136                                
     137 013116 005700                  	tst	r0			; num sign
     138 013120 002006                  	bge	10$			; br if pos
     139                                
     140 013122 005104                  	com	r4			; neg
     141                                
     142 013124 005101                  	com	r1			; negate num
     143 013126 005100                  	com	r0			;
     144 013130 062701  000001          	add	#1,r1			;
     145 013134 005500                  	adc	r0			; 
     146                                
     147 013136 005702                  10$:	tst	r2			; den sign
     148 013140 002006                  	bge	20$			; br if pos
     149                                
     150 013142 105104                  	comb	r4			; neg
     151                                
     152 013144 005103                  	com	r3			; negate den
     153 013146 005102                  	com	r2			;
     154 013150 062703  000001          	add	#1,r3			;
     155 013154 005502                  	adc	r2			; 
     156                                	
     157 013156 010346                  20$:	mov	r3,-(sp)		; den.lo
     158 013160 010246                  	mov	r2,-(sp)		; den.hi
     159 013162 010146                  	mov	r1,-(sp)		; num.lo
     160 013164 010046                  	mov	r0,-(sp)		; num.hi
     161 013166                         	call	uldiv			;
       1 013166 004737  012756          	jsr	pc,uldiv
     162 013172 062706  000010          	add	#8.,sp			; 
     163                                
     164 013176 005704                  	tst	r4			; invert result
     165 013200 002005                  	bge	30$			;
     166                                
     167 013202 005103                   	com	r3			; negate rem
     168 013204 005102                  	com	r2			;
     169 013206 062703  000001          	add	#1,r3			;
     170 013212 005502                  	adc	r2			; 
     171                                
     172 013214 105704                  30$:	tstb	r4			; invert result
     173 013216 002005                  	bge	40$			;
     174                                
     175 013220 005101                  	com	r1			; negate quo
     176 013222 005100                  	com	r0			;
     177 013224 062701  000001          	add	#1,r1			;
     178 013230 005500                  	adc	r0			; 
     179                                
     180 013232 012604                  40$:	mov	(sp)+,r4		; restore
     181 013234                         	return				; done
       1 013234 000207                  	rts	pc
     182                                
     183                                ;================================================================================
     184                                ; end of muldiv.mac
     185                                ;================================================================================
     185                                
     533                                
     534                                ; --------------------------------------------------------------------------------
     535                                
     536        000000                  .iif ne,pf.sep,	.end
     537                                
     538                                ;=================================================================================
     539                                ; end of printf.mac
     540                                ;=================================================================================
     540                                
     921                                
     922                                .end
     922                                


Symbol table

$$NUM  = 000012           2$1    = 002450   L       440$17 = 011674   L       BIT07  = 000200           MSIZER = 002606           
$$POS  = 000200           2$17   = 011160   L       450$17 = 011710   L       BIT08  = 000400           N.ARGS = 000016           
.      = 013236           2$18   = 012210   L       460$17 = 011724   L       BIT09  = 001000           N.LAST = 000014           
1$1    = 002422   L       2$2    = 002642   L       470$17 = 011740   L       BIT1   = 000002           NUMPAS = 002004           
1$14   = 010750   L       2$20   = 012730   L       5$1    = 002600   L       BIT10  = 002000           OPTSWI = 002002           
1$15   = 011032   L       2$21   = 013040   L       50$18  = 012362   L       BIT11  = 004000           P.FIL  = 177776           
1$16   = 011112   L       2$3    = 003050   L       50$19  = 012552   L       BIT12  = 010000           P.FLG  = 177777           
1$17   = 011140   L       20$10  = 010244   L       51$18  = 012376   L       BIT13  = 020000           P.LEN  = 177770           
1$18   = 012146   L       20$11  = 010332   L       52$18  = 012424   L       BIT14  = 040000           P.OUT  = 177766           
1$19   = 012516   L       20$12  = 010404   L       60$4   = 003510   L       BIT15  = 100000           P.PRE  = 177772           
1$2    = 002616   L       20$13  = 010550   L       61$4   = 003512   L       BIT2   = 000004           P.PTR  = 177764           
1$20   = 012712   L       20$17  = 011346   L       62$4   = 003536   L       BIT3   = 000010           P.SR0  = 000012           
1$21   = 013002   L       20$18  = 012250   L       63$4   = 003536   L       BIT4   = 000020           P.SR1  = 000010           
1$3    = 003020   L       20$19  = 012540   L       70$0   = 002330   L       BIT5   = 000040           P.SR2  = 000006           
1$4    = 003210   L       20$22  = 013156   L       70$18  = 012432   L       BIT6   = 000100           P.SR3  = 000004           
1$8    = 007404   L       20$4   = 003330   L       70$19  = 012566   L       BIT7   = 000200           P.SR4  = 000002           
10$12  = 010352   L       20$5   = 004116   L       70$4   = 003540   L       BIT8   = 000400           P.SR5  = 000000           
10$13  = 010442   L       20$6   = 004552   L       70$5   = 004250   L       BIT9   = 001000           P.WID  = 177774           
10$17  = 011232   L       20$8   = 007456   L       70$6   = 004716   L       BLBEG  = 002020           PASSES = 002040           
10$18  = 012226   L       21$18  = 012304   L       70$7   = 006332   L       BLEND  = 002022           PF.ALT = 000004           
10$22  = 013136   L       21$4   = 003352   L       70$8   = 007600   L       BLMAX  = 002010           PF.LJU = 000001           
10$4   = 003252   L       21$5   = 004140   L       71$13  = 010572   L       BLMIN  = 002006           PF.LON = 000010           
10$5   = 004054   L       21$8   = 007466   L       71$18  = 012434   L       BLMN   = 000000           PF.NEG = 000020           
10$6   = 004530   L       22$18  = 012314   L       71$19  = 012572   L       BLMSK  = 002024           PF.SEP = 000000           
10$8   = 007420   L       22$4   = 003432   L       71$4   = 003603   L       BLMX18 = 007577           PF.SIG = 000002           
10$9   = 007716   L       22$5   = 004214   L       71$5   = 004321   L       BLMX22 = 167777           PGIOS  = 000007           
100$19 = 012630   L       23$4   = 003446   L       71$6   = 004770   L       BLSZBY = 000100           PGNONE = 077400           
100$7  = 005220   L       23$5   = 004230   L       71$7   = 006402   L       BLSZIO = 000200           PGPRG  = 000000           
1000$17= 012106   L       24$4   = 003450   L       72$4   = 003737   L       BLSZUM = 010000           PGPRGN = 000001           
101$19 = 012644   L       24$5   = 004232   L       72$7   = 006463   L       CCSR   = 177746           PGRW   = 077406           
101$7  = 005242   L       3$17   = 011170   L       73$7   = 006576   L       CONSOL = 165144 G         PGSZBL = 000200           
102$19 = 012654   L       3$21   = 013064   L       74$7   = 006674   L       CR     = 000015           PGSZBY = 020000           
109$7  = 005246   L       3$3    = 003102   L       75$7   = 006773   L       CRLF   = 010157           PGTST  = 000006           
11$17  = 011260   L       30$10  = 010254   L       76$7   = 007072   L       DISECC = 010336           PHYADR = 002044           
11$4   = 003274   L       30$12  = 010412   L       77$7   = 007153   L       DONE   = 007664           PRINTF = 010766 G         
11$5   = 004076   L       30$13  = 010556   L       80$18  = 012450   L       DPYREG = 177570 G         PROTMN = 002026           
11$8   = 007430   L       30$18  = 012324   L       80$19  = 012606   L       ENBECC = 010420           PROTMX = 002030           
110$7  = 005302   L       30$22  = 013214   L       800$17 = 011754   L       ENMMGT = 002412           PRT32U = 012140           
111$7  = 005330   L       30$6   = 004574   L       81$18  = 012464   L       ERRORS = 002036           PRTSTR = 012510           
112$7  = 005416   L       30$8   = 007516   L       810$17 = 011774   L       EXIT   = 007700           PSW    = 177776 G         
113$7  = 005500   L       31$18  = 012342   L       820$17 = 011776   L       FAILS  = 000000           SLDIV  = 013072 G         
119$7  = 005502   L       31$6   = 004662   L       880$17 = 012040   L       FLG22B = 002034           SPRINT = 011046 G         
12$17  = 011312   L       32$18  = 012356   L       890$17 = 012046   L       KPAR   = 172340           STACK  = 002000           
12$4   = 003314   L       32$6   = 004676   L       90$18  = 012502   L       KPDR   = 172300           START  = 002200           
12$5   = 004102   L       32768$0= 002212   L       90$19  = 012622   L       LF     = 000012           SWIREG = 177570 G         
120$7  = 005536   L       32769$0= 002220   L       900$17 = 012050   L       LOOP   = 003126           TEST1  = 003136           
121$7  = 005560   L       32770$0= 002236   L       99$0   = 002410   L       MCR0   = 172100           TEST2  = 004012           
122$7  = 005646   L       32771$0= 002250   L       99$4   = 004006   L       MCRDET = 002766           TEST3  = 004466           
129$7  = 005650   L       34$6   = 004700   L       99$5   = 004462   L       MCRMSK = 002032           TEST4  = 005136           
13$17  = 011330   L       4$1    = 002556   L       99$6   = 005132   L       MEMBL  = 002012           TESTNO = 002042           
130$7  = 005704   L       4$17   = 011224   L       99$7   = 007320   L       MEMBYH = 002016           TST$NO = 000005           
131$7  = 005732   L       40$10  = 010272   L       99$8   = 007662   L       MEMBYL = 002014           TSTMAX = 140077           
132$7  = 006012   L       40$17  = 011400   L       990$17 = 012066   L       MMR0   = 177572           TSTMIN = 140000           
139$7  = 006014   L       40$22  = 013232   L       ADRCHK = 010714 G         MMR1   = 177574           TSTPAR = 172354           
140$7  = 006050   L       400$17 = 011450   L       ADRTST = 010312           MMR2   = 177576           TSTWC  = 000040           
141$7  = 006072   L       401$17 = 011534   L       ADRXLT = 010162           MMR3   = 172516           TTRBUF = 177562 G         
142$7  = 006154   L       405$17 = 011550   L       BIT0   = 000001           MRELOC = 007354           TTRCSR = 177560 G         
149$7  = 006156   L       41$17  = 011404   L       BIT00  = 000001           MSG1   = 007726           TTXBUF = 177566 G         
150$7  = 006212   L       410$17 = 011566   L       BIT01  = 000002           MSG2   = 007763           TTXCSR = 177564 G         
151$7  = 006234   L       42$17  = 011434   L       BIT02  = 000004           MSG3   = 007777           ULDIV  = 012756 G         
152$7  = 006310   L       420$17 = 011600   L       BIT03  = 000010           MSG4   = 010033           ULMUL  = 012656 G         
159$7  = 006312   L       430$17 = 011620   L       BIT04  = 000020           MSG5A  = 010104           XPRINT = 011136           
18$13  = 010536   L       431$17 = 011644   L       BIT05  = 000040           MSG5B  = 010141           
19$13  = 010544   L       439$17 = 011664   L       BIT06  = 000100           MSG5C  = 010147           


Program sections:

. ABS.  013236    000   (RW,I,GBL,ABS,OVR,NOSAV)
        000000    001   (RW,I,LCL,REL,CON,NOSAV)
