       1                                .title	Memory Exerciser Diagnostic Test
       2                                
       3                                ; (C) 2010-2016 Donald North. All rights reserved.
       4                                
       5                                .include "mac/stddef.mac"
       1                                ;================================================================================
       2                                ; stddef.mac - standard definitions
       3                                ; (C) 2009 Donald North. All rights reserved.
       4                                ;================================================================================
       5                                .macro	align	arg1
      16                                ;================================================================================
      17                                .macro	savreg	arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8
      28                                ;================================================================================
      29                                .macro	resreg	arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8
      40                                ;================================================================================
      41                                .macro	call	proc
      44                                .macro	return
      47                                .macro	calls	proc arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8 arg9 arg10 arg11 arg12 arg13 arg14 arg15 arg16
      67                                ;================================================================================
      68                                .macro	jeq	label ?a1
      73                                .macro	jne	label ?a1
      78                                .macro	jpl	label ?a1
      83                                .macro	jmi	label ?a1
      88                                .macro	jlo	label ?a1
      93                                .macro	jhis	label ?a1
      98                                .macro	jlos	label ?a1
     103                                .macro	jhi	label ?a1
     108                                .macro	jlt	label ?a1
     113                                .macro	jge	label ?a1
     118                                .macro	jle	label ?a1
     123                                .macro	jgt	label ?a1
     128                                .macro	jcc	label ?a1
     133                                .macro	jcs	label ?a1
     138                                .macro	jvc	label ?a1
     143                                .macro	jvs	label ?a1
     148                                ;================================================================================
     149                                .macro	printf	arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8 arg9 arg10 arg11 arg12 arg13 arg14 arg15 arg16
     152                                .macro	sprintf	arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8 arg9 arg10 arg11 arg12 arg13 arg14 arg15 arg16
     155                                ;================================================================================
     156                                .macro	ipl	lvl
     161                                ;================================================================================
     162                                .macro	trapcatcher	list ?a1 ?a2 ?a3 ?a4
     176                                ;================================================================================
     177        000001                  tst$no	= 1
     178                                .macro	test	title
     198                                ;================================================================================
     199                                ; end of stddef.mac
     200                                ;================================================================================
     200                                
       6                                
       7                                ; --------------------------------------------------------------------------------
       8                                
       9                                .sbttl	general definitions
      10                                
      11        000000                  fails	=0			; 1 for force fails, 0 for normal
      12                                
      13                                .include "mac/bits.mac"
       1                                ;================================================================================
       2                                ; bits.mac - standard bit definitions
       3                                ;================================================================================
       4                                
       5                                ;  system global fixed addresses
       6                                
       7        177776                  psw	==177776		; processor status word
       8                                
       9        165144                  console	==165144		; console routine start
      10                                
      11        177570                  swireg	==177570		; console switch register
      12        177570                  dpyreg	==swireg		; console display register
      13                                
      14        177560                  ttrcsr	==177560		; console serial device
      15        177562                  ttrbuf	==ttrcsr+2		;
      16        177564                  ttxcsr	==ttrcsr+4		;
      17        177566                  ttxbuf	==ttrcsr+6		;
      18                                
      19                                ; common values
      20                                
      21        000015                  cr	=015			; ascii CR
      22        000012                  lf	=012			; ascii LF
      23                                
      24        000001                  bit00	=000001			; bit positions
      25        000002                  bit01	=000002			;
      26        000004                  bit02	=000004			;
      27        000010                  bit03	=000010			;
      28        000020                  bit04	=000020			;
      29        000040                  bit05	=000040			;
      30        000100                  bit06	=000100			;
      31        000200                  bit07	=000200			;
      32        000400                  bit08	=000400			;
      33        001000                  bit09	=001000			;
      34        002000                  bit10	=002000			;
      35        004000                  bit11	=004000			;
      36        010000                  bit12	=010000			;
      37        020000                  bit13	=020000			;
      38        040000                  bit14	=040000			;
      39        100000                  bit15	=100000			;
      40                                	
      41        000001                  bit0	=bit00			; also
      42        000002                  bit1	=bit01			;
      43        000004                  bit2	=bit02			;
      44        000010                  bit3	=bit03			;
      45        000020                  bit4	=bit04			;
      46        000040                  bit5	=bit05			;
      47        000100                  bit6	=bit06			;
      48        000200                  bit7	=bit07			;
      49        000400                  bit8	=bit08			;
      50        001000                  bit9	=bit09			;
      51                                
      52                                ;================================================================================
      53                                ; end of bits.mac
      54                                ;================================================================================
      54                                
      14                                
      15                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      16                                
      17                                .sbttl	memory definitions
      18                                
      19        177572                  mmr0	=177572			; mem mgt sr#0 ... error/status, enable
      20        177574                  mmr1	=177574			; mem mgt sr#1 ... register modifications
      21        177576                  mmr2	=177576			; mem mgt sr#2 ... virtual address
      22        172516                  mmr3	=172516			; mem mgt sr#3 ... ispace, 22b, map enables
      23                                
      24        172340                  kpar	=172340			; mem mgt kernel page addr reg base
      25        172300                  kpdr	=172300			; mem mgt kernel page desc reg base
      26                                
      27        177746                  ccsr	=177746			; cache control register ... cache force miss
      28                                
      29        000000                  pgprg	=0			; first program page
      30        000004                  pgprgn	=4			; number of 8KB program pages (must be power of two)
      31        000006                  pgtst	=6			; memory test page
      32        000007                  pgios	=7			; i/o page
      33                                
      34        020000                  pgszby	=8192.			; size of a page, bytes
      35        000200                  pgszbl	=128.			; size of a page, blocks
      36        000100                  blszby	=64.			; size of a block, bytes
      37        000200                  blszio	=8.*<1024./blszby>	; size of 8KB I/O page, blocks
      38        010000                  blszum	=256.*<1024./blszby>	; size of 256K U/B map, blocks
      39                                	
      40        000000                  blmn	=0.			; min memory block number we can test
      41        007577                  blmx18	=4095.-blszio		; max memory block number we can test, 18b mode, minus I/O page
      42        167777                  blmx22	=65535.-blszum		; max memory block number we can test, 22b mode, minus U/B map
      43                                
      44        077406                  pgrw	=077406			; PDR value for a full size r/w page
      45        077400                  pgnone	=077400			; PDR value for a full size missing page
      46                                
      47        140000                  tstmin	=pgtst*pgszby		; test block, address base
      48        140077                  tstmax	=tstmin+blszby-1	; test block, address max
      49        000040                  tstwc	=blszby/2		; test block, size in words
      50        172354                  tstpar	=kpar+<pgtst*2>		; ptr to KPAR for block number
      51                                
      52        172100                  mcr0	=172100			; memory control csr base
      53                                
      54                                ; --------------------------------------------------------------------------------
      55                                
      56                                .sbttl	low memory
      57                                
      58                                	.enabl	ama			; change all mode 67 references to 37
      59                                
      60 000000                         	.asect				; absolute load image
      61                                
      62        000046                  	.=46
      63 000046 007702                  	.word	$endad			; address of JSR PC,(R0)
      64        000052                  	.=52
      65 000052 000000                  	.word	0			; run options
      66                                
      67        000200                  	.=200
      68 000200 000137  002200          	jmp	@#start			; standard diag entry
      69                                
      70                                ; --------------------------------------------------------------------------------
      71                                
      72                                .sbttl	global variables
      73                                
      74        002000                  	.=2000
      75 002000 177777                  stack:	.word	-1			; top of stack
      76 002002 000000                  optswi:	.word	0			; option switches, bit0 = run with ECC enabled
      77 002004 000024                  numpas:	.word	20.			; number of passes to run
      78 002006 000000                  blmin:	.word	blmn			; set to blmn
      79 002010 007577                  blmax:	.word	blmx18			; set to either blmx18/blmx22
      80 002012 000000                  membl:	.word	0			; memory size in blocks
      81 002014 000000                  membyl:	.word	0			; memory size in bytes, lsb
      82 002016 000000                  membyh:	.word	0			; memory size in bytes, msb
      83 002020 000000                  blbeg:	.word	0			; begin block number for tests
      84 002022 000000                  blend:	.word	0			; end   block number for tests
      85 002024 001777                  blmsk:	.word	1777			; 16K device boundary address mask
      86 002026 000000                  protmn:	.word	0			; begin block number of protected space
      87 002030 000777                  protmx:	.word	<pgprgn*pgszbl>-1	; end block number of protected space
      88 002032 000000                  mcrmsk:	.word	0			; bitmask of mcsr's that exist
      89 002034 000000                  flg22b:	.word	0			; set nonzero for 22b system
      90 002036 000000                  errors:	.word	0			; count errors
      91 002040 000000                  passes:	.word	0			; count passes
      92 002042 000000                  testno:	.word	0			; current test number
      93        002044                  phyadr:	.blkw	2			; physical address of error
      94 002050 000000                  $sav42:	.word	0			; XXDP restart address
      95                                	.even
      96                                
      97                                ; --------------------------------------------------------------------------------
      98                                
      99                                .sbttl	program start
     100                                
     101 002052                         	align	7			; pc alignment
     102                                
     103 002200 012706  002000          start:	mov	#stack,sp		; setup a stack
     104 002204 000005                  	reset				; reset the world
     105 002206 013737  000042  002050  	mov	@#42,$sav42		; save XXDP restart
     106                                
     107 002214                         	trapcatcher <2,200,206,400>	; setup a trapcatcher in low vector space
       1 002214 012700  002244          	mov	#32770$,r0    		; ptr to table
       2 002220 012001                  32768$:	mov	(r0)+,r1		; start addr
       3 002222 100415                  	bmi	32771$			; done?
       4 002224 012002                  	mov	(r0)+,r2		; end addr
       5 002226 010161  177776          32769$:	mov	r1,-2(r1)		; point vector at next word
       6 002232 005011                  	clr	(r1)			; <0> which is a halt
       7 002234 022121                  	cmp	(r1)+,(r1)+		; add four to ptr
       8 002236 020102                  	cmp	r1,r2			; reached end?
       9 002240 003772                  	ble	32769$			; not yet
      10 002242 000766                  	br	32768$			; more
      11 002244 000002  000200  000206  32770$:	.word	2,200,206,400, -1
         002252 000400  177777          
      12 002256 000240                  32771$:	nop				; placeholder
     108                                
     109 002260                         	printf	#msg1			; say hello
       1 002260                         	calls	printf #msg1               
       9 002260 012746  007760          	mov	#msg1,-(sp)
       2 002264                         	call	printf
       1 002264 004737  011020          	jsr	pc,printf
       3 002270 062706  000002          	add	#2,sp
     110                                
     111 002274 005037  002036          	clr	errors			; none yet
     112 002300 005037  002040          	clr	passes			; ditto
     113                                
     114                                	; test for memmgt, exit if none available
     115                                
     116 002304 012700  177572          	mov	#mmr0,r0		; main memmgt control
     117 002310                         	call	adrchk			; check if exists
       1 002310 004737  010746          	jsr	pc,adrchk
     118 002314 103440                  	bcs	99$			; br if OK
     119                                
     120 002316                         	printf	#70$			; print a message
       1 002316                         	calls	printf #70$               
       9 002316 012746  002336          	mov	#70$,-(sp)
       2 002322                         	call	printf
       1 002322 004737  011020          	jsr	pc,printf
       3 002326 062706  000002          	add	#2,sp
     121 002332 000137  007732          	jmp	exit			; just exit	
     122                                
     123 002336    015     012     124  70$:	.asciz	<cr><lf>"This diagnostic requires memory management"<cr><lf>
         002341    150     151     163  
         002344    040     144     151  
         002347    141     147     156  
         002352    157     163     164  
         002355    151     143     040  
         002360    162     145     161  
         002363    165     151     162  
         002366    145     163     040  
         002371    155     145     155  
         002374    157     162     171  
         002377    040     155     141  
         002402    156     141     147  
         002405    145     155     145  
         002410    156     164     015  
         002413    012     000          
     124 002415    000                  	.even
     125                                
     126 002416 000240                  99$:	nop
     127                                
     128                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     129                                
     130                                .sbttl	setup/enable memory management
     131                                
     132 002420 012701  172300          enmmgt:	mov	#kpdr,r1		; base register
     133 002424 012702  000010          	mov	#8.,r2			; number of reg pairs
     134 002430 005061  000040          1$:	clr	kpar-kpdr(r1)		; init KPAR[n]
     135 002434 012721  077400          	mov	#pgnone,(r1)+		; init KPDR[n]
     136 002440 077205                  	sob	r2,1$			; loop over all pairs
     137                                
     138 002442 012701  172300          	mov	#kpdr+<2*pgprg>,r1	; ptr to first base register
     139 002446 012702  000004          	mov	#pgprgn,r2		; number of program pages
     140 002452 012703  000000          	mov	#0, r3			; first physical block address
     141 002456 010361  000040          2$:	mov	r3,kpar-kpdr(r1)	; init KPAR[n]
     142 002462 012721  077406          	mov	#pgrw,(r1)+		; init KPDR[n] as r/w page
     143 002466 062703  000200          	add	#pgszbl,r3		; incr physical block address
     144 002472 077207                  	sob	r2,2$			; loop over all pages
     145                                
     146 002474 010337  172354          	mov	r3,@#kpar+<pgtst*2>	; map test page to physical 8KB
     147 002500 012737  077406  172314  	mov	#pgrw,@#kpdr+<pgtst*2>	; full page, r/w access
     148                                
     149 002506 012737  177600  172356  	mov	#511.*pgszbl,@#kpar+<pgios*2> ; map iopage to physical last page
     150 002514 012737  077406  172316  	mov	#pgrw,@#kpdr+<pgios*2>	; full page, r/w access
     151                                
     152 002522 012737  000000  002034  	mov	#0,flg22b		; set 18b flag
     153 002530 012737  007577  002010  	mov	#blmx18,blmax		; set maximum block number, 18b
     154                                
     155 002536 032737  170000  172356  	bit	#170000,@#kpar+<pgios*2> ; could we set the 22b physical addr bits?
     156 002544 001420                  	beq	5$			; br if not, 18b system
     157                                
     158 002546 012700  177746          	mov	#ccsr,r0		; cache control register
     159 002552                         	call	adrchk			; check if exists
       1 002552 004737  010746          	jsr	pc,adrchk
     160 002556 103002                  	bcc	4$			; br if not
     161 002560 012710  000014          	mov	#bit3+bit2,(r0)		; force miss high/low (disable cache)
     162                                
     163 002564 012737  177777  002034  4$:	mov	#-1,flg22b		; set 22b flag
     164 002572 012737  167777  002010  	mov	#blmx22,blmax		; set maximum block number, 22b
     165 002600 012737  000020  172516  	mov	#bit4,@#mmr3		; enable 22b mem mgt mode	
     166                                
     167 002606 012737  000001  177572  5$:	mov	#bit0,@#mmr0		; turn on mem mgt, hope we don't die...
     168                                
     169                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     170                                
     171                                .sbttl	size physical memory
     172                                
     173 002614 013701  002006          msizer:	mov	blmin,r1		; first available physical block
     174 002620 012700  140000          	mov	#tstmin,r0		; test at this address
     175                                
     176 002624 010137  172354          1$:	mov	r1,@#tstpar		; point test page at physical page
     177 002630                         	call	adrchk			; test the address in R0, may fail
       1 002630 004737  010746          	jsr	pc,adrchk
     178 002634 103005                  	bcc	2$			; br if not there
     179 002636 005201                  	inc	r1			; bump to next block
     180 002640 020137  002010          	cmp	r1,blmax		; hit end of blocks?
     181 002644 001367                  	bne	1$			; not yet, keep looping
     182 002646 005201                  	inc	r1			; no trap, point at next block
     183                                
     184 002650 010137  002012          2$:	mov	r1,membl		; save number of memory blocks
     185                                
     186 002654 013700  002012          	mov	membl,r0		; size in blocks
     187 002660 070027  000100          	mul	#blszby,r0		; compute memory size, bytes
     188 002664 042700  177700          	bic	#^c77,r0		; max limit is 4096KB
     189 002670 010137  002014          	mov	r1,membyl		; size in bytes, lsb
     190 002674 010037  002016          	mov	r0,membyh		; size in bytes, msb
     191                                
     192 002700 013701  002012          	mov	membl,r1		; size in blocks, lsb
     193 002704 005000                  	clr	r0			; msb
     194 002706 071027  000020          	div	#16.,r0			; size in Kbytes
     195                                
     196 002712                         	printf	#msg4,r0,membyh,membyl	; format, size in KB, size msb, size lsb
       1 002712                         	calls	printf #msg4 r0 membyh membyl            
       9 002712 013746  002014          	mov	membyl,-(sp)
      15 002716 013746  002016          	mov	membyh,-(sp)
      21 002722 010046                  	mov	r0,-(sp)
      27 002724 012746  010065          	mov	#msg4,-(sp)
       2 002730                         	call	printf
       1 002730 004737  011020          	jsr	pc,printf
       3 002734 062706  000010          	add	#10,sp
     197                                
     198 002740 013737  002006  002020  	mov	blmin,blbeg		; min test block number
     199 002746 013737  002012  002022  	mov	membl,blend		; max test block number
     200 002754 005337  002022          	dec	blend			;
     201                                
     202 002760 013737  002006  002026  	mov	blmin, protmn		; begin block number of protected space
     203 002766 012737  000777  002030  	mov	#<pgprgn*pgszbl>-1,protmx ; end block number of protected space
     204                                
     205                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     206                                
     207                                .sbttl	determine number of memory control registers
     208                                
     209 002774 012700  172100          mcrdet:	mov	#mcr0,r0		; ptr to first memory csr
     210 003000 012701  000001          	mov	#bit0,r1		; bit mask counter
     211 003004 005002                  	clr	r2			; bitmask of csr found
     212 003006 012703  000020          	mov	#16.,r3			; maximum number of registers
     213 003012                         	printf	#msg5a			; memory control register header
       1 003012                         	calls	printf #msg5a               
       9 003012 012746  010136          	mov	#msg5a,-(sp)
       2 003016                         	call	printf
       1 003016 004737  011020          	jsr	pc,printf
       3 003022 062706  000002          	add	#2,sp
     214                                
     215 003026                         1$:	call	adrchk			; check if (r0) exists
       1 003026 004737  010746          	jsr	pc,adrchk
     216 003032 103011                  	bcc	2$			; br if not
     217 003034 005010                  	clr	(r0)			; init a csr
     218 003036                         	printf	#msg5b,r0		; print register address
       1 003036                         	calls	printf #msg5b r0              
       9 003036 010046                  	mov	r0,-(sp)
      15 003040 012746  010173          	mov	#msg5b,-(sp)
       2 003044                         	call	printf
       1 003044 004737  011020          	jsr	pc,printf
       3 003050 062706  000004          	add	#4,sp
     219 003054 050102                  	bis	r1,r2			; indicate present
     220 003056 006301                  2$:	asl	r1			; shift mask left
     221 003060 062700  000002          	add	#2,r0			; bump pointer
     222 003064 077320                  	sob	r3,1$			; loop
     223                                
     224 003066 010237  002032          	mov	r2,mcrmsk		; save bitmask of memory csrs
     225 003072 001006                  	bne	3$			; br if at least one
     226 003074                         	printf	#msg5c			; message about none
       1 003074                         	calls	printf #msg5c               
       9 003074 012746  010201          	mov	#msg5c,-(sp)
       2 003100                         	call	printf
       1 003100 004737  011020          	jsr	pc,printf
       3 003104 062706  000002          	add	#2,sp
     227 003110                         3$:	printf	#crlf			; done
       1 003110                         	calls	printf #crlf               
       9 003110 012746  010211          	mov	#crlf,-(sp)
       2 003114                         	call	printf
       1 003114 004737  011020          	jsr	pc,printf
       3 003120 062706  000002          	add	#2,sp
     228                                
     229                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     230                                
     231                                .sbttl	set psw to zero
     232                                
     233 003124 005046                  	clr	-(sp)			; zap psw
     234 003126 012746  003134          	mov	#loop,-(sp)		; fake pc
     235 003132 000002                  	rti				; reload psw
     236                                
     237                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     238                                
     239 003134 000240                  loop:	nop				; next pass enters here
     240 003136 012737  000001  002042  	mov	#1,testno		; current test number
     241                                
     242                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     243                                
     244 003144                         	test	<constant data patterns>
       2                                
       3                                	;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       4                                	.sbttl	Test1 - constant data patterns
       5                                	;------------------------------------------------------------
       6                                
       7                                test1:	; start of test
       8                                
       9 003144 022737  000001  002042  	cmp	#1,testno		; check for sequence error
      10 003152 001401                  	beq	.+4			; OK, skip over halt
      11 003154 000000                  	halt				; FATAL - SEQUENCE ERROR
     245                                
     246 003156                         	printf	#70$,testno		; header message
       1 003156                         	calls	printf #70$ testno              
       9 003156 013746  002042          	mov	testno,-(sp)
      15 003162 012746  003546          	mov	#70$,-(sp)
       2 003166                         	call	printf
       1 003166 004737  011020          	jsr	pc,printf
       3 003172 062706  000004          	add	#4,sp
     247                                
     248 003176                         	call	disecc			; disable ecc
       1 003176 004737  010370          	jsr	pc,disecc
     249                                
     250 003202 012737  000141  003544  	mov	#<'a>,63$		; subtest index
     251 003210 012737  003520  003516  	mov	#61$,60$		; ptr to data table
     252 003216 013703  003516          1$:	mov	60$,r3			; get pattern address
     253 003222 011302                  	mov	(r3),r2			; get expected pattern
     254 003224                         	printf	#72$,testno,63$,r2,r2	; subheader message
       1 003224                         	calls	printf #72$ testno 63$ r2 r2           
       9 003224 010246                  	mov	r2,-(sp)
      15 003226 010246                  	mov	r2,-(sp)
      21 003230 013746  003544          	mov	63$,-(sp)
      27 003234 013746  002042          	mov	testno,-(sp)
      33 003240 012746  003745          	mov	#72$,-(sp)
       2 003244                         	call	printf
       1 003244 004737  011020          	jsr	pc,printf
       3 003250 062706  000012          	add	#12,sp
     255                                
     256                                	; fill each block with a constant data pattern
     257                                
     258 003254 013705  002020          	mov	blbeg,r5		; starting block number
     259 003260                         10$:	call	adrtst			; check ok to test this block
       1 003260 004737  010344          	jsr	pc,adrtst
     260 003264 103016                  	bcc	12$			; br if not
     261 003266 010537  172354          	mov	r5,@#tstpar		; point mmu at test block
     262 003272 012704  140000          	mov	#tstmin,r4		; start block address
     263 003276 012703  000040          	mov	#tstwc,r3		; this many words
     264 003302 005102                  11$:	com	r2			; invert pattern
     265 003304 010214                  	mov	r2,(r4)			; write as a word
     266 003306 005102                  	com	r2			; back to normal
     267 003310 110224                  	movb	r2,(r4)+		; write first byte
     268 003312 000302                  	swab	r2			; flip
     269 003314 110224                  	movb	r2,(r4)+		; write second byte
     270 003316 000302                  	swab	r2			; back to normal
     271 003320 077310                  	sob	r3,11$			; loop for block size
     272 003322 005205                  12$:	inc	r5			; incr test block
     273 003324 020537  002022          	cmp	r5,blend		; at the end?
     274 003330 101753                  	blos	10$			; br if more to do
     275                                
     276                                	; check each block has its pattern
     277                                
     278 003332 013705  002020          	mov	blbeg,r5		; starting block number
     279 003336                         20$:	call	adrtst			; check ok to test this block
       1 003336 004737  010344          	jsr	pc,adrtst
     280 003342 103045                  	bcc	24$			; br if not
     281 003344 010537  172354          	mov	r5,@#tstpar		; point mmu at test block
     282 003350 012704  140000          	mov	#tstmin,r4		; start block address
     283 003354 012703  000040          	mov	#tstwc,r3		; this many words
     284 003360 012401                  21$:	mov	(r4)+,r1		; get block address
     285        000000                  .if ne fails
     286                                	cmp	#1,passes		; only fail on pass2
     287                                	bne	66$			; br if OK
     288                                	cmp	r4,#tstmin+74+2		; fail offset
     289                                	bne	66$			; br if not
     290                                	cmp	r5,#123456		; first fail block
     291                                	bne	66$			; br if not
     292                                	com	r1			; yes, fudge data
     293                                66$:	nop				; placeholder
     294                                .endc
     295 003362 020201                  	cmp	r2,r1			; compare expected:received
     296 003364 001433                  	beq	23$			; br if matches
     297                                
     298 003366 010446                  	mov	r4,-(sp)		; virtual address of error
     299 003370 162716  000002          	sub	#2,(sp)			; backup
     300 003374                         	call	adrxlt			; translate to physical
       1 003374 004737  010214          	jsr	pc,adrxlt
     301 003400                         	printf	#71$,testno,63$,phyadr+0,phyadr+2,r2,r1 ; format, test, addrhi/lo, exp, rcv
       1 003400                         	calls	printf #71$ testno 63$ phyadr+0 phyadr+2 r2 r1         
       9 003400 010146                  	mov	r1,-(sp)
      15 003402 010246                  	mov	r2,-(sp)
      21 003404 013746  002046          	mov	phyadr+2,-(sp)
      27 003410 013746  002044          	mov	phyadr+0,-(sp)
      33 003414 013746  003544          	mov	63$,-(sp)
      39 003420 013746  002042          	mov	testno,-(sp)
      45 003424 012746  003611          	mov	#71$,-(sp)
       2 003430                         	call	printf
       1 003430 004737  011020          	jsr	pc,printf
       3 003434 062706  000016          	add	#16,sp
     302                                
     303 003440 005237  002036          22$:	inc	errors			; count errors
     304 003444 001775                  	beq	22$			;
     305 003446 053705  002024          	bis	blmsk,r5		; bump to last block...
     306 003452 000401                  	br	24$			; exit early...
     307                                
     308 003454 077337                  23$:	sob	r3,21$			; loop for block size
     309                                
     310 003456 005205                  24$:	inc	r5			; incr test block
     311 003460 020537  002022          	cmp	r5,blend		; at the end?
     312 003464 101724                  	blos	20$			; br if more to do
     313                                
     314 003466 005237  003544          	inc	63$			; bump index id
     315 003472 062737  000002  003516  	add	#2,60$			; bump ptr
     316 003500 022737  003544  003516  	cmp	#62$,60$		; end of table?
     317 003506 001243                  	bne	1$			; br if not yet
     318                                
     319 003510                         	call	enbecc			; check for errors, reenable ecc
       1 003510 004737  010452          	jsr	pc,enbecc
     320                                
     321 003514 000537                  	br	99$			; next test
     322                                
     323 003516 003520                  60$:	.word	61$			; ptr to data table
     324                                					;
     325 003520 000000                  61$:	.word	^b0000000000000000	;\
     326 003522 177777                  	.word	^b1111111111111111	; \
     327 003524 000377                  	.word	^b0000000011111111	; |
     328 003526 177400                  	.word	^b1111111100000000	; |
     329 003530 007417                  	.word	^b0000111100001111	; | -- table of patterns
     330 003532 170360                  	.word	^b1111000011110000	; |
     331 003534 031463                  	.word	^b0011001100110011	; |
     332 003536 146314                  	.word	^b1100110011001100	; |
     333 003540 052525                  	.word	^b0101010101010101	; /
     334 003542 125252                  	.word	^b1010101010101010	;/
     335                                62$:					;
     336                                					; end of table
     337        003544                  63$:	.blkw	1.			; subtest index
     338                                
     339 003546    015     012     124  70$:	.asciz	<cr><lf>"Test%d: constant data patterns"<cr><lf>
         003551    145     163     164  
         003554    045     144     072  
         003557    040     143     157  
         003562    156     163     164  
         003565    141     156     164  
         003570    040     144     141  
         003573    164     141     040  
         003576    160     141     164  
         003601    164     145     162  
         003604    156     163     015  
         003607    012     000          
     340 003611    124     145     163  71$:	.ascii	"Test%d%c: constant data patterns failure"<cr><lf>
         003614    164     045     144  
         003617    045     143     072  
         003622    040     143     157  
         003625    156     163     164  
         003630    141     156     164  
         003633    040     144     141  
         003636    164     141     040  
         003641    160     141     164  
         003644    164     145     162  
         003647    156     163     040  
         003652    146     141     151  
         003655    154     165     162  
         003660    145     015     012  
     341 003663    040     040     120  	.ascii	"  PhysAddr  Exp'ed  Rcv'ed"<cr><lf>
         003666    150     171     163  
         003671    101     144     144  
         003674    162     040     040  
         003677    105     170     160  
         003702    047     145     144  
         003705    040     040     122  
         003710    143     166     047  
         003713    145     144     015  
         003716    012                  
     342 003717    040     040     045  	.asciz	"  %.8lp  %.6o  %.6o"<cr><lf>
         003722    056     070     154  
         003725    160     040     040  
         003730    045     056     066  
         003733    157     040     040  
         003736    045     056     066  
         003741    157     015     012  
         003744    000                  
     343 003745    124     145     163  72$:	.asciz	"Test%d%c: data pattern %.6o (%.16b)"<cr><lf>
         003750    164     045     144  
         003753    045     143     072  
         003756    040     144     141  
         003761    164     141     040  
         003764    160     141     164  
         003767    164     145     162  
         003772    156     040     045  
         003775    056     066     157  
         004000    040     050     045  
         004003    056     061     066  
         004006    142     051     015  
         004011    012     000          
     344 004013    000                  	.even
     345                                
     346 004014 005237  002042          99$:	inc	testno			; count tests
     347                                
     348                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     349                                
     350 004020                         	test	<unique physical block select test>
       2                                
       3                                	;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       4                                	.sbttl	Test2 - unique physical block select test
       5                                	;------------------------------------------------------------
       6                                
       7                                test2:	; start of test
       8                                
       9 004020 022737  000002  002042  	cmp	#2,testno		; check for sequence error
      10 004026 001401                  	beq	.+4			; OK, skip over halt
      11 004030 000000                  	halt				; FATAL - SEQUENCE ERROR
     351                                
     352 004032                         	printf	#70$,testno		; header message
       1 004032                         	calls	printf #70$ testno              
       9 004032 013746  002042          	mov	testno,-(sp)
      15 004036 012746  004256          	mov	#70$,-(sp)
       2 004042                         	call	printf
       1 004042 004737  011020          	jsr	pc,printf
       3 004046 062706  000004          	add	#4,sp
     353                                
     354 004052                         	call	disecc			; disable ecc
       1 004052 004737  010370          	jsr	pc,disecc
     355                                
     356                                	; fill each block with its address
     357                                
     358 004056 013705  002020          	mov	blbeg,r5		; starting block number
     359 004062                         10$:	call	adrtst			; check ok to test this block
       1 004062 004737  010344          	jsr	pc,adrtst
     360 004066 103010                  	bcc	12$			; br if not
     361 004070 010537  172354          	mov	r5,@#tstpar		; point mmu at test block
     362 004074 012704  140000          	mov	#tstmin,r4		; start block address
     363 004100 012703  000040          	mov	#tstwc,r3		; this many words
     364 004104 010524                  11$:	mov	r5,(r4)+		; fill with block address
     365 004106 077302                  	sob	r3,11$			; loop for block size
     366 004110 005205                  12$:	inc	r5			; incr test block
     367 004112 020537  002022          	cmp	r5,blend		; at the end?
     368 004116 101761                  	blos	10$			; br if more to do
     369                                
     370                                	; check each block has its address
     371                                
     372 004120 013705  002020          	mov	blbeg,r5		; starting block number
     373 004124                         20$:	call	adrtst			; check ok to test this block
       1 004124 004737  010344          	jsr	pc,adrtst
     374 004130 103043                  	bcc	24$			; br if not
     375 004132 010537  172354          	mov	r5,@#tstpar		; point mmu at test block
     376 004136 012704  140000          	mov	#tstmin,r4		; start block address
     377 004142 012703  000040          	mov	#tstwc,r3		; this many words
     378 004146 012402                  21$:	mov	(r4)+,r2		; get block address
     379        000000                  .if ne fails
     380                                	cmp	#1,passes		; only fail on pass2
     381                                	bne	66$			; br if OK
     382                                	cmp	r4,#tstmin+4+2		; fail offset
     383                                	bne	66$			; br if not
     384                                	cmp	r5,#004321		; first fail block
     385                                	bne	66$			; br if not
     386                                	com	r2			; yes, fudge data
     387                                66$:	nop				; placeholder
     388                                .endc
     389 004150 020502                  	cmp	r5,r2			; compare expected:received
     390 004152 001431                  	beq	23$			; br if matches
     391                                
     392 004154 010446                  	mov	r4,-(sp)		; virtual address of error
     393 004156 162716  000002          	sub	#2,(sp)			; backup
     394 004162                         	call	adrxlt			; translate to physical
       1 004162 004737  010214          	jsr	pc,adrxlt
     395 004166                         	printf	#71$,testno,phyadr+0,phyadr+2,r5,r2 ; format, test, addrhi/lo, exp, rcv
       1 004166                         	calls	printf #71$ testno phyadr+0 phyadr+2 r5 r2          
       9 004166 010246                  	mov	r2,-(sp)
      15 004170 010546                  	mov	r5,-(sp)
      21 004172 013746  002046          	mov	phyadr+2,-(sp)
      27 004176 013746  002044          	mov	phyadr+0,-(sp)
      33 004202 013746  002042          	mov	testno,-(sp)
      39 004206 012746  004327          	mov	#71$,-(sp)
       2 004212                         	call	printf
       1 004212 004737  011020          	jsr	pc,printf
       3 004216 062706  000014          	add	#14,sp
     396                                
     397 004222 005237  002036          22$:	inc	errors			; count errors
     398 004226 001775                  	beq	22$			;
     399 004230 053705  002024          	bis	blmsk,r5		; bump to last block...
     400 004234 000401                  	br	24$			; exit early...
     401                                
     402 004236 077335                  23$:	sob	r3,21$			; loop for block size
     403                                
     404 004240 005205                  24$:	inc	r5			; incr test block
     405 004242 020537  002022          	cmp	r5,blend		; at the end?
     406 004246 101726                  	blos	20$			; br if more to do
     407                                
     408 004250                         	call	enbecc			; check for errors, reenable ecc
       1 004250 004737  010452          	jsr	pc,enbecc
     409                                
     410 004254 000505                  	br	99$			; next test
     411                                
     412 004256    015     012     124  70$:	.asciz	<cr><lf>"Test%d: unique physical block select"<cr><lf>
         004261    145     163     164  
         004264    045     144     072  
         004267    040     165     156  
         004272    151     161     165  
         004275    145     040     160  
         004300    150     171     163  
         004303    151     143     141  
         004306    154     040     142  
         004311    154     157     143  
         004314    153     040     163  
         004317    145     154     145  
         004322    143     164     015  
         004325    012     000          
     413 004327    124     145     163  71$:	.ascii	"Test%d: unique physical block select failure"<cr><lf>
         004332    164     045     144  
         004335    072     040     165  
         004340    156     151     161  
         004343    165     145     040  
         004346    160     150     171  
         004351    163     151     143  
         004354    141     154     040  
         004357    142     154     157  
         004362    143     153     040  
         004365    163     145     154  
         004370    145     143     164  
         004373    040     146     141  
         004376    151     154     165  
         004401    162     145     015  
         004404    012                  
     414 004405    040     040     120  	.ascii	"  PhysAddr  Exp'ed  Rcv'ed"<cr><lf>
         004410    150     171     163  
         004413    101     144     144  
         004416    162     040     040  
         004421    105     170     160  
         004424    047     145     144  
         004427    040     040     122  
         004432    143     166     047  
         004435    145     144     015  
         004440    012                  
     415 004441    040     040     045  	.asciz	"  %.8lp  %.6o  %.6o"<cr><lf>
         004444    056     070     154  
         004447    160     040     040  
         004452    045     056     066  
         004455    157     040     040  
         004460    045     056     066  
         004463    157     015     012  
         004466    000                  
     416 004467    000                  	.even
     417                                
     418 004470 005237  002042          99$:	inc	testno			; count tests
     419                                
     420                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     421                                
     422 004474                         	test	<unique physical block address test>
       2                                
       3                                	;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       4                                	.sbttl	Test3 - unique physical block address test
       5                                	;------------------------------------------------------------
       6                                
       7                                test3:	; start of test
       8                                
       9 004474 022737  000003  002042  	cmp	#3,testno		; check for sequence error
      10 004502 001401                  	beq	.+4			; OK, skip over halt
      11 004504 000000                  	halt				; FATAL - SEQUENCE ERROR
     423                                
     424 004506                         	printf	#70$,testno		; header message
       1 004506                         	calls	printf #70$ testno              
       9 004506 013746  002042          	mov	testno,-(sp)
      15 004512 012746  004724          	mov	#70$,-(sp)
       2 004516                         	call	printf
       1 004516 004737  011020          	jsr	pc,printf
       3 004522 062706  000004          	add	#4,sp
     425                                
     426 004526                         	call	disecc			; disable ecc
       1 004526 004737  010370          	jsr	pc,disecc
     427                                
     428                                	; iterate over all memory blocks
     429                                
     430 004532 013705  002020          	mov	blbeg,r5		; starting block number
     431 004536                         10$:	call	adrtst			; check ok to test this block
       1 004536 004737  010344          	jsr	pc,adrtst
     432 004542 103061                  	bcc	34$			; br if not
     433 004544 010537  172354          	mov	r5,@#tstpar		; point mmu at test block
     434                                
     435                                	; fill each word in the block with a unique pattern
     436                                
     437 004550 012704  140000          	mov	#tstmin,r4		; start block address
     438 004554 012703  000040          	mov	#tstwc,r3		; this many words
     439 004560 110324                  20$:	movb	r3,(r4)+		; fill low byte with count
     440 004562 005103                  	com	r3			; invert
     441 004564 110324                  	movb	r3,(r4)+		; fill low byte with ~count
     442 004566 005103                  	com	r3			; invert
     443 004570 077305                  	sob	r3,20$			; loop for block size
     444                                
     445                                	; now check the pattern is the same
     446                                
     447 004572 012704  140000          	mov	#tstmin,r4		; start block address
     448 004576 012703  000040          	mov	#tstwc,r3		; this many words
     449 004602 012402                  30$:	mov	(r4)+,r2		; get test data
     450 004604 005001                  	clr	r1			;    0|0
     451 004606 150301                  	bisb	r3,r1			;    0|cnt
     452 004610 105101                  	comb	r1			;    0|~cnt
     453 004612 000301                  	swab	r1			; ~cnt|0
     454 004614 150301                  	bisb	r3,r1			; ~cnt|cnt
     455        000000                  .if ne fails
     456                                	cmp	#1,passes		; only fail on pass2
     457                                	bne	66$			; br if OK
     458                                	cmp	r4,#tstmin+36+2		; fail offset
     459                                	bne	66$			; br if not
     460                                	cmp	r5,#000123		; first fail block
     461                                	bne	66$			; br if not
     462                                	com	r2			; yes, fudge data
     463                                66$:	nop				; placeholder
     464                                .endc
     465 004616 020102                  	cmp	r1,r2			; check matches
     466 004620 001431                  	beq	32$			; br if OK
     467                                
     468 004622 010446                  	mov	r4,-(sp)		; virtual address of error
     469 004624 162716  000002          	sub	#2,(sp)			; backup
     470 004630                         	call	adrxlt			; translate to physical
       1 004630 004737  010214          	jsr	pc,adrxlt
     471 004634                         	printf	#71$,testno,phyadr+0,phyadr+2,r1,r2 ; format, test, addrhi/lo, exp, rcv
       1 004634                         	calls	printf #71$ testno phyadr+0 phyadr+2 r1 r2          
       9 004634 010246                  	mov	r2,-(sp)
      15 004636 010146                  	mov	r1,-(sp)
      21 004640 013746  002046          	mov	phyadr+2,-(sp)
      27 004644 013746  002044          	mov	phyadr+0,-(sp)
      33 004650 013746  002042          	mov	testno,-(sp)
      39 004654 012746  004776          	mov	#71$,-(sp)
       2 004660                         	call	printf
       1 004660 004737  011020          	jsr	pc,printf
       3 004664 062706  000014          	add	#14,sp
     472                                
     473 004670 005237  002036          31$:	inc	errors			; count errors
     474 004674 001775                  	beq	31$			;
     475 004676 053705  002024          	bis	blmsk,r5		; bump to last block...
     476 004702 000401                  	br	34$			; exit early...
     477                                
     478 004704 077342                  32$:	sob	r3,30$			; loop for block size
     479                                
     480 004706 005205                  34$:	inc	r5			; incr test block
     481 004710 020537  002022          	cmp	r5,blend		; at the end?
     482 004714 101710                  	blos	10$			; br if more to do
     483                                
     484 004716                         	call	enbecc			; check for errors, reenable ecc
       1 004716 004737  010452          	jsr	pc,enbecc
     485                                
     486 004722 000506                  	br	99$			; next test
     487                                
     488 004724    015     012     124  70$:	.asciz	<cr><lf>"Test%d: unique physical block address"<cr><lf>
         004727    145     163     164  
         004732    045     144     072  
         004735    040     165     156  
         004740    151     161     165  
         004743    145     040     160  
         004746    150     171     163  
         004751    151     143     141  
         004754    154     040     142  
         004757    154     157     143  
         004762    153     040     141  
         004765    144     144     162  
         004770    145     163     163  
         004773    015     012     000  
     489 004776    124     145     163  71$:	.ascii	"Test%d: unique physical block address failure"<cr><lf>
         005001    164     045     144  
         005004    072     040     165  
         005007    156     151     161  
         005012    165     145     040  
         005015    160     150     171  
         005020    163     151     143  
         005023    141     154     040  
         005026    142     154     157  
         005031    143     153     040  
         005034    141     144     144  
         005037    162     145     163  
         005042    163     040     146  
         005045    141     151     154  
         005050    165     162     145  
         005053    015     012          
     490 005055    040     040     120  	.ascii	"  PhysAddr  Exp'ed  Rcv'ed"<cr><lf>
         005060    150     171     163  
         005063    101     144     144  
         005066    162     040     040  
         005071    105     170     160  
         005074    047     145     144  
         005077    040     040     122  
         005102    143     166     047  
         005105    145     144     015  
         005110    012                  
     491 005111    040     040     045  	.asciz	"  %.8lp  %.6o  %.6o"<cr><lf>
         005114    056     070     154  
         005117    160     040     040  
         005122    045     056     066  
         005125    157     040     040  
         005130    045     056     066  
         005133    157     015     012  
         005136    000                  
     492 005137    000                  	.even
     493                                
     494 005140 005237  002042          99$:	inc	testno			; count tests
     495                                
     496                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     497                                
     498 005144                         	test	<extended march c- data test>
       2                                
       3                                	;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       4                                	.sbttl	Test4 - extended march c- data test
       5                                	;------------------------------------------------------------
       6                                
       7                                test4:	; start of test
       8                                
       9 005144 022737  000004  002042  	cmp	#4,testno		; check for sequence error
      10 005152 001401                  	beq	.+4			; OK, skip over halt
      11 005154 000000                  	halt				; FATAL - SEQUENCE ERROR
     499                                
     500 005156                         	printf	#70$,testno		; header message
       1 005156                         	calls	printf #70$ testno              
       9 005156 013746  002042          	mov	testno,-(sp)
      15 005162 012746  006340          	mov	#70$,-(sp)
       2 005166                         	call	printf
       1 005166 004737  011020          	jsr	pc,printf
       3 005172 062706  000004          	add	#4,sp
     501                                
     502 005176                         	call	disecc			; disable ecc
       1 005176 004737  010370          	jsr	pc,disecc
     503                                
     504                                	; extended march c- data test:
     505                                	;
     506                                	;   ud(w0); u(r0,w1,r1); u(r1,w0); d(r0,w1); d(r1,w0); ud(r0)
     507                                
     508                                	; a: ud(w0) - address ascending (or descending) write zero
     509                                
     510 005202                         	printf	#71$,testno		; subheader
       1 005202                         	calls	printf #71$ testno              
       9 005202 013746  002042          	mov	testno,-(sp)
      15 005206 012746  006410          	mov	#71$,-(sp)
       2 005212                         	call	printf
       1 005212 004737  011020          	jsr	pc,printf
       3 005216 062706  000004          	add	#4,sp
     511 005222 013705  002020          	mov	blbeg,r5		; starting block number
     512 005226                         100$:	call	adrtst			; check ok to test this block
       1 005226 004737  010344          	jsr	pc,adrtst
     513 005232 103010                  	bcc	109$			; br if not
     514 005234 010537  172354          	mov	r5,@#tstpar		; point mmu at test block
     515 005240 012704  140000          	mov	#tstmin,r4		; start block address
     516 005244 012703  000040          	mov	#tstwc,r3		; this many words
     517 005250 005024                  101$:	clr	(r4)+			; write zero
     518 005252 077302                  	sob	r3,101$			; loop for block size
     519 005254 005205                  109$:	inc	r5			; incr test block
     520 005256 020537  002022          	cmp	r5,blend		; at the end?
     521 005262 101761                  	blos	100$			; br if more to do
     522                                
     523                                	; b: u(r0,w1,r1) - address ascending read zero, write one, read one
     524                                
     525 005264                         	printf	#72$,testno		; subheader
       1 005264                         	calls	printf #72$ testno              
       9 005264 013746  002042          	mov	testno,-(sp)
      15 005270 012746  006471          	mov	#72$,-(sp)
       2 005274                         	call	printf
       1 005274 004737  011020          	jsr	pc,printf
       3 005300 062706  000004          	add	#4,sp
     526 005304 013705  002020          	mov	blbeg,r5		; starting block number
     527 005310                         110$:	call	adrtst			; check ok to test this block
       1 005310 004737  010344          	jsr	pc,adrtst
     528 005314 103075                  	bcc	119$			; br if not
     529 005316 010537  172354          	mov	r5,@#tstpar		; point mmu at test block
     530 005322 012704  140000          	mov	#tstmin,r4		; start block address
     531 005326 012703  000040          	mov	#tstwc,r3		; this many words
     532 005332 012702  177777          	mov	#-1,r2			; write data
     533 005336 011400                  111$:	mov	(r4),r0			; read zero
     534 005340 010214                  	mov	r2,(r4)			; write one
     535 005342 012401                  	mov	(r4)+,r1		; read one
     536 005344 005700                  	tst	r0			; check zero
     537 005346 001426                  	beq	112$			; br if OK
     538 005350 010446                  	mov	r4,-(sp)		; virtual address of error
     539 005352 162716  000002          	sub	#2,(sp)			; backup
     540 005356                         	call	adrxlt			; translate to physical
       1 005356 004737  010214          	jsr	pc,adrxlt
     541 005362                         	printf	#77$,testno,#'b,phyadr+0,phyadr+2,#0,r0 ; format, test, subtest, addrhi/lo, exp, rcv
       1 005362                         	calls	printf #77$ testno #'b phyadr+0 phyadr+2 #0 r0         
       9 005362 010046                  	mov	r0,-(sp)
      15 005364 012746  000000          	mov	#0,-(sp)
      21 005370 013746  002046          	mov	phyadr+2,-(sp)
      27 005374 013746  002044          	mov	phyadr+0,-(sp)
      33 005400 012746  000142          	mov	#'b,-(sp)
      39 005404 013746  002042          	mov	testno,-(sp)
      45 005410 012746  007161          	mov	#77$,-(sp)
       2 005414                         	call	printf
       1 005414 004737  011020          	jsr	pc,printf
       3 005420 062706  000016          	add	#16,sp
     542 005424 005101                  112$:	com	r1			; check one
     543 005426 001427                  	beq	113$			; br if OK
     544 005430 005101                  	com	r1			; restore r1
     545 005432 010446                  	mov	r4,-(sp)		; virtual address of error
     546 005434 162716  000002          	sub	#2,(sp)			; backup
     547 005440                         	call	adrxlt			; translate to physical
       1 005440 004737  010214          	jsr	pc,adrxlt
     548 005444                         	printf	#77$,testno,#'b,phyadr+0,phyadr+2,#-1,r1 ; format, test, subtest, addrhi/lo, exp, rcv
       1 005444                         	calls	printf #77$ testno #'b phyadr+0 phyadr+2 #-1 r1         
       9 005444 010146                  	mov	r1,-(sp)
      15 005446 012746  177777          	mov	#-1,-(sp)
      21 005452 013746  002046          	mov	phyadr+2,-(sp)
      27 005456 013746  002044          	mov	phyadr+0,-(sp)
      33 005462 012746  000142          	mov	#'b,-(sp)
      39 005466 013746  002042          	mov	testno,-(sp)
      45 005472 012746  007161          	mov	#77$,-(sp)
       2 005476                         	call	printf
       1 005476 004737  011020          	jsr	pc,printf
       3 005502 062706  000016          	add	#16,sp
     549 005506 077365                  113$:	sob	r3,111$			; loop for block size
     550 005510 005205                  119$:	inc	r5			; incr test block
     551 005512 020537  002022          	cmp	r5,blend		; at the end?
     552 005516 101674                  	blos	110$			; br if more to do
     553                                
     554                                	; c: u(r1,w0) - address ascending read one, write zero
     555                                
     556 005520                         	printf	#73$,testno		; subheader
       1 005520                         	calls	printf #73$ testno              
       9 005520 013746  002042          	mov	testno,-(sp)
      15 005524 012746  006604          	mov	#73$,-(sp)
       2 005530                         	call	printf
       1 005530 004737  011020          	jsr	pc,printf
       3 005534 062706  000004          	add	#4,sp
     557 005540 013705  002020          	mov	blbeg,r5		; starting block number
     558 005544                         120$:	call	adrtst			; check ok to test this block
       1 005544 004737  010344          	jsr	pc,adrtst
     559 005550 103042                  	bcc	129$			; br if not
     560 005552 010537  172354          	mov	r5,@#tstpar		; point mmu at test block
     561 005556 012704  140000          	mov	#tstmin,r4		; start block address
     562 005562 012703  000040          	mov	#tstwc,r3		; this many words
     563 005566 011400                  121$:	mov	(r4),r0			; read one
     564 005570 005024                  	clr	(r4)+			; write zero
     565        000000                  .if ne fails
     566                                	cmp	#1,passes		; only fail on pass2
     567                                	bne	67$			; br if OK
     568                                	cmp	r4,#tstmin+16+2		; fail offset
     569                                	bne	67$			; br if not
     570                                	cmp	r5,#001234		; first fail block
     571                                	bne	67$			; br if not
     572                                	dec	r0			; yes, fudge data
     573                                67$:	nop				; placeholder
     574                                .endc
     575 005572 005100                  	com	r0			; zero -> one
     576 005574 001427                  	beq	122$			; br if OK
     577 005576 005100                  	com	r0			; restore r0
     578 005600 010446                  	mov	r4,-(sp)		; virtual address of error
     579 005602 162716  000002          	sub	#2,(sp)			; backup
     580 005606                         	call	adrxlt			; translate to physical
       1 005606 004737  010214          	jsr	pc,adrxlt
     581 005612                         	printf	#77$,testno,#'c,phyadr+0,phyadr+2,#-1,r0 ; format, test, subtest, addrhi/lo, exp, rcv
       1 005612                         	calls	printf #77$ testno #'c phyadr+0 phyadr+2 #-1 r0         
       9 005612 010046                  	mov	r0,-(sp)
      15 005614 012746  177777          	mov	#-1,-(sp)
      21 005620 013746  002046          	mov	phyadr+2,-(sp)
      27 005624 013746  002044          	mov	phyadr+0,-(sp)
      33 005630 012746  000143          	mov	#'c,-(sp)
      39 005634 013746  002042          	mov	testno,-(sp)
      45 005640 012746  007161          	mov	#77$,-(sp)
       2 005644                         	call	printf
       1 005644 004737  011020          	jsr	pc,printf
       3 005650 062706  000016          	add	#16,sp
     582 005654 077334                  122$:	sob	r3,121$			; loop for block size
     583 005656 005205                  129$:	inc	r5			; incr test block
     584 005660 020537  002022          	cmp	r5,blend		; at the end?
     585 005664 101727                  	blos	120$			; br if more to do
     586                                
     587                                	; d: d(r0,w1) - address descending read zero, write one
     588                                
     589 005666                         	printf	#74$,testno		; subheader
       1 005666                         	calls	printf #74$ testno              
       9 005666 013746  002042          	mov	testno,-(sp)
      15 005672 012746  006702          	mov	#74$,-(sp)
       2 005676                         	call	printf
       1 005676 004737  011020          	jsr	pc,printf
       3 005702 062706  000004          	add	#4,sp
     590 005706 013705  002022          	mov	blend,r5		; ending block number
     591 005712                         130$:	call	adrtst			; check ok to test this block
       1 005712 004737  010344          	jsr	pc,adrtst
     592 005716 103041                  	bcc	139$			; br if not
     593 005720 010537  172354          	mov	r5,@#tstpar		; point mmu at test block
     594 005724 012704  140100          	mov	#tstmax+1,r4		; end block address
     595 005730 012703  000040          	mov	#tstwc,r3		; this many words
     596 005734 012702  177777          	mov	#-1,r2			; write data
     597 005740 014400                  131$:	mov	-(r4),r0		; read zero
     598 005742 010214                  	mov	r2,(r4)			; write one
     599        000000                  .if ne fails
     600                                	cmp	#1,passes		; only fail on pass2
     601                                	bne	66$			; br if OK
     602                                	cmp	r4,#tstmin+26+2		; fail offset
     603                                	bne	66$			; br if not
     604                                	cmp	r5,#012345		; first fail block
     605                                	bne	66$			; br if not
     606                                	inc	r0			; yes, fudge data
     607                                66$:	nop				; placeholder
     608                                .endc
     609 005744 005700                  	tst	r0			; check zero
     610 005746 001424                  	beq	132$			; br if OK
     611 005750 010446                  	mov	r4,-(sp)		; virtual address of error
     612 005752                         	call	adrxlt			; translate to physical
       1 005752 004737  010214          	jsr	pc,adrxlt
     613 005756                         	printf	#77$,testno,#'d,phyadr+0,phyadr+2,#0,r0 ; format, test, subtest, addrhi/lo, exp, rcv
       1 005756                         	calls	printf #77$ testno #'d phyadr+0 phyadr+2 #0 r0         
       9 005756 010046                  	mov	r0,-(sp)
      15 005760 012746  000000          	mov	#0,-(sp)
      21 005764 013746  002046          	mov	phyadr+2,-(sp)
      27 005770 013746  002044          	mov	phyadr+0,-(sp)
      33 005774 012746  000144          	mov	#'d,-(sp)
      39 006000 013746  002042          	mov	testno,-(sp)
      45 006004 012746  007161          	mov	#77$,-(sp)
       2 006010                         	call	printf
       1 006010 004737  011020          	jsr	pc,printf
       3 006014 062706  000016          	add	#16,sp
     614 006020 077331                  132$:	sob	r3,131$			; loop for block size
     615 006022 005305                  139$:	dec	r5			; incr test block
     616 006024 020537  002020          	cmp	r5,blbeg		; at the begin
     617 006030 101330                  	bhi	130$			; br if more to do
     618                                
     619                                	; e: d(r1,w0) - address descending read one, write zero
     620                                
     621 006032                         	printf	#75$,testno		; subheader
       1 006032                         	calls	printf #75$ testno              
       9 006032 013746  002042          	mov	testno,-(sp)
      15 006036 012746  007001          	mov	#75$,-(sp)
       2 006042                         	call	printf
       1 006042 004737  011020          	jsr	pc,printf
       3 006046 062706  000004          	add	#4,sp
     622 006052 013705  002022          	mov	blend,r5		; ending block number
     623 006056                         140$:	call	adrtst			; check ok to test this block
       1 006056 004737  010344          	jsr	pc,adrtst
     624 006062 103040                  	bcc	149$			; br if not
     625 006064 010537  172354          	mov	r5,@#tstpar		; point mmu at test block
     626 006070 012704  140100          	mov	#tstmax+1,r4		; end block address
     627 006074 012703  000040          	mov	#tstwc,r3		; this many words
     628 006100 014400                  141$:	mov	-(r4),r0		; read one
     629 006102 005014                  	clr	(r4)			; write zero
     630 006104 005100                  	com	r0			; one -> zero
     631 006106 001425                  	beq	142$			; br if OK
     632 006110 005100                  	com	r0			; restore r0
     633 006112 010446                  	mov	r4,-(sp)		; virtual address of error
     634 006114                         	call	adrxlt			; translate to physical
       1 006114 004737  010214          	jsr	pc,adrxlt
     635 006120                         	printf	#77$,testno,#'e,phyadr+0,phyadr+2,#-1,r0 ; format, test, subtest, addrhi/lo, exp, rcv
       1 006120                         	calls	printf #77$ testno #'e phyadr+0 phyadr+2 #-1 r0         
       9 006120 010046                  	mov	r0,-(sp)
      15 006122 012746  177777          	mov	#-1,-(sp)
      21 006126 013746  002046          	mov	phyadr+2,-(sp)
      27 006132 013746  002044          	mov	phyadr+0,-(sp)
      33 006136 012746  000145          	mov	#'e,-(sp)
      39 006142 013746  002042          	mov	testno,-(sp)
      45 006146 012746  007161          	mov	#77$,-(sp)
       2 006152                         	call	printf
       1 006152 004737  011020          	jsr	pc,printf
       3 006156 062706  000016          	add	#16,sp
     636 006162 077332                  142$:	sob	r3,141$			; loop for block size
     637 006164 005305                  149$:	dec	r5			; incr test block
     638 006166 020537  002020          	cmp	r5,blbeg		; at the begin
     639 006172 101331                  	bhi	140$			; br if more to do
     640                                
     641                                	; f: ud(r0) - address descending (or ascending) read zero
     642                                
     643 006174                         	printf	#76$,testno		; subheader
       1 006174                         	calls	printf #76$ testno              
       9 006174 013746  002042          	mov	testno,-(sp)
      15 006200 012746  007100          	mov	#76$,-(sp)
       2 006204                         	call	printf
       1 006204 004737  011020          	jsr	pc,printf
       3 006210 062706  000004          	add	#4,sp
     644 006214 013705  002022          	mov	blend,r5		; ending block number
     645 006220                         150$:	call	adrtst			; check ok to test this block
       1 006220 004737  010344          	jsr	pc,adrtst
     646 006224 103035                  	bcc	159$			; br if not
     647 006226 010537  172354          	mov	r5,@#tstpar		; point mmu at test block
     648 006232 012704  140100          	mov	#tstmax+1,r4		; end block address
     649 006236 012703  000040          	mov	#tstwc,r3		; this many words
     650 006242 014400                  151$:	mov	-(r4),r0		; read zero
     651 006244 001424                  	beq	152$			; br if OK
     652 006246 010446                  	mov	r4,-(sp)		; virtual address of error
     653 006250                         	call	adrxlt			; translate to physical
       1 006250 004737  010214          	jsr	pc,adrxlt
     654 006254                         	printf	#77$,testno,#'f,phyadr+0,phyadr+2,#0,r0 ; format, test, subtest, addrhi/lo, exp, rcv
       1 006254                         	calls	printf #77$ testno #'f phyadr+0 phyadr+2 #0 r0         
       9 006254 010046                  	mov	r0,-(sp)
      15 006256 012746  000000          	mov	#0,-(sp)
      21 006262 013746  002046          	mov	phyadr+2,-(sp)
      27 006266 013746  002044          	mov	phyadr+0,-(sp)
      33 006272 012746  000146          	mov	#'f,-(sp)
      39 006276 013746  002042          	mov	testno,-(sp)
      45 006302 012746  007161          	mov	#77$,-(sp)
       2 006306                         	call	printf
       1 006306 004737  011020          	jsr	pc,printf
       3 006312 062706  000016          	add	#16,sp
     655 006316 077327                  152$:	sob	r3,151$			; loop for block size
     656 006320 005305                  159$:	dec	r5			; incr test block
     657 006322 020537  002020          	cmp	r5,blbeg		; at the begin
     658 006326 101334                  	bhi	150$			; br if more to do
     659                                
     660                                	; done
     661                                
     662 006330                         	call	enbecc			; check for errors, reenable ecc
       1 006330 004737  010452          	jsr	pc,enbecc
     663                                
     664 006334 000137  007326          	jmp	99$			; next test
     665                                
     666 006340    015     012     124  70$:	.asciz	<cr><lf>"Test%d: extended march c- data test"<cr><lf>
         006343    145     163     164  
         006346    045     144     072  
         006351    040     145     170  
         006354    164     145     156  
         006357    144     145     144  
         006362    040     155     141  
         006365    162     143     150  
         006370    040     143     055  
         006373    040     144     141  
         006376    164     141     040  
         006401    164     145     163  
         006404    164     015     012  
         006407    000                  
     667 006410    124     145     163  71$:	.asciz	"Test%da: u(w0) - address ascending; write zero"<cr><lf>
         006413    164     045     144  
         006416    141     072     040  
         006421    165     050     167  
         006424    060     051     040  
         006427    055     040     141  
         006432    144     144     162  
         006435    145     163     163  
         006440    040     141     163  
         006443    143     145     156  
         006446    144     151     156  
         006451    147     073     040  
         006454    167     162     151  
         006457    164     145     040  
         006462    172     145     162  
         006465    157     015     012  
         006470    000                  
     668 006471    124     145     163  72$:	.asciz	"Test%db: u(r0,w1,r1) - address ascending; read zero, write one, read one"<cr><lf>
         006474    164     045     144  
         006477    142     072     040  
         006502    165     050     162  
         006505    060     054     167  
         006510    061     054     162  
         006513    061     051     040  
         006516    055     040     141  
         006521    144     144     162  
         006524    145     163     163  
         006527    040     141     163  
         006532    143     145     156  
         006535    144     151     156  
         006540    147     073     040  
         006543    162     145     141  
         006546    144     040     172  
         006551    145     162     157  
         006554    054     040     167  
         006557    162     151     164  
         006562    145     040     157  
         006565    156     145     054  
         006570    040     162     145  
         006573    141     144     040  
         006576    157     156     145  
         006601    015     012     000  
     669 006604    124     145     163  73$:	.asciz	"Test%dc: u(r1,w0) - address ascending; read one, write zero"<cr><lf>
         006607    164     045     144  
         006612    143     072     040  
         006615    165     050     162  
         006620    061     054     167  
         006623    060     051     040  
         006626    055     040     141  
         006631    144     144     162  
         006634    145     163     163  
         006637    040     141     163  
         006642    143     145     156  
         006645    144     151     156  
         006650    147     073     040  
         006653    162     145     141  
         006656    144     040     157  
         006661    156     145     054  
         006664    040     167     162  
         006667    151     164     145  
         006672    040     172     145  
         006675    162     157     015  
         006700    012     000          
     670 006702    124     145     163  74$:	.asciz	"Test%dd: d(r0,w1) - address descending; read zero, write one"<cr><lf>
         006705    164     045     144  
         006710    144     072     040  
         006713    144     050     162  
         006716    060     054     167  
         006721    061     051     040  
         006724    055     040     141  
         006727    144     144     162  
         006732    145     163     163  
         006735    040     144     145  
         006740    163     143     145  
         006743    156     144     151  
         006746    156     147     073  
         006751    040     162     145  
         006754    141     144     040  
         006757    172     145     162  
         006762    157     054     040  
         006765    167     162     151  
         006770    164     145     040  
         006773    157     156     145  
         006776    015     012     000  
     671 007001    124     145     163  75$:	.asciz	"Test%de: d(r1,w0) - address descending; read one, write zero"<cr><lf>
         007004    164     045     144  
         007007    145     072     040  
         007012    144     050     162  
         007015    061     054     167  
         007020    060     051     040  
         007023    055     040     141  
         007026    144     144     162  
         007031    145     163     163  
         007034    040     144     145  
         007037    163     143     145  
         007042    156     144     151  
         007045    156     147     073  
         007050    040     162     145  
         007053    141     144     040  
         007056    157     156     145  
         007061    054     040     167  
         007064    162     151     164  
         007067    145     040     172  
         007072    145     162     157  
         007075    015     012     000  
     672 007100    124     145     163  76$:	.asciz	"Test%df: d(r0) - address descending; read zero"<cr><lf>
         007103    164     045     144  
         007106    146     072     040  
         007111    144     050     162  
         007114    060     051     040  
         007117    055     040     141  
         007122    144     144     162  
         007125    145     163     163  
         007130    040     144     145  
         007133    163     143     145  
         007136    156     144     151  
         007141    156     147     073  
         007144    040     162     145  
         007147    141     144     040  
         007152    172     145     162  
         007155    157     015     012  
         007160    000                  
     673 007161    124     145     163  77$:	.ascii	"Test%d%c: extended march c- data compare failure"<cr><lf>
         007164    164     045     144  
         007167    045     143     072  
         007172    040     145     170  
         007175    164     145     156  
         007200    144     145     144  
         007203    040     155     141  
         007206    162     143     150  
         007211    040     143     055  
         007214    040     144     141  
         007217    164     141     040  
         007222    143     157     155  
         007225    160     141     162  
         007230    145     040     146  
         007233    141     151     154  
         007236    165     162     145  
         007241    015     012          
     674 007243    040     040     120  	.ascii	"  PhysAddr  Exp'ed  Rcv'ed"<cr><lf>
         007246    150     171     163  
         007251    101     144     144  
         007254    162     040     040  
         007257    105     170     160  
         007262    047     145     144  
         007265    040     040     122  
         007270    143     166     047  
         007273    145     144     015  
         007276    012                  
     675 007277    040     040     045  	.asciz	"  %.8lp  %.6o  %.6o"<cr><lf>
         007302    056     070     154  
         007305    160     040     040  
         007310    045     056     066  
         007313    157     040     040  
         007316    045     056     066  
         007321    157     015     012  
         007324    000                  
     676 007325    000                  	.even
     677                                
     678 007326 005237  002042          99$:	inc	testno			; count tests
     679                                
     680                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     681                                
     682                                .sbttl	print end of pass message
     683                                
     684 007332 005237  002040          	inc	passes			; count passes
     685 007336                         	printf	#msg3,passes,errors	; format, passcount, errcount
       1 007336                         	calls	printf #msg3 passes errors             
       9 007336 013746  002036          	mov	errors,-(sp)
      15 007342 013746  002040          	mov	passes,-(sp)
      21 007346 012746  010031          	mov	#msg3,-(sp)
       2 007352                         	call	printf
       1 007352 004737  011020          	jsr	pc,printf
       3 007356 062706  000006          	add	#6,sp
     686                                
     687                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     688                                
     689                                .sbttl	relocate program for next pass
     690                                
     691 007362 013700  002040          mreloc:	mov	 passes,r0		; get current pass number (0...)
     692 007366 005200                  	inc	 r0			; passcnt+1
     693 007370 042700  177777          	bic	 #^c0,r0		; do modulo 2 remainder (relocate every pass)
     694 007374 001135                  	bne	 99$			; don't do any relocation
     695                                
     696                                	; copy current program image space to relocated space
     697                                
     698 007376 012701  001000          	mov	#pgprgn*pgszbl,r1	; number of blocks to move (power of two)
     699 007402 074137  002026          	xor	r1,protmn		; new dest prot range low
     700 007406 074137  002030          	xor	r1,protmx		; new dest prot range high
     701                                
     702 007412 012701  001000          1$:	mov	#pgprgn*pgszbl,r1	; number of blocks to move (power of two)
     703 007416 013737  002026  172354  	mov	protmn,@#tstpar		; starting dest block address
     704 007424 005002                  	clr	r2			; starting source address
     705 007426 012703  000040          10$:	mov	#blszby/2,r3		; number of words to move
     706 007432 012704  140000          	mov	#tstmin,r4		; dest address
     707 007436 012224                  11$:	mov	(r2)+,(r4)+		; copy a word
     708 007440 077302                  	sob	r3,11$			; loop over a block
     709 007442 005237  172354          	inc	@#tstpar		; bump to next block
     710 007446 077111                  	sob	r1,10$			; loop over all blocks
     711                                
     712                                	; compare current program image space to relocated space
     713                                
     714 007450 012701  001000          	mov	#pgprgn*pgszbl,r1	; number of blocks to move (power of two)
     715 007454 013737  002026  172354  	mov	protmn,@#tstpar		; starting dest block address
     716 007462 005002                  	clr	r2			; starting source address
     717 007464 012703  000040          20$:	mov	#blszby/2,r3		; number of words to move
     718 007470 012704  140000          	mov	#tstmin,r4		; dest address
     719 007474 022224                  21$:	cmp	(r2)+,(r4)+		; copy a word
     720 007476 001345                  	bne	1$			; WHOOPS, error in copy, retry
     721 007500 077303                  	sob	r3,21$			; loop over a block
     722 007502 005237  172354          	inc	@#tstpar		; bump to next block
     723 007506 077112                  	sob	r1,20$			; loop over all blocks
     724                                
     725                                	; now relocate program via swapping KPARx contents
     726                                
     727 007510 012701  001000          	mov	#pgprgn*pgszbl,r1	; number of blocks to move (power of two)
     728 007514 012702  172340          	mov	#kpar+<2*pgprg>,r2	; ptr to first base register
     729 007520 012703  000004          	mov	#pgprgn,r3		; number of program pages
     730 007524 074122                  30$:	xor	r1,(r2)+		; swap address in KPAR[n]
     731 007526 077302                  	sob	r3,30$			; loop over all pages
     732                                
     733                                	; if we got here, it worked ok ... print a message
     734                                
     735 007530 013701  002026          	mov	protmn,r1		; address min low
     736 007534 005000                  	clr	r0			; zap high
     737 007536 073027  000006          	ashc	#6,r0			; shift left 6
     738                                
     739 007542 013703  002030          	mov	protmx,r3		; address max low
     740 007546 005002                  	clr	r2			; zap high
     741 007550 073227  000006          	ashc	#6,r2			; shift left 6
     742 007554 052703  000077          	bis	#blszby-1,r3		; up thru last block number
     743                                
     744 007560                         	printf	#70$,r0,r1,r2,r3	; format, min hi, min lo, max hi, max lo
       1 007560                         	calls	printf #70$ r0 r1 r2 r3           
       9 007560 010346                  	mov	r3,-(sp)
      15 007562 010246                  	mov	r2,-(sp)
      21 007564 010146                  	mov	r1,-(sp)
      27 007566 010046                  	mov	r0,-(sp)
      33 007570 012746  007606          	mov	#70$,-(sp)
       2 007574                         	call	printf
       1 007574 004737  011020          	jsr	pc,printf
       3 007600 062706  000012          	add	#12,sp
     745                                
     746 007604 000431                  	br	99$			; next
     747                                
     748 007606    015     012     120  70$:	.asciz	<cr><lf>"Program relocated to %lp(8) - %lp(8) physical"<cr><lf>
         007611    162     157     147  
         007614    162     141     155  
         007617    040     162     145  
         007622    154     157     143  
         007625    141     164     145  
         007630    144     040     164  
         007633    157     040     045  
         007636    154     160     050  
         007641    070     051     040  
         007644    055     040     045  
         007647    154     160     050  
         007652    070     051     040  
         007655    160     150     171  
         007660    163     151     143  
         007663    141     154     015  
         007666    012     000          
     749                                	.even
     750                                
     751 007670 000240                  99$:	nop
     752                                
     753                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     754                                
     755                                .sbttl	all done - end of pass cleanup
     756                                
     757 007672 013700  002050          done:	mov	$sav42,r0		; check if loaded by XXDP
     758 007676 001407                  	beq	noxxdp			; br if not
     759 007700 000005                  	reset				; yes, reset the world
     760 007702 004710                  $endad:	jsr	pc,(r0)			; return back to XXDP
     761 007704 000240                  	nop				; standard sequence
     762 007706 000240                  	nop				;
     763 007710 000240                  	nop				;
     764 007712 000137  003134          	jmp	loop			; back for more
     765                                
     766 007716 023737  002004  002040  noxxdp:	cmp	numpas,passes		; done
     767 007724 001402                  	beq	exit			; yes
     768 007726 000137  003134          	jmp	loop			; not yet
     769                                
     770 007732                         exit:	printf	#msg2			; say goodbye
       1 007732                         	calls	printf #msg2               
       9 007732 012746  010015          	mov	#msg2,-(sp)
       2 007736                         	call	printf
       1 007736 004737  011020          	jsr	pc,printf
       3 007742 062706  000002          	add	#2,sp
     771 007746 005000                  	clr	r0			;
     772 007750 077001                  10$:	sob	r0,10$			; some delay
     773 007752 000005                  	reset				; zap the world
     774 007754 000137  165144          	jmp	@#console		; exit to console
     775                                
     776                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     777                                ; 
     778                                ; random status messages
     779                                ; 
     780 007760    015     012     015  msg1:	.asciz	<cr><lf><cr><lf>"Memory Exerciser v1.32"<cr><lf>
         007763    012     115     145  
         007766    155     157     162  
         007771    171     040     105  
         007774    170     145     162  
         007777    143     151     163  
         010002    145     162     040  
         010005    166     061     056  
         010010    063     062     015  
         010013    012     000          
     781 010015    015     012     107  msg2:	.asciz	<cr><lf>"Goodbye"<cr><lf>
         010020    157     157     144  
         010023    142     171     145  
         010026    015     012     000  
     782 010031    015     012     105  msg3:	.asciz	<cr><lf>"End pass %u. errors %u."<cr><lf>
         010034    156     144     040  
         010037    160     141     163  
         010042    163     040     045  
         010045    165     056     040  
         010050    145     162     162  
         010053    157     162     163  
         010056    040     045     165  
         010061    056     015     012  
         010064    000                  
     783 010065    015     012     104  msg4:	.asciz	<cr><lf>"Detected memory size is %dKB (%.6lp)"<cr><lf>
         010070    145     164     145  
         010073    143     164     145  
         010076    144     040     155  
         010101    145     155     157  
         010104    162     171     040  
         010107    163     151     172  
         010112    145     040     151  
         010115    163     040     045  
         010120    144     113     102  
         010123    040     050     045  
         010126    056     066     154  
         010131    160     051     015  
         010134    012     000          
     784 010136    015     012     115  msg5a:	.asciz	<cr><lf>"Memory Control registers: "
         010141    145     155     157  
         010144    162     171     040  
         010147    103     157     156  
         010152    164     162     157  
         010155    154     040     162  
         010160    145     147     151  
         010163    163     164     145  
         010166    162     163     072  
         010171    040     000          
     785 010173    040     045     056  msg5b:	.asciz	" %.6o"
         010176    066     157     000  
     786 010201    040     074     156  msg5c:	.asciz	" <none>"
         010204    157     156     145  
         010207    076     000          
     787 010211    015     012     000  crlf:	.asciz	<cr><lf>
     788                                	.even
     789                                
     790                                ; --------------------------------------------------------------------------------
     791                                ;
     792                                ; translate virtual address to physical in phyadr+0/+2
     793                                ;
     794                                ;	call:	mov	#addr,-(sp)	; virtual address, popped on return
     795                                ;		call	adrxlt
     796                                ;
     797 010214 010146                  adrxlt:	mov	r1,-(sp)		; save
     798 010216 010046                  	mov	r0,-(sp)		;
     799                                
     800 010220 016601  000006          	mov	6.(sp),r1		; default lsb
     801 010224 005000                  	clr	r0			; default msb
     802 010226 032737  000001  177572  	bit	#bit0,@#mmr0		; check if mmgt enabled
     803 010234 001420                  	beq	20$			; br if OFF
     804                                
     805 010236 073027  000003          	ashc	#3.,r0			; page number to R0<2:0>
     806 010242 006300                  	asl	r0			; R0*2, 0->C
     807 010244 016000  172340          	mov	kpar(r0),r0		; get base address of page
     808 010250 072127  177767          	ash	#-9.,r1			; block to R1<6:0>
     809 010254 060001                  	add	r0,r1			; add block to base
     810 010256 073027  000006          	ashc	#6.,r0			; base to R0/R1<21:06>
     811 010262 016646  000006          	mov	6.(sp),-(sp)		; duplicate VA<15:0>
     812 010266 042716  177700          	bic	#^c77,(sp)		; mask to DIB<5:0>
     813 010272 052601                  	bis	(sp)+,r1		; merge into PA<21:00>
     814 010274 000404                  	br	30$			; continue
     815                                
     816 010276 020127  160000          20$:	cmp	r1,#160000		; check for I/O page
     817 010302 103401                  	blo	30$			; br if not	
     818 010304 005100                  	com	r0			; yes, set bits
     819                                
     820 010306 042700  177700          30$:	bic	#^c77,r0		; mask to 22b physical
     821 010312 005737  002034          	tst	flg22b			; 22b mode ?
     822 010316 001002                  	bne	40$			; br if 22b
     823 010320 042700  177774          	bic	#^c3,r0			; mask to 18b physical
     824                                
     825 010324 010037  002044          40$:	mov	r0,phyadr+0		; store msb
     826 010330 010137  002046          	mov	r1,phyadr+2		; and lsb
     827                                
     828 010334 012600                  	mov	(sp)+,r0		; restore
     829 010336 012601                  	mov	(sp)+,r1		;
     830 010340 012616                  	mov	(sp)+,(sp)		; flush argument
     831 010342                         	return				; return
       1 010342 000207                  	rts	pc
     832                                
     833                                ; --------------------------------------------------------------------------------
     834                                ;
     835                                ; check block address valid for test
     836                                ;
     837                                ;	call:	mov	#addr,r5
     838                                ;		call	adrtst
     839                                ;		bcc	not_valid
     840                                ;		bcs	valid
     841                                ;
     842 010344 020537  002026          adrtst:	cmp	r5,protmn		; addr vs lowest
     843 010350 103405                  	blo	20$			; br if lower
     844 010352 020537  002030          	cmp	r5,protmx		; addr vs highest
     845 010356 101002                  	bhi	20$			; br if higher
     846 010360 000241                  	clc				; indicate not valid
     847 010362                         	return				; return
       1 010362 000207                  	rts	pc
     848 010364 000261                  20$:	sec				; indicate valid
     849 010366                         	return				; return
       1 010366 000207                  	rts	pc
     850                                
     851                                ; --------------------------------------------------------------------------------
     852                                ;
     853                                ; disable ecc routine
     854                                ;
     855                                ;	call:	call	disecc
     856                                ;
     857 010370 010446                  disecc:	mov	r4,-(sp)		; save registers
     858 010372 010346                  	mov	r3,-(sp)		;
     859                                
     860 010374 013704  002032          	mov	mcrmsk,r4		; bitmask of existing memory csr
     861 010400 012703  172100          	mov	#mcr0,r3		; addr of first csr
     862                                
     863 010404 005704                  10$:	tst	r4			; check any csrs left, zero to C
     864 010406 001416                  	beq	30$			; br if done
     865 010410 006004                  	ror	r4			; next csr exist?
     866 010412 103011                  	bcc	20$			; br if none
     867 010414 005013                  	clr	(r3)			; clear errors
     868 010416 032737  000001  002002  	bit	#bit0,optswi		; check if run with ecc enabled
     869 010424 001004                  	bne	20$			; br if yes
     870 010426 042713  140024          	bic	#bit15+bit14+bit4+bit2,(r3) ; clear error bit and ecc read mode
     871 010432 052713  000003          	bis	#bit1+bit0,(r3)		; disable correction, trap on error, clear flags
     872 010436 062703  000002          20$:	add	#2,r3			; bump addr
     873 010442 000760                  	br	10$			; loop
     874                                
     875 010444 012603                  30$:	mov	(sp)+,r3		; restore registers
     876 010446 012604                  	mov	(sp)+,r4		;
     877 010450                         	return				; return
       1 010450 000207                  	rts	pc
     878                                
     879                                ; --------------------------------------------------------------------------------
     880                                ;
     881                                ; check errors / enable ecc routine
     882                                ;
     883                                ;	call:	call	enbecc
     884                                ;
     885 010452 010446                  enbecc:	mov	r4,-(sp)		; save registers
     886 010454 010346                  	mov	r3,-(sp)		;
     887 010456 010246                  	mov	r2,-(sp)		;
     888 010460 010146                  	mov	r1,-(sp)		;
     889 010462 010046                  	mov	r0,-(sp)		;
     890                                
     891 010464 013704  002032          	mov	mcrmsk,r4		; bitmask of existing memory csr
     892 010470 012703  172100          	mov	#mcr0,r3		; addr of first csr
     893                                
     894 010474 005704                  10$:	tst	r4			; check any csrs left, zero to C
     895 010476 001444                  	beq	30$			; br if done
     896 010500 006004                  	ror	r4			; next csr exist?
     897 010502 103037                  	bcc	20$			; br if none
     898 010504 011302                  	mov	(r3),r2			; get current csr
     899 010506 032702  100020          	bit	#bit15+bit4,r2		; check for any errors
     900 010512 001431                  	beq	19$			; br if no errors
     901                                
     902 010514 010200                  	mov	r2,r0			; memory block
     903 010516 042700  170037          	bic	#170037,r0		; isolate A<17:11>
     904 010522 052713  040000          	bis	#bit14,(r3)		; select upper EUB
     905 010526 011301                  	mov	(r3),r1			;
     906 010530 042701  170037          	bic	#170037,r1		;
     907 010534 072127  000007          	ash	#7,r1			; isolate A<21:18>
     908 010540 050100                  	bis	r1,r0			; merge
     909 010542                         	printf	#71$,r3,r0,#0,r2	; format, csr addr, memory block, expected, received
       1 010542                         	calls	printf #71$ r3 r0 #0 r2           
       9 010542 010246                  	mov	r2,-(sp)
      15 010544 012746  000000          	mov	#0,-(sp)
      21 010550 010046                  	mov	r0,-(sp)
      27 010552 010346                  	mov	r3,-(sp)
      33 010554 012746  010624          	mov	#71$,-(sp)
       2 010560                         	call	printf
       1 010560 004737  011020          	jsr	pc,printf
       3 010564 062706  000012          	add	#12,sp
     910                                
     911 010570 005237  002036          18$:	inc	errors			; count errors
     912 010574 001775                  	beq	18$			; not zero
     913                                
     914 010576 042713  157767          19$:	bic	#^c<bit13+bit3>,(r3)	; enable error correction, clear errors
     915 010602 062703  000002          20$:	add	#2,r3			; bump addr
     916 010606 000732                  	br	10$			; loop
     917                                
     918 010610 012600                  30$:	mov	(sp)+,r0		; restore registers
     919 010612 012601                  	mov	(sp)+,r1		;
     920 010614 012602                  	mov	(sp)+,r2		;
     921 010616 012603                  	mov	(sp)+,r3		;
     922 010620 012604                  	mov	(sp)+,r4		;
     923 010622                         	return				; return
       1 010622 000207                  	rts	pc
     924                                
     925 010624    115     145     155  71$:	.ascii	"Memory CSR Contents"<cr><lf>
         010627    157     162     171  
         010632    040     103     123  
         010635    122     040     103  
         010640    157     156     164  
         010643    145     156     164  
         010646    163     015     012  
     926 010651    040     040     103  	.ascii	"  CSRadr  MemBlk  Exp'ed  Rcv'ed"<cr><lf>
         010654    123     122     141  
         010657    144     162     040  
         010662    040     115     145  
         010665    155     102     154  
         010670    153     040     040  
         010673    105     170     160  
         010676    047     145     144  
         010701    040     040     122  
         010704    143     166     047  
         010707    145     144     015  
         010712    012                  
     927 010713    040     040     045  	.asciz	"  %.6o  %.6o  %.6o  %.6o"<cr><lf>
         010716    056     066     157  
         010721    040     040     045  
         010724    056     066     157  
         010727    040     040     045  
         010732    056     066     157  
         010735    040     040     045  
         010740    056     066     157  
         010743    015     012     000  
     928                                	.even
     929                                
     930                                .include "mac/adrchk.mac"
       1                                ;================================================================================
       2                                ; adrchk.mac - routine to check if a physical address exists
       3                                ; (C) 2009 Donald North. All rights reserved.
       4                                ;================================================================================
       5                                ;
       6                                ; address check routine
       7                                ;
       8                                ;	call:	mov	#addr,r0
       9                                ;		call	adrchk
      10                                ;		bcc	we_trapped
      11                                ;		bcs	no_trap
      12                                ;
      13 010746 010546                  adrchk::mov	r5,-(sp)		; save registers
      14                                
      15 010750 013746  000004          	mov	@#4,-(sp)		; save old vector
      16 010754 013746  000006          	mov	@#6,-(sp)		;
      17 010760 010605                  	mov	sp,r5			; save sp here
      18                                
      19 010762 012737  011002  000004  	mov	#1$,@#4  		; if we timeout go here
      20 010770 005037  000006          	clr	@#6			; next psw if we trap
      21                                
      22 010774 000241                  	clc				; C=0 means we trapped
      23 010776 005710                  	tst	(r0)			; test the address, may trap
      24 011000 000261                  	sec				; C=1 means no trap
      25                                
      26 011002 010506                  1$:	mov	r5,sp			; restore stack
      27 011004 012637  000006          	mov	(sp)+,@#6		; restore old vector
      28 011010 012637  000004          	mov	(sp)+,@#4		;
      29                                
      30 011014 012605                  	mov	(sp)+,r5		; restore registers
      31 011016                         	return				; done
       1 011016 000207                  	rts	pc
      32                                
      33                                ;================================================================================
      34                                ; end of adrchk.mac
      35                                ;================================================================================
      35                                
     931                                .include "mac/printf.mac"
       1                                ;================================================================================
       2                                ; printf.mac - printf routines for macro11 diagnostics
       3                                ; (C) 2009-2016 Donald North. All rights reserved.
       4                                ;================================================================================
       5                                
       6                                .if ndf ttxcsr
       7                                	
       8                                	; separate psect (if console registers not defined)
       9                                	.psect	printf
      10                                
      11                                	; external tty references
      12                                	.globl	ttxcsr, ttxbuf
      13                                
      14                                	; standard macro definitions
      15                                 	.include "mac/stddef.mac"
      16                                
      17                                pf.sep	=1 ; flag separate compilation
      18                                
      19                                .iff
      20                                
      21        000000                  pf.sep	=0 ; flag unified compilation (via include)
      22                                	
      23                                .endc
      24                                ; 
      25                                ; global registers:
      26                                ;
      27                                ;  R5 - frame pointer
      28                                ;  R4 - argument pointer
      29                                ;  R3 - format string pointer
      30                                ;  R2 - current format character
      31                                ;  R1 - temp
      32                                ;  R0 - temp
      33                                ;
      34                                ; note:	for 11/04-05-10 compatibility, do NOT use SXT/XOR/SOB and MUL/DIV/ASH/ASHC
      35                                ; 
      36                                ; offsets from frame pointer (r5):
      37                                ; 
      38        000012                  p.sr0	=+10.	; saved r0
      39        000010                  p.sr1	=+8.	; saved r1
      40        000006                  p.sr2	=+6.	; saved r2
      41        000004                  p.sr3	=+4.	; saved r3
      42        000002                  p.sr4	=+2.	; saved r4
      43        000000                  p.sr5	=+0.	; saved r5
      44        177777                  p.flg	=-1.	; format flags (byte)
      45        177776                  p.fil	=-2.	; fill character (byte)
      46        177774                  p.wid	=-4.	; format numeric width (word)
      47        177772                  p.pre	=-6.	; format numeric precision (word)
      48        177770                  p.len	=-8.	; number of digits generated (word)
      49        177766                  p.out	=-10.	; addr(char print routine)
      50        177764                  p.ptr	=-12.	; sprintf output buffer pointer
      51                                ; 
      52        000014                  n.last	=+12.	; number of bytes allocated on stack
      53        000016                  n.args	=+14.	; offset to first argument on stack
      54                                ; 
      55                                ; bits in p.flg byte:
      56                                ; 
      57        000001                  pf.ljus	=1	; set for left justified ('-' seen)
      58        000002                  pf.sign	=2	; set for sign requested ('+' seen)
      59        000004                  pf.altf	=4	; set for alt flag ('#' seen)
      60        000010                  pf.long	=10	; set for long value (%...l. seen)
      61        000020                  pf.nega	=20	; set for negative value (msb set)
      62                                
      63                                ; --------------------------------------------------------------------------------
      64                                ;
      65                                ; printf routine .. 'C' printf(format,arg1,arg2,..,argn) ..  called in 'C' style
      66                                ;
      67                                ;	call:	mov	argN,-(sp)
      68                                ;		...
      69                                ;		mov	arg2,-(sp)
      70                                ;		mov	arg1,-(sp)
      71                                ;		mov	format,-(sp)
      72                                ;		call	printf
      73                                ;		add	#2*N,sp
      74                                ;
      75 011020 010046                  printf::mov	r0,-(sp)		; save reg
      76 011022 010146                  	mov	r1,-(sp)		;
      77 011024 010246                  	mov	r2,-(sp)		;
      78 011026 010346                  	mov	r3,-(sp)		;
      79 011030 010446                  	mov	r4,-(sp)		;
      80 011032 010546                  	mov	r5,-(sp)		;
      81                                	
      82 011034 010605                  	mov	sp,r5			; frame pointer
      83 011036 162706  000014          	sub	#n.last,sp		; reserve space on stack
      84                                	
      85 011042 010504                  	mov	r5,r4			; get frame ptr
      86 011044 062704  000016          	add	#n.args,r4		; offset to first argument
      87                                	
      88 011050 012765  011064  177766  	mov	#1$,p.out(r5)		; character output routine
      89 011056 005065  177764          	clr	p.ptr(r5)		; bufptr not used here
      90                                	
      91 011062 000442                  	br	xprintf			; continue
      92                                
      93                                	; ---------------------------------------------------------
      94                                	
      95                                	; character output to console
      96                                	
      97 011064 105737  177564          1$:	tstb	@#ttxcsr		; check if ready
      98 011070 100375                  	bpl	1$			; not yet
      99 011072 110037  177566          	movb	r0,@#ttxbuf		; send character
     100 011076                         	return				; return
       1 011076 000207                  	rts	pc
     101                                	
     102                                ; --------------------------------------------------------------------------------
     103                                ;
     104                                ; sprintf routine .. 'C' sprintf(buffer,format,arg1,arg2,..,argn) ..  called in 'C' style
     105                                ;
     106                                ;	call:	mov	argN,-(sp)
     107                                ;		...
     108                                ;		mov	arg2,-(sp)
     109                                ;		mov	arg1,-(sp)
     110                                ;		mov	format,-(sp)
     111                                ;		mov	buffer,-(sp)
     112                                ;		call	sprintf
     113                                ;		add	#2*N,sp
     114                                ;
     115 011100 010046                  sprintf::mov	r0,-(sp)		; save reg
     116 011102 010146                  	mov	r1,-(sp)		;
     117 011104 010246                  	mov	r2,-(sp)		;
     118 011106 010346                  	mov	r3,-(sp)		;
     119 011110 010446                  	mov	r4,-(sp)		;
     120 011112 010546                  	mov	r5,-(sp)		;
     121                                	
     122 011114 010605                  	mov	sp,r5			; frame pointer
     123 011116 162706  000014          	sub	#n.last,sp		; reserve space on stack
     124                                	
     125 011122 010504                  	mov	r5,r4			; get frame ptr
     126 011124 062704  000016          	add	#n.args,r4		; offset to first argument
     127                                	
     128 011130 012765  011144  177766  	mov	#1$,p.out(r5)		; character output routine
     129 011136 012465  177764          	mov	(r4)+,p.ptr(r5)		; init bufptr from argument
     130                                	
     131 011142 000412                  	br	xprintf			; continue
     132                                
     133                                	; ---------------------------------------------------------
     134                                	
     135                                	; character output to buffer
     136                                	
     137 011144 110075  177764          1$:	movb	r0,@p.ptr(r5)		; store character
     138 011150 005265  177764          	inc	p.ptr(r5)		; bump pointer
     139 011154 105075  177764          	clrb	@p.ptr(r5)		; null terminate
     140 011160 016565  177764  000012  	mov	p.ptr(r5),p.sr0(r5)	; return updated ptr in saved r0
     141 011166                         	return				; return
       1 011166 000207                  	rts	pc
     142                                	
     143                                ; --------------------------------------------------------------------------------
     144                                
     145                                	; process main format
     146                                
     147 011170 012403                  xprintf:mov	(r4)+,r3		; prime format string pointer
     148                                
     149 011172                         1$:	call	900$			; get next format character
       1 011172 004737  012102          	jsr	pc,900$
     150 011176 120227  000045          	cmpb	r2,#<'%>		; hit a format flag?
     151 011202 001430                  	beq	10$			; yes, go process
     152 011204 120227  000134          	cmpb	r2,#<'\>		; hit an escape flag?
     153 011210 001404                  	beq	3$			; yes, go process
     154 011212 010200                  2$:	mov	r2,r0			; char to print
     155 011214                         	call	@p.out(r5)		; no, just print it
       1 011214 004775  177766          	jsr	pc,@p.out(r5)
     156 011220 000764                  	br	1$			; loop
     157                                
     158                                	; process escaped character \a .. \z
     159                                
     160 011222                         3$:	call	900$			; get the escaped character
       1 011222 004737  012102          	jsr	pc,900$
     161 011226 002771                  	blt	2$			; quick exit for [NUL-@] range
     162 011230 120227  000172          	cmpb	r2,#<'z>		;
     163 011234 003366                  	bgt	2$			; exit if [{-DEL]
     164 011236 120227  000141          	cmpb	r2,#<'a>		;
     165 011242 002005                  	bge	4$			; br if [a-z]	
     166 011244 120227  000132          	cmpb	r2,#<'Z>		;
     167 011250 003360                  	bgt	2$			; br if [[-`]
     168 011252 152702  000040          	bisb	#40,r2			; force to [a-z] range
     169 011256 116202  011777          4$:	movb	1000$-<'a>(r2),r2	; translate a..z to escaped
     170 011262 000753                  	br	2$			; go print
     171                                
     172                                	; process format flag %[-+]?(0?\d+([.]\d+)?)?[lh]?[iduscpxo]
     173                                
     174 011264 112765  000040  177776  10$:	movb	#<' >,p.fil(r5)		; blank fill
     175 011272 105065  177777          	clrb	p.flg(r5)		; clear flags
     176 011276 005065  177774          	clr	p.wid(r5)		; init width spec
     177 011302 005065  177772          	clr	p.pre(r5)		; init precision spec
     178 011306 005065  177770          	clr	p.len(r5)		; no digits yet
     179                                
     180 011312                         11$:	call	900$			; get next format character
       1 011312 004737  012102          	jsr	pc,900$
     181 011316 002045                  	bge	40$			; br if [A-DEL]
     182 011320 120227  000045          	cmpb	r2,#<'%>		; check for '%'
     183 011324 001732                  	beq	2$			; br if yes
     184                                
     185                                	; some character in range [NUL-@]
     186                                
     187 011326 120227  000055          	cmpb	r2,#<'->		; check for '-'
     188 011332 001004                  	bne	12$			; br if not
     189 011334 152765  000001  177777  	bisb	#pf.ljus,p.flg(r5)	; yes, set a flag
     190 011342 000763                  	br	11$			; loop
     191 011344 120227  000053          12$:	cmpb	r2,#<'+>		; check for '+'
     192 011350 001004                  	bne	13$			; br if not
     193 011352 152765  000002  177777  	bisb	#pf.sign,p.flg(r5)	; yes, set a flag
     194 011360 000754                  	br	11$			; loop
     195 011362 120227  000043          13$:	cmpb	r2,#<'#>		; check for '#'
     196 011366 001004                  	bne	20$			; br if not
     197 011370 152765  000004  177777  	bisb	#pf.altr,p.flg(r5)	; yes, set a flag
     198 011376 000745                  	br	11$			; loop
     199                                
     200 011400                         20$:	call	800$			; get a number if present
       1 011400 004737  012006          	jsr	pc,800$
     201 011404 010165  177774          	mov	r1,p.wid(r5)		; save number as width
     202                                
     203 011410 120227  000056          	cmpb	r2,#<'.>		; check for .
     204 011414 001006                  	bne	40$			; br if not, should be alpha
     205 011416                         	call	900$			; get next character
       1 011416 004737  012102          	jsr	pc,900$
     206                                
     207 011422                         	call	800$			; get a number if present
       1 011422 004737  012006          	jsr	pc,800$
     208 011426 010165  177772          	mov	r1,p.pre(r5)		; save number as precision
     209                                
     210                                	; flag is in range [A-Za-z]
     211                                
     212 011432 005000                  40$:	clr	r0			; zap numerics
     213 011434 005001                  	clr	r1			;
     214 011436 120227  000101          41$:	cmpb	r2,#<'A>		; check for [:-@]
     215 011442 002663                  	blt	2$			; br if yes
     216 011444 120227  000172          	cmpb	r2,#<'z>		; check for [{-DEL]
     217 011450 003260                  	bgt	2$			; br if yes
     218 011452 120227  000141          	cmpb	r2,#<'a>		; check for [a-z]
     219 011456 002003                  	bge	42$			; br if yes
     220 011460 120227  000132          	cmpb	r2,#<'Z>		; check for [A-Z]
     221 011464 003252                  	bgt	2$			; br if no
     222 011466 042702  000040          42$:	bic	#40,r2			; force to [a-z] to [A-Z] range
     223 011472 012401                  	mov	(r4)+,r1		; get the next value as lsb
     224 011474 006302                  	asl	r2			; char*2 for word offset
     225 011476 000172  011300          	jmp	@400$-<2*'A>(r2)	; dispatch
     226                                
     227                                400$:	;----	aaaa,bbbb,cccc,dddd,eeee,ffff,gggg,hhhh,iiii,jjjj,kkkk,llll,mmmm
     228 011502 011566  011772  011632  	.word	401$,470$,420$,430$,401$,401$,401$,401$,430$,401$,401$,405$,401$
         011510 011652  011566  011566  
         011516 011566  011566  011652  
         011524 011566  011566  011602  
         011532 011566                  
     229                                	;----	nnnn,oooo,pppp,qqqq,rrrr,ssss,tttt,uuuu,vvvv,wwww,xxxx,yyyy,zzzz
     230 011534 011566  011742  011742  	.word	401$,450$,450$,401$,401$,410$,401$,440$,401$,401$,460$,401$,401$
         011542 011566  011566  011620  
         011550 011566  011726  011566  
         011556 011566  011756  011566  
         011564 011566                  
     231                                
     232 011566 005744                  401$:	tst	-(r4)			; %<illegal>: backup argument pointer
     233 011570 005002                  	clr	r2			; zap
     234 011572 156302  177777          	bisb	-1(r3),r2		; retrieve last character
     235 011576 000137  011212          	jmp	2$			; just go print
     236                                
     237 011602                         405$:	call	900$			; %l: get next character
       1 011602 004737  012102          	jsr	pc,900$
     238 011606 152765  000010  177777  	bisb	#pf.long,p.flg(r5)	; indicate longword value
     239 011614 010100                  	mov	r1,r0			; copy 1st arg to msb
     240 011616 000707                  	br	41$			; and go parse next flag
     241                                
     242 011620 010102                  410$:	mov	r1,r2			; %s: get next arg as string address
     243 011622                         	call	prtstr			; print as a string
       1 011622 004737  012542          	jsr	pc,prtstr
     244 011626 000137  011172          	jmp	1$			; continue at the top
     245                                
     246 011632 005046                  420$:	clr	-(sp)			; %c: zap upper byte
     247 011634 110116                  	movb	r1,(sp)			; insert the character
     248 011636 010602                  	mov	sp,r2			; point at string
     249 011640                         	call	prtstr			; print as a string
       1 011640 004737  012542          	jsr	pc,prtstr
     250 011644 005726                  	tst	(sp)+			; flush temp string
     251 011646 000137  011172          	jmp	1$			; continue at the top
     252                                
     253 011652 012702  000012          430$:	mov	#10.,r2			; %d,%i: decimal radix
     254 011656 132765  000010  177777  	bitb	#pf.long,p.flg(r5)	; longword value?
     255 011664 001004                  	bne	431$			; br if yes
     256 011666 005000                  	clr	r0			; zap
     257 011670 005701                  	tst	r1			; no; test lsb sign
     258 011672 100001                  	bpl	431$			; br if plus/zero
     259 011674 005100                  	com	r0			; extend -1 to msb
     260 011676 005700                  431$:	tst	r0			; test msb sign
     261 011700 002006                  	bge	439$			; br if zero or positive
     262 011702 005400                  	neg	r0			; negative; make positive
     263 011704 005401                  	neg	r1			;
     264 011706 005600                  	sbc	r0			;
     265 011710 152765  000020  177777  	bisb	#pf.nega,p.flg(r5)	; set flag indicating negative
     266 011716                         439$:	call	prt32u			; print as unsigned decimal w/sign
       1 011716 004737  012172          	jsr	pc,prt32u
     267 011722 000137  011172          	jmp	1$			; continue at the top
     268                                
     269 011726 012702  000012          440$:	mov	#10.,r2			; %u: decimal radix
     270 011732                         	call	prt32u			; print as an unsigned decimal
       1 011732 004737  012172          	jsr	pc,prt32u
     271 011736 000137  011172          	jmp	1$			; continue at the top
     272                                
     273 011742 012702  000010          450$:	mov	#8.,r2			; %o,%p: octal radix
     274 011746                         	call	prt32u			; print as an unsigned hex
       1 011746 004737  012172          	jsr	pc,prt32u
     275 011752 000137  011172          	jmp	1$			; continue at the top
     276                                
     277 011756 012702  000020          460$:	mov	#16.,r2			; %x: hexadecimal radix
     278 011762                         	call	prt32u			; print as an unsigned hex
       1 011762 004737  012172          	jsr	pc,prt32u
     279 011766 000137  011172          	jmp	1$			; continue at the top
     280                                
     281 011772 012702  000002          470$:	mov	#2.,r2			; %b: binary radix
     282 011776                         	call	prt32u			; print as an unsigned binary
       1 011776 004737  012172          	jsr	pc,prt32u
     283 012002 000137  011172          	jmp	1$			; continue at the top
     284                                
     285                                	; ---------------------------------------------------------
     286                                	; get a number as '[0-9]+' or '*'
     287                                
     288 012006 120227  000052          800$:	cmpb	r2,#<'*>		; check for '*' indirection
     289 012012 001427                  	beq	880$			; br if yes
     290 012014 120227  000060          	cmpb	r2,#<'0>		; check for leading '0' character
     291 012020 001002                  	bne	810$			; br if not
     292 012022 110265  177776          	movb	r2,p.fil(r5)		; yes, set a flag
     293 012026 005001                  810$:	clr	r1			; number accumulated here
     294 012030 120227  000060          820$:	cmpb	r2,#<'0>		; check for '0'
     295 012034 002421                  	blt	890$			; br if less that a '0'
     296 012036 120227  000071          	cmpb	r2,#<'9>		; check for '9'
     297 012042 003016                  	bgt	890$			; br if greater than '9'
     298 012044 162702  000060          	sub	#<'0>,r2		; offset to range 0..9
     299 012050 006301                  	asl	r1			; number *= 2.
     300 012052 010100                  	mov	r1,r0			; (number*2.)
     301 012054 006300                  	asl	r0			; (number*4.)
     302 012056 006300                  	asl	r0			; (number*8.)
     303 012060 060001                  	add	r0,r1			; number = number*8. + number*2.
     304 012062 060201                  	add	r2,r1			; add in this digit
     305 012064                         	call	900$			; get next format character
       1 012064 004737  012102          	jsr	pc,900$
     306 012070 000757                  	br	820$			; and loop
     307 012072 012401                  880$:	mov	(r4)+,r1		; get next arg as number
     308 012074                         	call	900$			; get next character
       1 012074 004737  012102          	jsr	pc,900$
     309 012100                         890$:	return				; return
       1 012100 000207                  	rts	pc
     310                                
     311                                	; ---------------------------------------------------------
     312                                	; get next character (or exit) routine; result in r2
     313                                
     314 012102 112302                  900$:	movb	(r3)+,r2		; get next format character
     315 012104 042702  177600          	bic	#^c177,r2		; 7bit ascii only
     316 012110 001403                  	beq	990$			; end of string seen
     317 012112 120227  000101          	cmpb	r2,#<'A>		; check for [A-DEL]
     318 012116                         	return				; leave CC set with result
       1 012116 000207                  	rts	pc
     319                                
     320 012120 010506                  990$:	mov	r5,sp			; flush frame
     321 012122 012605                  	mov	(sp)+,r5		; restore reg
     322 012124 012604                  	mov	(sp)+,r4		;
     323 012126 012603                  	mov	(sp)+,r3		;
     324 012130 012602                  	mov	(sp)+,r2		;
     325 012132 012601                  	mov	(sp)+,r1		;
     326 012134 012600                  	mov	(sp)+,r0		;
     327 012136                         	return				; return
       1 012136 000207                  	rts	pc
     328                                
     329                                	; ---------------------------------------------------------
     330                                	; escaped character table
     331                                1000$:	;	aaa bbb ccc ddd eee fff ggg hhh iii jjj kkk lll mmm
     332                                	;	BEL  BS         ESC  FF
     333 012140    007     010     143  	.byte	007,010,143,144,033,014,147,150,151,152,153,154,155
         012143    144     033     014  
         012146    147     150     151  
         012151    152     153     154  
         012154    155                  
     334                                	;	nnn ooo ppp qqq rrr sss ttt uuu vvv www xxx yyy zzz
     335                                	;	 LF              CR      HT      VT
     336 012155    012     157     160  	.byte	012,157,160,161,015,163,011,165,013,167,170,172,172
         012160    161     015     163  
         012163    011     165     013  
         012166    167     170     172  
         012171    172                  
     337                                	; ---------------------------------------------------------
     338                                
     339                                ; --------------------------------------------------------------------------------
     340                                ;
     341                                ; digit print routine .. print a 32b value as unsigned digits
     342                                ;
     343                                ;	call:	mov	datahi,r0
     344                                ;		mov	datalo,r1
     345                                ;		mov	#radix,r2 ; 2. or 8. or 10. or 16.
     346                                ;		call	prt32u
     347                                ;
     348                                ;		r0 - data msb      (not saved)
     349                                ;		r1 - data lsb      (not saved)
     350                                ;		r2 - radix         (not saved)
     351                                ;		r3 - ptr to format     (saved)
     352                                ;		r4 - ptr to arglist    (saved) [input not used]
     353                                ;		r5 - ptr to flags      (saved)
     354                                ;
     355 012172 010346                  prt32u:	mov	r3,-(sp)		; save regs we use
     356 012174 010446                  	mov	r4,-(sp)		;
     357                                
     358                                	; render all the digits onto the stack (lsd first, msd last)
     359                                
     360 012176 005046                  	clr	-(sp)			; zero flag
     361 012200 010246                  1$:	mov	r2,-(sp)		; radix lsb
     362 012202 005046                  	clr	-(sp)			;   and msb
     363 012204 010146                  	mov	r1,-(sp)		; number lsb
     364 012206 010046                  	mov	r0,-(sp)		;    and msb
     365 012210                         	call	uldiv			; get quo and rem
       1 012210 004737  013010          	jsr	pc,uldiv
     366 012214 016602  000006          	mov	6.(sp),r2		; restore radix from stack
     367 012220 062706  000010          	add	#8.,sp			; flush args
     368 012224 062703  000060          	add	#<'0>,r3		; make rem lsb a digit
     369 012230 020327  000071          	cmp	r3,#<'9>		; still a valid digit?
     370 012234 003402                  	ble	2$			; br if yes
     371 012236 062703  000007          	add	#<'A>-<':>,r3		; offset to 'A...'Z range
     372 012242 010346                  2$:	mov	r3,-(sp)		; save
     373 012244 005265  177770          	inc	p.len(r5)		; count digits
     374 012250 005701                  	tst	r1			; any lsb left?
     375 012252 001352                  	bne	1$			; br if yes
     376 012254 005700                  	tst	r0			; any msb left?
     377 012256 001350                  	bne	1$			; br if yes
     378                                
     379                                	; check if we generated the minimum number of digits requested
     380                                
     381 012260 026565  177770  177772  10$:	cmp	p.len(r5),p.pre(r5)	; compare length to precision
     382 012266 103005                  	bhis	20$			; br we're OK
     383 012270 012746  000060          	mov	#<'0>,-(sp)		; nope, add another digit
     384 012274 005265  177770          	inc	p.len(r5)		; count digits
     385 012300 000767                  	br	10$			; and loop	
     386                                
     387                                	; check for options (#) flag
     388                                
     389 012302 132765  000004  177777  20$:	bitb	#pf.altf,p.flg(r5)	; check for options flag
     390 012310 001422                  	beq	30$			; br if not set
     391 012312 020227  000020          	cmp	r2,#16.			; radix 16?
     392 012316 001407                  	beq	21$			; br if yes
     393 012320 020227  000010          	cmp	r2,#8.			; radix 8?
     394 012324 001014                  	bne	30$			; br if not
     395 012326 022716  000060          	cmp	#<'0>,(sp)		; first digit already zero?
     396 012332 001411                  	beq	30$			; yes, no need to add
     397 012334 000404                  	br	22$			; no, add a leading zero
     398 012336 012746  000170          21$:	mov	#<'x>,-(sp)		; add a '0x' prefix
     399 012342 005265  177770          	inc	p.len(r5)		; count it
     400 012346 012746  000060          22$:	mov	#<'0>,-(sp)		;
     401 012352 005265  177770          	inc	p.len(r5)		; count it
     402                                
     403                                	; check if we need a sign (+/-/none)
     404                                
     405 012356 132765  000020  177777  30$:	bitb	#pf.nega,p.flg(r5)	; was original value negative?
     406 012364 001403                  	beq	31$			; br if not
     407 012366 012746  000055          	mov	#<'->,-(sp)		; minus sign
     408 012372 000406                  	br	32$			;
     409 012374 132765  000002  177777  31$:	bitb	#pf.sign,p.flg(r5)	; sign always requested?
     410 012402 001404                  	beq	50$			; br if not
     411 012404 012746  000053          	mov	#<'+>,-(sp)		; plus sign
     412 012410 005265  177770          32$:	inc	p.len(r5)		; count all chars generated
     413                                
     414                                	; processing for right justification
     415                                
     416 012414 132765  000001  177777  50$:	bitb	#pf.ljus,p.flg(r5)	; check left-justify flag
     417 012422 001020                  	bne	70$			; br if left justified
     418 012424 116501  177776          	movb	p.fil(r5),r1		; get fill character
     419 012430 026565  177770  177774  51$:	cmp	p.len(r5),p.wid(r5)	; compare length to width
     420 012436 103012                  	bhis	70$			; br if we're OK
     421 012440 011600                  	mov	(sp),r0			; copy last character
     422 012442 010146                  	mov	r1,-(sp)		; add a fill character
     423 012444 020100                  	cmp	r1,r0			; check fill/last char order
     424 012446 101403                  	blos	52$			; br if order OK
     425 012450 010016                  	mov	r0,(sp)			; copy sign/last char
     426 012452 010166  000002          	mov	r1,2(sp)		; insert fill after sign
     427 012456 005265  177770          52$:	inc	p.len(r5)		; count it
     428 012462 000762                  	br	51$			; loop
     429                                
     430                                	; print all digits in order (sign..msd..lsd)
     431                                
     432 012464 005001                  70$:	clr	r1			; count characters output
     433 012466 012600                  71$:	mov	(sp)+,r0		; get a digit
     434 012470 001404                  	beq	80$			; br if no more
     435 012472                         	call	@p.out(r5)		; print it
       1 012472 004775  177766          	jsr	pc,@p.out(r5)
     436 012476 005201                  	inc	r1			; count it
     437 012500 000772                  	br	71$			; loop
     438                                
     439                                	; processing for left justification
     440                                
     441 012502 132765  000001  177777  80$:	bitb	#pf.ljus,p.flg(r5)	; check left-justify flag
     442 012510 001411                  	beq	90$			; br if is right justified
     443 012512 012700  000040          	mov	#<' >,r0		; space fill on right
     444 012516 020165  177774          81$:	cmp	r1,p.wid(r5)		; compare length to width
     445 012522 103004                  	bhis	90$			; br we're OK
     446 012524                         	call	@p.out(r5)		; print it
       1 012524 004775  177766          	jsr	pc,@p.out(r5)
     447 012530 005201                  	inc	r1			; count characters
     448 012532 000771                  	br	81$			; and loop	
     449                                
     450                                	; and done
     451                                
     452 012534 012604                  90$:	mov	(sp)+,r4		; restore regs
     453 012536 012603                  	mov	(sp)+,r3		;
     454 012540                         	return				; return
       1 012540 000207                  	rts	pc
     455                                
     456                                ; --------------------------------------------------------------------------------
     457                                ;
     458                                ; asciz string print routine
     459                                ;
     460                                ;	call:	mov	#strptr,r2
     461                                ;		call	prtstr
     462                                ;
     463                                ;		r0 - temp          (not saved)
     464                                ;		r1 - temp          (not saved)
     465                                ;		r2 - ptr to string (not saved)
     466                                ;		r3 - ptr to format     (saved) [input not used]
     467                                ;		r4 - ptr to arglist    (saved) [input not used]
     468                                ;		r5 - ptr to flags      (saved)
     469                                ;
     470 012542 010346                  prtstr:	mov	r3,-(sp)		; save regs
     471 012544 010446                  	mov	r4,-(sp)		;
     472                                
     473                                	; compute length of string
     474                                
     475 012546 010203                  	mov	r2,r3			; copy ptr to string
     476 012550 105723                  1$:	tstb	(r3)+			; check a byte
     477 012552 001376                  	bne	1$			; br if more string
     478 012554 160203                  	sub	r2,r3			; compute length
     479 012556 005303                  	dec	r3			; minus the trailing null	
     480                                
     481                                	; set precision to length if precision is zero
     482                                
     483 012560 005765  177772          	tst	p.pre(r5)		; check requested precision
     484 012564 001002                  	bne	20$			; br if nonzero
     485 012566 010365  177772          	mov	r3,p.pre(r5)		; else set to string length
     486 012572 020365  177772          20$:	cmp	r3,p.pre(r5)		; compare actual length to precision
     487 012576 101402                  	blos	50$			; br if actual <= precision
     488 012600 016503  177772          	mov	p.pre(r5),r3		; else set actual to precision
     489                                
     490                                	; processing for right justification
     491                                
     492 012604 132765  000001  177777  50$:	bitb	#pf.ljus,p.flg(r5)	; check left-justify flag
     493 012612 001002                  	bne	70$			; br if left justified
     494 012614                         	call	100$			; do fill
       1 012614 004737  012662          	jsr	pc,100$
     495                                
     496                                	; print string 
     497                                
     498 012620 010301                  70$:	mov	r3,r1			; copy length
     499 012622 001406                  	beq	80$			; br if no characters
     500 012624 112200                  71$:	movb	(r2)+,r0		; get a character
     501 012626 001404                  	beq	80$			; br if no characters
     502 012630                         	call	@p.out(r5)		; print it
       1 012630 004775  177766          	jsr	pc,@p.out(r5)
     503 012634 005301                  	dec	r1			; count
     504 012636 001372                  	bne	71$			; loop
     505                                
     506                                	; processing for left justification
     507                                
     508 012640 132765  000001  177777  80$:	bitb	#pf.ljus,p.flg(r5)	; check left-justify flag
     509 012646 001402                  	beq	90$			; br if is right justified
     510 012650                         	call	100$			; do fill
       1 012650 004737  012662          	jsr	pc,100$
     511                                
     512                                	; and done
     513                                
     514 012654 012604                  90$:	mov	(sp)+,r4		; restore
     515 012656 012603                  	mov	(sp)+,r3		;
     516 012660                         	return				; return
       1 012660 000207                  	rts	pc
     517                                
     518                                	; ----------------------------------------------------
     519                                	; generate fill characters
     520                                
     521 012662 016501  177774          100$:	mov	p.wid(r5),r1		; requested width
     522 012666 160301                  	sub	r3,r1			; subtract string width
     523 012670 101406                  	blos	102$			; br if no fill needed
     524 012672 116500  177776          	movb	p.fil(r5),r0		; get fill character
     525 012676                         101$:	call	@p.out(r5)		; print a fill character
       1 012676 004775  177766          	jsr	pc,@p.out(r5)
     526 012702 005301                  	dec	r1			; count
     527 012704 001374                  	bne	101$			; loop
     528 012706                         102$:	return				; done
       1 012706 000207                  	rts	pc
     529                                
     530                                ; --------------------------------------------------------------------------------
     531                                
     532                                .include "mac/muldiv.mac"
       1                                ;=================================================================================
       2                                ; muldiv.mac - 32b mul/div routines for macro11 diagnostics
       3                                ; (C) 2009-2016 Donald North. All rights reserved.
       4                                ;=================================================================================
       5                                
       6                                ; --------------------------------------------------------------------------------
       7                                ;
       8                                ; unsigned 32b * 32b => 32b multiplication
       9                                ; 
      10                                ; from the 2.9BSD stdio C lib, using simple shift/add algorithm
      11                                ; 
      12                                ;	call:	mov	#b.lo,-(sp)
      13                                ;		mov	#b.hi,-(sp)
      14                                ;		mov	#a.lo,-(sp)
      15                                ;		mov	#a.hi,-(sp)
      16                                ;		call	ulmul
      17                                ;		add	#8.,sp
      18                                ;		mov	r1,q.lo
      19                                ;		mov	r0,q.hi
      20                                ;
      21 012710 010246                  ulmul::	mov	r2,-(sp)		; save
      22 012712 010346                  	mov	r3,-(sp)		;
      23 012714 010446                  	mov	r4,-(sp)		;
      24 012716 010546                  	mov	r5,-(sp)		;
      25                                
      26 012720 016605  000020          	mov	8.+8.(sp),r5		; b.lo
      27 012724 016604  000016          	mov	6.+8.(sp),r4		; b.hi
      28 012730 016603  000014          	mov	4.+8.(sp),r3		; a.lo
      29 012734 016602  000012          	mov	2.+8.(sp),r2		; a.hi
      30 012740 005001                  	clr	r1			; q.lo
      31 012742 005000                  	clr	r0			; q.hi
      32                                
      33 012744 000241                  1$:	clc				; shiftin zeroes
      34 012746 006004                  	ror	r4			; shift multiplier right one
      35 012750 006005                  	ror	r5			;
      36 012752 103003                  	bcc	2$			; br if shifted out a zero
      37 012754 060301                  	add	r3,r1			; else add multiplicand to product
      38 012756 005500                  	adc	r0			; propagate C
      39 012760 060200                  	add	r2,r0			;
      40 012762 006303                  2$:	asl	r3			; shift multiplicant left one
      41 012764 006102                  	rol	r2			;
      42 012766 005704                  	tst	r4			; any high multiplier bits left?
      43 012770 001365                  	bne	1$			; br if yes
      44 012772 005705                  	tst	r5			; any low multiplier bits left?
      45 012774 001363                  	bne	1$			; br if yes
      46                                
      47 012776 012605                  	mov	(sp)+,r5		; restore
      48 013000 012604                  	mov	(sp)+,r4		;
      49 013002 012603                  	mov	(sp)+,r3		;
      50 013004 012602                  	mov	(sp)+,r2		;
      51 013006                         	return				; done
       1 013006 000207                  	rts	pc
      52                                
      53                                ; --------------------------------------------------------------------------------
      54                                ;
      55                                ; unsigned 32b / 32b => 32b, 32b division with remainder
      56                                ; 
      57                                ; from Hennessey & Patterson Appendix A
      58                                ;
      59                                ;	call:	mov	#den.lo,-(sp)	; 8.(sp)
      60                                ;		mov	#den.hi,-(sp)	; 6.(sp)
      61                                ;		mov	#num.lo,-(sp)	; 4.(sp)
      62                                ;		mov	#num.hi,-(sp)	; 2.(sp)
      63                                ;		call	uldiv
      64                                ;		add	#8.,sp
      65                                ;		mov	r3,rem.lo
      66                                ;		mov	r2,rem.hi
      67                                ;		mov	r1,quo.lo
      68                                ;		mov	r0,quo.hi
      69                                ;
      70 013010 010446                  uldiv::	mov	r4,-(sp)		; save
      71 013012 010546                  	mov	r5,-(sp)		;
      72                                
      73 013014 016601  000010          	mov	4.+4.(sp),r1		; num.lo
      74 013020 016600  000006          	mov	2.+4.(sp),r0		; num.hi
      75                                
      76 013024 005005                  	clr	r5			; tmp.lo
      77 013026 005004                  	clr	r4			; tmp.hi
      78                                
      79 013030 012746  000037          	mov	#31.,-(sp)		; bit count
      80                                
      81 013034 006301                  1$:	asl	r1			; (tmp,num) <<= 1
      82 013036 006100                  	rol	r0			;
      83 013040 006105                  	rol	r5			;
      84 013042 006104                  	rol	r4			;
      85                                
      86 013044 010503                  	mov	r5,r3			; rem = tmp - den
      87 013046 010402                  	mov	r4,r2			;
      88 013050 166603  000016          	sub	8.+6.(sp),r3		;
      89 013054 005602                  	sbc	r2			;
      90 013056 166602  000014          	sub	6.+6.(sp),r2		;
      91                                
      92 013062 100403                  	bmi	2$			; br if rem < 0
      93                                
      94 013064 005201                  	inc	r1			; quo |= 1
      95 013066 010305                  	mov	r3,r5			; tmp = rem
      96 013070 010204                  	mov	r2,r4			;
      97                                
      98 013072 005316                  2$:	dec	(sp)			; count bits
      99 013074 002357                  	bge	1$			; loop if more
     100 013076 005726                  	tst	(sp)+			; flush counter
     101                                
     102 013100 005702                  	tst	r2			; test for rem < 0
     103 013102 002005                  	bge	3$			; br if not
     104                                
     105 013104 066603  000014          	add	8.+4.(sp),r3		; rem += den correction
     106 013110 005502                  	adc	r2			;
     107 013112 066602  000012          	add	6.+4.(sp),r2		;
     108                                
     109 013116 012605                  3$:	mov	(sp)+,r5		; restore
     110 013120 012604                  	mov	(sp)+,r4		;
     111 013122                         	return				; done
       1 013122 000207                  	rts	pc
     112                                
     113                                ; --------------------------------------------------------------------------------
     114                                ;
     115                                ; signed 32b / 32b => 32b, 32b division with remainder
     116                                ; 
     117                                ;	call:	mov	#den.lo,-(sp)	; 8.(sp)
     118                                ;		mov	#den.hi,-(sp)	; 6.(sp)
     119                                ;		mov	#num.lo,-(sp)	; 4.(sp)
     120                                ;		mov	#num.hi,-(sp)	; 2.(sp)
     121                                ;		call	sldiv
     122                                ;		add	#8.,sp
     123                                ;		mov	r3,rem.lo
     124                                ;		mov	r2,rem.hi
     125                                ;		mov	r1,quo.lo
     126                                ;		mov	r0,quo.hi
     127                                ;
     128 013124 010446                  sldiv::	mov	r4,-(sp)		; save
     129                                
     130 013126 016603  000012          	mov	8.+2.(sp),r3		; den.lo
     131 013132 016602  000010          	mov	6.+2.(sp),r2		; den.hi
     132 013136 016601  000006          	mov	4.+2.(sp),r1		; num.lo
     133 013142 016600  000004          	mov	2.+2.(sp),r0		; num.hi
     134                                
     135 013146 005004                  	clr	r4			; pos
     136                                
     137 013150 005700                  	tst	r0			; num sign
     138 013152 002006                  	bge	10$			; br if pos
     139                                
     140 013154 005104                  	com	r4			; neg
     141                                
     142 013156 005101                  	com	r1			; negate num
     143 013160 005100                  	com	r0			;
     144 013162 062701  000001          	add	#1,r1			;
     145 013166 005500                  	adc	r0			; 
     146                                
     147 013170 005702                  10$:	tst	r2			; den sign
     148 013172 002006                  	bge	20$			; br if pos
     149                                
     150 013174 105104                  	comb	r4			; neg
     151                                
     152 013176 005103                  	com	r3			; negate den
     153 013200 005102                  	com	r2			;
     154 013202 062703  000001          	add	#1,r3			;
     155 013206 005502                  	adc	r2			; 
     156                                	
     157 013210 010346                  20$:	mov	r3,-(sp)		; den.lo
     158 013212 010246                  	mov	r2,-(sp)		; den.hi
     159 013214 010146                  	mov	r1,-(sp)		; num.lo
     160 013216 010046                  	mov	r0,-(sp)		; num.hi
     161 013220                         	call	uldiv			;
       1 013220 004737  013010          	jsr	pc,uldiv
     162 013224 062706  000010          	add	#8.,sp			; 
     163                                
     164 013230 005704                  	tst	r4			; invert result
     165 013232 002005                  	bge	30$			;
     166                                
     167 013234 005103                   	com	r3			; negate rem
     168 013236 005102                  	com	r2			;
     169 013240 062703  000001          	add	#1,r3			;
     170 013244 005502                  	adc	r2			; 
     171                                
     172 013246 105704                  30$:	tstb	r4			; invert result
     173 013250 002005                  	bge	40$			;
     174                                
     175 013252 005101                  	com	r1			; negate quo
     176 013254 005100                  	com	r0			;
     177 013256 062701  000001          	add	#1,r1			;
     178 013262 005500                  	adc	r0			; 
     179                                
     180 013264 012604                  40$:	mov	(sp)+,r4		; restore
     181 013266                         	return				; done
       1 013266 000207                  	rts	pc
     182                                
     183                                ;================================================================================
     184                                ; end of muldiv.mac
     185                                ;================================================================================
     185                                
     533                                
     534                                ; --------------------------------------------------------------------------------
     535                                
     536        000000                  .iif ne,pf.sep,	.end
     537                                
     538                                ;=================================================================================
     539                                ; end of printf.mac
     540                                ;=================================================================================
     540                                
     932                                
     933                                .end
     933                                


Symbol table

$$NUM  =000012           19$13  =010576   L       440$17 =011726   L       BIT08  =000400           N.LAST =000014           
$$POS  =000200           2$1    =002456   L       450$17 =011742   L       BIT09  =001000           NOXXDP =007716           
$ENDAD =007702           2$17   =011212   L       460$17 =011756   L       BIT1   =000002           NUMPAS =002004           
$SAV42 =002050           2$18   =012242   L       470$17 =011772   L       BIT10  =002000           OPTSWI =002002           
.      =******           2$2    =002650   L       5$1    =002606   L       BIT11  =004000           P.FIL  =177776           
1$1    =002430   L       2$20   =012762   L       50$18  =012414   L       BIT12  =010000           P.FLG  =177777           
1$14   =011002   L       2$21   =013072   L       50$19  =012604   L       BIT13  =020000           P.LEN  =177770           
1$15   =011064   L       2$3    =003056   L       51$18  =012430   L       BIT14  =040000           P.OUT  =177766           
1$16   =011144   L       20$10  =010276   L       52$18  =012456   L       BIT15  =100000           P.PRE  =177772           
1$17   =011172   L       20$11  =010364   L       60$4   =003516   L       BIT2   =000004           P.PTR  =177764           
1$18   =012200   L       20$12  =010436   L       61$4   =003520   L       BIT3   =000010           P.SR0  =000012           
1$19   =012550   L       20$13  =010602   L       62$4   =003544   L       BIT4   =000020           P.SR1  =000010           
1$2    =002624   L       20$17  =011400   L       63$4   =003544   L       BIT5   =000040           P.SR2  =000006           
1$20   =012744   L       20$18  =012302   L       70$0   =002336   L       BIT6   =000100           P.SR3  =000004           
1$21   =013034   L       20$19  =012572   L       70$18  =012464   L       BIT7   =000200           P.SR4  =000002           
1$3    =003026   L       20$22  =013210   L       70$19  =012620   L       BIT8   =000400           P.SR5  =000000           
1$4    =003216   L       20$4   =003336   L       70$4   =003546   L       BIT9   =001000           P.WID  =177774           
1$8    =007412   L       20$5   =004124   L       70$5   =004256   L       BLBEG  =002020           PASSES =002040           
10$12  =010404   L       20$6   =004560   L       70$6   =004724   L       BLEND  =002022           PF.ALT =000004           
10$13  =010474   L       20$8   =007464   L       70$7   =006340   L       BLMAX  =002010           PF.LJU =000001           
10$17  =011264   L       21$18  =012336   L       70$8   =007606   L       BLMIN  =002006           PF.LON =000010           
10$18  =012260   L       21$4   =003360   L       71$13  =010624   L       BLMN   =000000           PF.NEG =000020           
10$22  =013170   L       21$5   =004146   L       71$18  =012466   L       BLMSK  =002024           PF.SEP =000000           
10$4   =003260   L       21$8   =007474   L       71$19  =012624   L       BLMX18 =007577           PF.SIG =000002           
10$5   =004062   L       22$18  =012346   L       71$4   =003611   L       BLMX22 =167777           PGIOS  =000007           
10$6   =004536   L       22$4   =003440   L       71$5   =004327   L       BLSZBY =000100           PGNONE =077400           
10$8   =007426   L       22$5   =004222   L       71$6   =004776   L       BLSZIO =000200           PGPRG  =000000           
10$9   =007750   L       23$4   =003454   L       71$7   =006410   L       BLSZUM =010000           PGPRGN =000004           
100$19 =012662   L       23$5   =004236   L       72$4   =003745   L       CCSR   =177746           PGRW   =077406           
100$7  =005226   L       24$4   =003456   L       72$7   =006471   L       CONSOL =165144 G         PGSZBL =000200           
1000$17=012140   L       24$5   =004240   L       73$7   =006604   L       CR     =000015           PGSZBY =020000           
101$19 =012676   L       3$17   =011222   L       74$7   =006702   L       CRLF   =010211           PGTST  =000006           
101$7  =005250   L       3$21   =013116   L       75$7   =007001   L       DISECC =010370           PHYADR =002044           
102$19 =012706   L       3$3    =003110   L       76$7   =007100   L       DONE   =007672           PRINTF =011020 G         
109$7  =005254   L       30$10  =010306   L       77$7   =007161   L       DPYREG =177570 G         PROTMN =002026           
11$17  =011312   L       30$12  =010444   L       80$18  =012502   L       ENBECC =010452           PROTMX =002030           
11$4   =003302   L       30$13  =010610   L       80$19  =012640   L       ENMMGT =002420           PRT32U =012172           
11$5   =004104   L       30$18  =012356   L       800$17 =012006   L       ERRORS =002036           PRTSTR =012542           
11$8   =007436   L       30$22  =013246   L       81$18  =012516   L       EXIT   =007732           PSW    =177776 G         
110$7  =005310   L       30$6   =004602   L       810$17 =012026   L       FAILS  =000000           SLDIV  =013124 G         
111$7  =005336   L       30$8   =007524   L       820$17 =012030   L       FLG22B =002034           SPRINT =011100 G         
112$7  =005424   L       31$18  =012374   L       880$17 =012072   L       KPAR   =172340           STACK  =002000           
113$7  =005506   L       31$6   =004670   L       890$17 =012100   L       KPDR   =172300           START  =002200           
119$7  =005510   L       32$18  =012410   L       90$18  =012534   L       LF     =000012           SWIREG =177570 G         
12$17  =011344   L       32$6   =004704   L       90$19  =012654   L       LOOP   =003134           TEST1  =003144           
12$4   =003322   L       32768$0=002220   L       900$17 =012102   L       MCR0   =172100           TEST2  =004020           
12$5   =004110   L       32769$0=002226   L       99$0   =002416   L       MCRDET =002774           TEST3  =004474           
120$7  =005544   L       32770$0=002244   L       99$4   =004014   L       MCRMSK =002032           TEST4  =005144           
121$7  =005566   L       32771$0=002256   L       99$5   =004470   L       MEMBL  =002012           TESTNO =002042           
122$7  =005654   L       34$6   =004706   L       99$6   =005140   L       MEMBYH =002016           TST$NO =000005           
129$7  =005656   L       4$1    =002564   L       99$7   =007326   L       MEMBYL =002014           TSTMAX =140077           
13$17  =011362   L       4$17   =011256   L       99$8   =007670   L       MMR0   =177572           TSTMIN =140000           
130$7  =005712   L       40$10  =010324   L       990$17 =012120   L       MMR1   =177574           TSTPAR =172354           
131$7  =005740   L       40$17  =011432   L       ADRCHK =010746 G         MMR2   =177576           TSTWC  =000040           
132$7  =006020   L       40$22  =013264   L       ADRTST =010344           MMR3   =172516           TTRBUF =177562 G         
139$7  =006022   L       400$17 =011502   L       ADRXLT =010214           MRELOC =007362           TTRCSR =177560 G         
140$7  =006056   L       401$17 =011566   L       BIT0   =000001           MSG1   =007760           TTXBUF =177566 G         
141$7  =006100   L       405$17 =011602   L       BIT00  =000001           MSG2   =010015           TTXCSR =177564 G         
142$7  =006162   L       41$17  =011436   L       BIT01  =000002           MSG3   =010031           ULDIV  =013010 G         
149$7  =006164   L       410$17 =011620   L       BIT02  =000004           MSG4   =010065           ULMUL  =012710 G         
150$7  =006220   L       42$17  =011466   L       BIT03  =000010           MSG5A  =010136           XPRINT =011170           
151$7  =006242   L       420$17 =011632   L       BIT04  =000020           MSG5B  =010173           
152$7  =006316   L       430$17 =011652   L       BIT05  =000040           MSG5C  =010201           
159$7  =006320   L       431$17 =011676   L       BIT06  =000100           MSIZER =002614           
18$13  =010570   L       439$17 =011716   L       BIT07  =000200           N.ARGS =000016           


Program sections:

. ABS.  013270    000   (RW,I,GBL,ABS,OVR,NOSAV)
        000000    001   (RW,I,LCL,REL,CON,NOSAV)
