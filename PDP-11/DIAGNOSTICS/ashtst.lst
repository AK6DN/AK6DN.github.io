       1                                .title	ASHC Instruction Test
       2                                
       3                                ; (C) 2016 Donald North. All rights reserved.
       4                                
       5                                .include "mac/stddef.mac"
       1                                ;================================================================================
       2                                ; stddef.mac - standard definitions
       3                                ; (C) 2009 Donald North. All rights reserved.
       4                                ;================================================================================
       5                                .macro	align	arg1
      16                                ;================================================================================
      17                                .macro	savreg	arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8
      28                                ;================================================================================
      29                                .macro	resreg	arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8
      40                                ;================================================================================
      41                                .macro	call	proc
      44                                .macro	return
      47                                .macro	calls	proc arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8 arg9 arg10 arg11 arg12 arg13 arg14 arg15 arg16
      67                                ;================================================================================
      68                                .macro	jeq	label ?a1
      73                                .macro	jne	label ?a1
      78                                .macro	jpl	label ?a1
      83                                .macro	jmi	label ?a1
      88                                .macro	jlo	label ?a1
      93                                .macro	jhis	label ?a1
      98                                .macro	jlos	label ?a1
     103                                .macro	jhi	label ?a1
     108                                .macro	jlt	label ?a1
     113                                .macro	jge	label ?a1
     118                                .macro	jle	label ?a1
     123                                .macro	jgt	label ?a1
     128                                .macro	jcc	label ?a1
     133                                .macro	jcs	label ?a1
     138                                .macro	jvc	label ?a1
     143                                .macro	jvs	label ?a1
     148                                ;================================================================================
     149                                .macro	printf	arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8 arg9 arg10 arg11 arg12 arg13 arg14 arg15 arg16
     152                                .macro	sprintf	arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8 arg9 arg10 arg11 arg12 arg13 arg14 arg15 arg16
     155                                ;================================================================================
     156                                .macro	ipl	lvl
     161                                ;================================================================================
     162                                .macro	trapcatcher	list ?a1 ?a2 ?a3 ?a4
     176                                ;================================================================================
     177        000001                  tst$no	= 1
     178                                .macro	test	title
     198                                ;================================================================================
     199                                ; end of stddef.mac
     200                                ;================================================================================
     200                                
       6                                
       7                                ; --------------------------------------------------------------------------------
       8                                
       9                                .sbttl	general definitions
      10                                
      11                                .include "mac/bits.mac"
       1                                ;================================================================================
       2                                ; bits.mac - standard bit definitions
       3                                ;================================================================================
       4                                
       5                                ;  system global fixed addresses
       6                                
       7        177776                  psw	==177776		; processor status word
       8                                
       9        165144                  console	==165144		; console routine start
      10                                
      11        177570                  swireg	==177570		; console switch register
      12        177570                  dpyreg	==swireg		; console display register
      13                                
      14        177560                  ttrcsr	==177560		; console serial device
      15        177562                  ttrbuf	==ttrcsr+2		;
      16        177564                  ttxcsr	==ttrcsr+4		;
      17        177566                  ttxbuf	==ttrcsr+6		;
      18                                
      19                                ; common values
      20                                
      21        000015                  cr	=015			; ascii CR
      22        000012                  lf	=012			; ascii LF
      23                                
      24        000001                  bit00	=000001			; bit positions
      25        000002                  bit01	=000002			;
      26        000004                  bit02	=000004			;
      27        000010                  bit03	=000010			;
      28        000020                  bit04	=000020			;
      29        000040                  bit05	=000040			;
      30        000100                  bit06	=000100			;
      31        000200                  bit07	=000200			;
      32        000400                  bit08	=000400			;
      33        001000                  bit09	=001000			;
      34        002000                  bit10	=002000			;
      35        004000                  bit11	=004000			;
      36        010000                  bit12	=010000			;
      37        020000                  bit13	=020000			;
      38        040000                  bit14	=040000			;
      39        100000                  bit15	=100000			;
      40                                	
      41        000001                  bit0	=bit00			; also
      42        000002                  bit1	=bit01			;
      43        000004                  bit2	=bit02			;
      44        000010                  bit3	=bit03			;
      45        000020                  bit4	=bit04			;
      46        000040                  bit5	=bit05			;
      47        000100                  bit6	=bit06			;
      48        000200                  bit7	=bit07			;
      49        000400                  bit8	=bit08			;
      50        001000                  bit9	=bit09			;
      51                                
      52                                ;================================================================================
      53                                ; end of bits.mac
      54                                ;================================================================================
      54                                
      12                                
      13                                ; --------------------------------------------------------------------------------
      14                                
      15                                .sbttl	low memory
      16                                
      17                                   	.enabl	ama			; change all mode 67 references to 37
      18                                
      19 000000                           	.asect				; absolute load image;	
      20                                
      21        000046                  	.=46
      22 000046 004512                  	.word	$endad			; address of JSR PC,(R0)
      23        000052                  	.=52
      24 000052 000000                  	.word	0			; run options
      25                                
      26        000200                  	.=200
      27 000200 000137  002200          	jmp	@#start			; standard diagnostic entry
      28                                
      29                                ; --------------------------------------------------------------------------------
      30                                
      31                                .sbttl	global variables
      32                                
      33        002000                  	.=2000
      34 002000 177777                  stack:	.word	-1			; top of stack
      35 002002 000000                  $sav42:	.word	0			; XXDP restart address
      36 002004 000000                  passes:	.word	0			; count passes
      37 002006    015     012     015  msg1:	.asciz	<cr><lf><cr><lf>"ASHC Test of ASHC R2,R0"<cr><lf><cr><lf>
         002011    012     101     123  
         002014    110     103     040  
         002017    124     145     163  
         002022    164     040     157  
         002025    146     040     101  
         002030    123     110     103  
         002033    040     122     062  
         002036    054     122     060  
         002041    015     012     015  
         002044    012     000          
      38 002046    015     012     107  msg2:	.asciz	<cr><lf>"Goodbye"<cr><lf>
         002051    157     157     144  
         002054    142     171     145  
         002057    015     012     000  
      39                                	.even
      40                                
      41                                ; --------------------------------------------------------------------------------
      42                                
      43                                .sbttl	program start
      44                                
      45 002062                         	align	7			; pc alignment
      46                                
      47 002200 012706  002000          start:	mov	#stack,sp		; setup a stack
      48 002204 000005                  	reset				; reset the world
      49 002206 013737  000042  002002  	mov	@#42,$sav42		; save XXDP restart
      50                                
      51 002214                         	trapcatcher <2,200,206,400>	; setup a trapcatcher in low vector space
       1 002214 012700  002244          	mov	#32770$,r0    		; ptr to table
       2 002220 012001                  32768$:	mov	(r0)+,r1		; start addr
       3 002222 100415                  	bmi	32771$			; done?
       4 002224 012002                  	mov	(r0)+,r2		; end addr
       5 002226 010161  177776          32769$:	mov	r1,-2(r1)		; point vector at next word
       6 002232 005011                  	clr	(r1)			; <0> which is a halt
       7 002234 022121                  	cmp	(r1)+,(r1)+		; add four to ptr
       8 002236 020102                  	cmp	r1,r2			; reached end?
       9 002240 003772                  	ble	32769$			; not yet
      10 002242 000766                  	br	32768$			; more
      11 002244 000002  000200  000206  32770$:	.word	2,200,206,400, -1
         002252 000400  177777          
      12 002256 000240                  32771$:	nop				; placeholder
      52                                
      53 002260                         	printf	#msg1			; say hello
       1 002260                         	calls	printf #msg1               
       9 002260 012746  002006          	mov	#msg1,-(sp)
       2 002264                         	call	printf
       1 002264 004737  004550          	jsr	pc,printf
       3 002270 062706  000002          	add	#2,sp
      54                                
      55 002274 005037  002004          	clr	passes			;
      56                                
      57 002300                         loop:	printf	#710$			; header
       1 002300                         	calls	printf #710$               
       9 002300 012746  004224          	mov	#710$,-(sp)
       2 002304                         	call	printf
       1 002304 004737  004550          	jsr	pc,printf
       3 002310 062706  000002          	add	#2,sp
      58 002314 012705  002434          	mov	#500$,r5		; data table
      59                                
      60 002320 012500                  100$:	mov	(r5)+,r0		; source data
      61 002322 012501                  	mov	(r5)+,r1		;
      62 002324 012502                  	mov	(r5)+,r2		;
      63                                
      64 002326                         	printf	#711$,r0,r1,r2,r0,r1,r2 ; print source
       1 002326                         	calls	printf #711$ r0 r1 r2 r0 r1 r2         
       9 002326 010246                  	mov	r2,-(sp)
      15 002330 010146                  	mov	r1,-(sp)
      21 002332 010046                  	mov	r0,-(sp)
      27 002334 010246                  	mov	r2,-(sp)
      33 002336 010146                  	mov	r1,-(sp)
      39 002340 010046                  	mov	r0,-(sp)
      45 002342 012746  004362          	mov	#711$,-(sp)
       2 002346                         	call	printf
       1 002346 004737  004550          	jsr	pc,printf
       3 002352 062706  000016          	add	#16,sp
      65                                
      66 002356 073002                  	ashc	r2,r0			; do it
      67                                
      68 002360 013703  177776          	mov	@#psw,r3		; processor status
      69 002364 042703  177760          	bic	#^c17,r3		; mask all except NZVC
      70                                
      71 002370                         	printf	#712$,r0,r1,r2,r0,r1,r2,r3 ; print result
       1 002370                         	calls	printf #712$ r0 r1 r2 r0 r1 r2 r3        
       9 002370 010346                  	mov	r3,-(sp)
      15 002372 010246                  	mov	r2,-(sp)
      21 002374 010146                  	mov	r1,-(sp)
      27 002376 010046                  	mov	r0,-(sp)
      33 002400 010246                  	mov	r2,-(sp)
      39 002402 010146                  	mov	r1,-(sp)
      45 002404 010046                  	mov	r0,-(sp)
      51 002406 012746  004422          	mov	#712$,-(sp)
       2 002412                         	call	printf
       1 002412 004737  004550          	jsr	pc,printf
       3 002416 062706  000020          	add	#20,sp
      72                                
      73 002422 020527  004224          	cmp	r5,#501$		; end of table
      74 002426 001334                  	bne	100$
      75                                
      76 002430 000137  004466          	jmp	done			; all done
      77                                
      78                                	;        NumHi   NumLo   Count
      79                                	;           R0      R1      R2
      80 002434 000000  000000  000000  500$:	.word	     0,      0,      0.
      81                                	; 
      82 002442 100000  000000  177774  	.word	100000,	000000,	    -4.
      83 002450 100000  000000  177775  	.word	100000,	000000,	    -3.
      84 002456 100000  000000  177776  	.word	100000,	000000,	    -2.
      85 002464 100000  000000  177777  	.word	100000,	000000,	    -1.
      86 002472 100000  000000  000000  	.word	100000,	000000,	     0.
      87 002500 100000  000000  000001  	.word	100000,	000000,	    +1.
      88 002506 100000  000000  000002  	.word	100000,	000000,	    +2.
      89 002514 100000  000000  000003  	.word	100000,	000000,	    +3.
      90 002522 100000  000000  000004  	.word	100000,	000000,	    +4.
      91                                	; 
      92 002530 077777  177777  177774  	.word	077777,	177777,	    -4.
      93 002536 077777  177777  177775  	.word	077777,	177777,	    -3.
      94 002544 077777  177777  177776  	.word	077777,	177777,	    -2.
      95 002552 077777  177777  177777  	.word	077777,	177777,	    -1.
      96 002560 077777  177777  000000  	.word	077777,	177777,	     0.
      97 002566 077777  177777  000001  	.word	077777,	177777,	    +1.
      98 002574 077777  177777  000002  	.word	077777,	177777,	    +2.
      99 002602 077777  177777  000003  	.word	077777,	177777,	    +3.
     100 002610 077777  177777  000004  	.word	077777,	177777,	    +4.
     101                                	;
     118                                	; 
     119 002616                         	$$itr	000000 000001 + 32.
       2 002616 000000  000001  000000  	.word	000000, 000001, +0
       2 002624 000000  000001  000001  	.word	000000, 000001, +1
       2 002632 000000  000001  000002  	.word	000000, 000001, +2
       2 002640 000000  000001  000003  	.word	000000, 000001, +3
       2 002646 000000  000001  000004  	.word	000000, 000001, +4
       2 002654 000000  000001  000005  	.word	000000, 000001, +5
       2 002662 000000  000001  000006  	.word	000000, 000001, +6
       2 002670 000000  000001  000007  	.word	000000, 000001, +7
       2 002676 000000  000001  000010  	.word	000000, 000001, +10
       2 002704 000000  000001  000011  	.word	000000, 000001, +11
       2 002712 000000  000001  000012  	.word	000000, 000001, +12
       2 002720 000000  000001  000013  	.word	000000, 000001, +13
       2 002726 000000  000001  000014  	.word	000000, 000001, +14
       2 002734 000000  000001  000015  	.word	000000, 000001, +15
       2 002742 000000  000001  000016  	.word	000000, 000001, +16
       2 002750 000000  000001  000017  	.word	000000, 000001, +17
       2 002756 000000  000001  000020  	.word	000000, 000001, +20
       2 002764 000000  000001  000021  	.word	000000, 000001, +21
       2 002772 000000  000001  000022  	.word	000000, 000001, +22
       2 003000 000000  000001  000023  	.word	000000, 000001, +23
       2 003006 000000  000001  000024  	.word	000000, 000001, +24
       2 003014 000000  000001  000025  	.word	000000, 000001, +25
       2 003022 000000  000001  000026  	.word	000000, 000001, +26
       2 003030 000000  000001  000027  	.word	000000, 000001, +27
       2 003036 000000  000001  000030  	.word	000000, 000001, +30
       2 003044 000000  000001  000031  	.word	000000, 000001, +31
       2 003052 000000  000001  000032  	.word	000000, 000001, +32
       2 003060 000000  000001  000033  	.word	000000, 000001, +33
       2 003066 000000  000001  000034  	.word	000000, 000001, +34
       2 003074 000000  000001  000035  	.word	000000, 000001, +35
       2 003102 000000  000001  000036  	.word	000000, 000001, +36
       2 003110 000000  000001  000037  	.word	000000, 000001, +37
     120                                	; 
     121 003116                         	$$itr	100000 000000 - 33.
       2 003116 100000  000000  000000  	.word	100000, 000000, -0
       2 003124 100000  000000  177777  	.word	100000, 000000, -1
       2 003132 100000  000000  177776  	.word	100000, 000000, -2
       2 003140 100000  000000  177775  	.word	100000, 000000, -3
       2 003146 100000  000000  177774  	.word	100000, 000000, -4
       2 003154 100000  000000  177773  	.word	100000, 000000, -5
       2 003162 100000  000000  177772  	.word	100000, 000000, -6
       2 003170 100000  000000  177771  	.word	100000, 000000, -7
       2 003176 100000  000000  177770  	.word	100000, 000000, -10
       2 003204 100000  000000  177767  	.word	100000, 000000, -11
       2 003212 100000  000000  177766  	.word	100000, 000000, -12
       2 003220 100000  000000  177765  	.word	100000, 000000, -13
       2 003226 100000  000000  177764  	.word	100000, 000000, -14
       2 003234 100000  000000  177763  	.word	100000, 000000, -15
       2 003242 100000  000000  177762  	.word	100000, 000000, -16
       2 003250 100000  000000  177761  	.word	100000, 000000, -17
       2 003256 100000  000000  177760  	.word	100000, 000000, -20
       2 003264 100000  000000  177757  	.word	100000, 000000, -21
       2 003272 100000  000000  177756  	.word	100000, 000000, -22
       2 003300 100000  000000  177755  	.word	100000, 000000, -23
       2 003306 100000  000000  177754  	.word	100000, 000000, -24
       2 003314 100000  000000  177753  	.word	100000, 000000, -25
       2 003322 100000  000000  177752  	.word	100000, 000000, -26
       2 003330 100000  000000  177751  	.word	100000, 000000, -27
       2 003336 100000  000000  177750  	.word	100000, 000000, -30
       2 003344 100000  000000  177747  	.word	100000, 000000, -31
       2 003352 100000  000000  177746  	.word	100000, 000000, -32
       2 003360 100000  000000  177745  	.word	100000, 000000, -33
       2 003366 100000  000000  177744  	.word	100000, 000000, -34
       2 003374 100000  000000  177743  	.word	100000, 000000, -35
       2 003402 100000  000000  177742  	.word	100000, 000000, -36
       2 003410 100000  000000  177741  	.word	100000, 000000, -37
       2 003416 100000  000000  177740  	.word	100000, 000000, -40
     122                                	; 
     123 003424                         	$$itr	000000 000707 + 32.
       2 003424 000000  000707  000000  	.word	000000, 000707, +0
       2 003432 000000  000707  000001  	.word	000000, 000707, +1
       2 003440 000000  000707  000002  	.word	000000, 000707, +2
       2 003446 000000  000707  000003  	.word	000000, 000707, +3
       2 003454 000000  000707  000004  	.word	000000, 000707, +4
       2 003462 000000  000707  000005  	.word	000000, 000707, +5
       2 003470 000000  000707  000006  	.word	000000, 000707, +6
       2 003476 000000  000707  000007  	.word	000000, 000707, +7
       2 003504 000000  000707  000010  	.word	000000, 000707, +10
       2 003512 000000  000707  000011  	.word	000000, 000707, +11
       2 003520 000000  000707  000012  	.word	000000, 000707, +12
       2 003526 000000  000707  000013  	.word	000000, 000707, +13
       2 003534 000000  000707  000014  	.word	000000, 000707, +14
       2 003542 000000  000707  000015  	.word	000000, 000707, +15
       2 003550 000000  000707  000016  	.word	000000, 000707, +16
       2 003556 000000  000707  000017  	.word	000000, 000707, +17
       2 003564 000000  000707  000020  	.word	000000, 000707, +20
       2 003572 000000  000707  000021  	.word	000000, 000707, +21
       2 003600 000000  000707  000022  	.word	000000, 000707, +22
       2 003606 000000  000707  000023  	.word	000000, 000707, +23
       2 003614 000000  000707  000024  	.word	000000, 000707, +24
       2 003622 000000  000707  000025  	.word	000000, 000707, +25
       2 003630 000000  000707  000026  	.word	000000, 000707, +26
       2 003636 000000  000707  000027  	.word	000000, 000707, +27
       2 003644 000000  000707  000030  	.word	000000, 000707, +30
       2 003652 000000  000707  000031  	.word	000000, 000707, +31
       2 003660 000000  000707  000032  	.word	000000, 000707, +32
       2 003666 000000  000707  000033  	.word	000000, 000707, +33
       2 003674 000000  000707  000034  	.word	000000, 000707, +34
       2 003702 000000  000707  000035  	.word	000000, 000707, +35
       2 003710 000000  000707  000036  	.word	000000, 000707, +36
       2 003716 000000  000707  000037  	.word	000000, 000707, +37
     124                                	; 
     125 003724                         	$$itr	177777 177070 + 32.
       2 003724 177777  177070  000000  	.word	177777, 177070, +0
       2 003732 177777  177070  000001  	.word	177777, 177070, +1
       2 003740 177777  177070  000002  	.word	177777, 177070, +2
       2 003746 177777  177070  000003  	.word	177777, 177070, +3
       2 003754 177777  177070  000004  	.word	177777, 177070, +4
       2 003762 177777  177070  000005  	.word	177777, 177070, +5
       2 003770 177777  177070  000006  	.word	177777, 177070, +6
       2 003776 177777  177070  000007  	.word	177777, 177070, +7
       2 004004 177777  177070  000010  	.word	177777, 177070, +10
       2 004012 177777  177070  000011  	.word	177777, 177070, +11
       2 004020 177777  177070  000012  	.word	177777, 177070, +12
       2 004026 177777  177070  000013  	.word	177777, 177070, +13
       2 004034 177777  177070  000014  	.word	177777, 177070, +14
       2 004042 177777  177070  000015  	.word	177777, 177070, +15
       2 004050 177777  177070  000016  	.word	177777, 177070, +16
       2 004056 177777  177070  000017  	.word	177777, 177070, +17
       2 004064 177777  177070  000020  	.word	177777, 177070, +20
       2 004072 177777  177070  000021  	.word	177777, 177070, +21
       2 004100 177777  177070  000022  	.word	177777, 177070, +22
       2 004106 177777  177070  000023  	.word	177777, 177070, +23
       2 004114 177777  177070  000024  	.word	177777, 177070, +24
       2 004122 177777  177070  000025  	.word	177777, 177070, +25
       2 004130 177777  177070  000026  	.word	177777, 177070, +26
       2 004136 177777  177070  000027  	.word	177777, 177070, +27
       2 004144 177777  177070  000030  	.word	177777, 177070, +30
       2 004152 177777  177070  000031  	.word	177777, 177070, +31
       2 004160 177777  177070  000032  	.word	177777, 177070, +32
       2 004166 177777  177070  000033  	.word	177777, 177070, +33
       2 004174 177777  177070  000034  	.word	177777, 177070, +34
       2 004202 177777  177070  000035  	.word	177777, 177070, +35
       2 004210 177777  177070  000036  	.word	177777, 177070, +36
       2 004216 177777  177070  000037  	.word	177777, 177070, +37
     126                                	; 
     127                                501$:
     128                                
     129 004224    040     040     056  710$:	.ascii	"  ..R0.. ..R1.. ..R2.. .....NUM.... .CNT. =>"
         004227    056     122     060  
         004232    056     056     040  
         004235    056     056     122  
         004240    061     056     056  
         004243    040     056     056  
         004246    122     062     056  
         004251    056     040     056  
         004254    056     056     056  
         004257    056     116     125  
         004262    115     056     056  
         004265    056     056     040  
         004270    056     103     116  
         004273    124     056     040  
         004276    075     076          
     130 004300    040     056     056  	.asciz	" ..R0.. ..R1.. ..R2.. .....NUM.... .CNT. NZVC"<cr><lf><cr><lf>
         004303    122     060     056  
         004306    056     040     056  
         004311    056     122     061  
         004314    056     056     040  
         004317    056     056     122  
         004322    062     056     056  
         004325    040     056     056  
         004330    056     056     056  
         004333    116     125     115  
         004336    056     056     056  
         004341    056     040     056  
         004344    103     116     124  
         004347    056     040     116  
         004352    132     126     103  
         004355    015     012     015  
         004360    012     000          
     131 004362    040     040     045  711$:	.asciz	"  %.6o %.6o %.6o %11ld. %4d. =>"
         004365    056     066     157  
         004370    040     045     056  
         004373    066     157     040  
         004376    045     056     066  
         004401    157     040     045  
         004404    061     061     154  
         004407    144     056     040  
         004412    045     064     144  
         004415    056     040     075  
         004420    076     000          
     132 004422    040     045     056  712$:	.asciz	" %.6o %.6o %.6o %11ld. %4d. %.4b"<cr><lf>
         004425    066     157     040  
         004430    045     056     066  
         004433    157     040     045  
         004436    056     066     157  
         004441    040     045     061  
         004444    061     154     144  
         004447    056     040     045  
         004452    064     144     056  
         004455    040     045     056  
         004460    064     142     015  
         004463    012     000          
     133                                
     134 004465    000                  	.even
     135                                
     136                                ; --------------------------------------------------------------------------------
     137                                
     138 004466                         done:	printf	#msg2			; say goodbye
       1 004466                         	calls	printf #msg2               
       9 004466 012746  002046          	mov	#msg2,-(sp)
       2 004472                         	call	printf
       1 004472 004737  004550          	jsr	pc,printf
       3 004476 062706  000002          	add	#2,sp
     139                                
     140 004502 013700  002002          	mov	$sav42,r0		; check if loaded by XXDP
     141 004506 001407                  	beq	noxxdp			; br if not
     142 004510 000005                  	reset				; yes, reset the world
     143 004512 004710                  $endad:	jsr	pc,(r0)			; return back to XXDP
     144 004514 000240                  	nop				; standard sequence
     145 004516 000240                  	nop				;
     146 004520 000240                  	nop				;
     147 004522 000137  002300          	jmp	loop			; back for more
     148                                
     149 004526 005000                  noxxdp:	clr	r0			;
     150 004530 005300                  10$:	dec	r0			; 
     151 004532 001376                  	bne	10$			; some delay
     152 004534 000005                  	reset				; zap the world
     153 004536 012746  000340          	mov	#<7>*bit5,-(sp)		; prio7 in psw
     154 004542 012746  165144          	mov	#console,-(sp)		; go there
     155 004546 000002                  	rti				; reload psw
     156                                
     157                                ; --------------------------------------------------------------------------------
     158                                
     159                                .include "mac/printf.mac"
       1                                ;================================================================================
       2                                ; printf.mac - printf routines for macro11 diagnostics
       3                                ; (C) 2009-2016 Donald North. All rights reserved.
       4                                ;================================================================================
       5                                
       6                                .if ndf ttxcsr
       7                                	
       8                                	; separate psect (if console registers not defined)
       9                                	.psect	printf
      10                                
      11                                	; external tty references
      12                                	.globl	ttxcsr, ttxbuf
      13                                
      14                                	; standard macro definitions
      15                                 	.include "mac/stddef.mac"
      16                                
      17                                pf.sep	=1 ; flag separate compilation
      18                                
      19                                .iff
      20                                
      21        000000                  pf.sep	=0 ; flag unified compilation (via include)
      22                                	
      23                                .endc
      24                                ; 
      25                                ; global registers:
      26                                ;
      27                                ;  R5 - frame pointer
      28                                ;  R4 - argument pointer
      29                                ;  R3 - format string pointer
      30                                ;  R2 - current format character
      31                                ;  R1 - temp
      32                                ;  R0 - temp
      33                                ;
      34                                ; note:	for 11/04-05-10 compatibility, do NOT use SXT/XOR/SOB and MUL/DIV/ASH/ASHC
      35                                ; 
      36                                ; offsets from frame pointer (r5):
      37                                ; 
      38        000012                  p.sr0	=+10.	; saved r0
      39        000010                  p.sr1	=+8.	; saved r1
      40        000006                  p.sr2	=+6.	; saved r2
      41        000004                  p.sr3	=+4.	; saved r3
      42        000002                  p.sr4	=+2.	; saved r4
      43        000000                  p.sr5	=+0.	; saved r5
      44        177777                  p.flg	=-1.	; format flags (byte)
      45        177776                  p.fil	=-2.	; fill character (byte)
      46        177774                  p.wid	=-4.	; format numeric width (word)
      47        177772                  p.pre	=-6.	; format numeric precision (word)
      48        177770                  p.len	=-8.	; number of digits generated (word)
      49        177766                  p.out	=-10.	; addr(char print routine)
      50        177764                  p.ptr	=-12.	; sprintf output buffer pointer
      51                                ; 
      52        000014                  n.last	=+12.	; number of bytes allocated on stack
      53        000016                  n.args	=+14.	; offset to first argument on stack
      54                                ; 
      55                                ; bits in p.flg byte:
      56                                ; 
      57        000001                  pf.ljus	=1	; set for left justified ('-' seen)
      58        000002                  pf.sign	=2	; set for sign requested ('+' seen)
      59        000004                  pf.altf	=4	; set for alt flag ('#' seen)
      60        000010                  pf.long	=10	; set for long value (%...l. seen)
      61        000020                  pf.nega	=20	; set for negative value (msb set)
      62                                
      63                                ; --------------------------------------------------------------------------------
      64                                ;
      65                                ; printf routine .. 'C' printf(format,arg1,arg2,..,argn) ..  called in 'C' style
      66                                ;
      67                                ;	call:	mov	argN,-(sp)
      68                                ;		...
      69                                ;		mov	arg2,-(sp)
      70                                ;		mov	arg1,-(sp)
      71                                ;		mov	format,-(sp)
      72                                ;		call	printf
      73                                ;		add	#2*N,sp
      74                                ;
      75 004550 010046                  printf::mov	r0,-(sp)		; save reg
      76 004552 010146                  	mov	r1,-(sp)		;
      77 004554 010246                  	mov	r2,-(sp)		;
      78 004556 010346                  	mov	r3,-(sp)		;
      79 004560 010446                  	mov	r4,-(sp)		;
      80 004562 010546                  	mov	r5,-(sp)		;
      81                                	
      82 004564 010605                  	mov	sp,r5			; frame pointer
      83 004566 162706  000014          	sub	#n.last,sp		; reserve space on stack
      84                                	
      85 004572 010504                  	mov	r5,r4			; get frame ptr
      86 004574 062704  000016          	add	#n.args,r4		; offset to first argument
      87                                	
      88 004600 012765  004614  177766  	mov	#1$,p.out(r5)		; character output routine
      89 004606 005065  177764          	clr	p.ptr(r5)		; bufptr not used here
      90                                	
      91 004612 000442                  	br	xprintf			; continue
      92                                
      93                                	; ---------------------------------------------------------
      94                                	
      95                                	; character output to console
      96                                	
      97 004614 105737  177564          1$:	tstb	@#ttxcsr		; check if ready
      98 004620 100375                  	bpl	1$			; not yet
      99 004622 110037  177566          	movb	r0,@#ttxbuf		; send character
     100 004626                         	return				; return
       1 004626 000207                  	rts	pc
     101                                	
     102                                ; --------------------------------------------------------------------------------
     103                                ;
     104                                ; sprintf routine .. 'C' sprintf(buffer,format,arg1,arg2,..,argn) ..  called in 'C' style
     105                                ;
     106                                ;	call:	mov	argN,-(sp)
     107                                ;		...
     108                                ;		mov	arg2,-(sp)
     109                                ;		mov	arg1,-(sp)
     110                                ;		mov	format,-(sp)
     111                                ;		mov	buffer,-(sp)
     112                                ;		call	sprintf
     113                                ;		add	#2*N,sp
     114                                ;
     115 004630 010046                  sprintf::mov	r0,-(sp)		; save reg
     116 004632 010146                  	mov	r1,-(sp)		;
     117 004634 010246                  	mov	r2,-(sp)		;
     118 004636 010346                  	mov	r3,-(sp)		;
     119 004640 010446                  	mov	r4,-(sp)		;
     120 004642 010546                  	mov	r5,-(sp)		;
     121                                	
     122 004644 010605                  	mov	sp,r5			; frame pointer
     123 004646 162706  000014          	sub	#n.last,sp		; reserve space on stack
     124                                	
     125 004652 010504                  	mov	r5,r4			; get frame ptr
     126 004654 062704  000016          	add	#n.args,r4		; offset to first argument
     127                                	
     128 004660 012765  004674  177766  	mov	#1$,p.out(r5)		; character output routine
     129 004666 012465  177764          	mov	(r4)+,p.ptr(r5)		; init bufptr from argument
     130                                	
     131 004672 000412                  	br	xprintf			; continue
     132                                
     133                                	; ---------------------------------------------------------
     134                                	
     135                                	; character output to buffer
     136                                	
     137 004674 110075  177764          1$:	movb	r0,@p.ptr(r5)		; store character
     138 004700 005265  177764          	inc	p.ptr(r5)		; bump pointer
     139 004704 105075  177764          	clrb	@p.ptr(r5)		; null terminate
     140 004710 016565  177764  000012  	mov	p.ptr(r5),p.sr0(r5)	; return updated ptr in saved r0
     141 004716                         	return				; return
       1 004716 000207                  	rts	pc
     142                                	
     143                                ; --------------------------------------------------------------------------------
     144                                
     145                                	; process main format
     146                                
     147 004720 012403                  xprintf:mov	(r4)+,r3		; prime format string pointer
     148                                
     149 004722                         1$:	call	900$			; get next format character
       1 004722 004737  005632          	jsr	pc,900$
     150 004726 120227  000045          	cmpb	r2,#<'%>		; hit a format flag?
     151 004732 001430                  	beq	10$			; yes, go process
     152 004734 120227  000134          	cmpb	r2,#<'\>		; hit an escape flag?
     153 004740 001404                  	beq	3$			; yes, go process
     154 004742 010200                  2$:	mov	r2,r0			; char to print
     155 004744                         	call	@p.out(r5)		; no, just print it
       1 004744 004775  177766          	jsr	pc,@p.out(r5)
     156 004750 000764                  	br	1$			; loop
     157                                
     158                                	; process escaped character \a .. \z
     159                                
     160 004752                         3$:	call	900$			; get the escaped character
       1 004752 004737  005632          	jsr	pc,900$
     161 004756 002771                  	blt	2$			; quick exit for [NUL-@] range
     162 004760 120227  000172          	cmpb	r2,#<'z>		;
     163 004764 003366                  	bgt	2$			; exit if [{-DEL]
     164 004766 120227  000141          	cmpb	r2,#<'a>		;
     165 004772 002005                  	bge	4$			; br if [a-z]	
     166 004774 120227  000132          	cmpb	r2,#<'Z>		;
     167 005000 003360                  	bgt	2$			; br if [[-`]
     168 005002 152702  000040          	bisb	#40,r2			; force to [a-z] range
     169 005006 116202  005527          4$:	movb	1000$-<'a>(r2),r2	; translate a..z to escaped
     170 005012 000753                  	br	2$			; go print
     171                                
     172                                	; process format flag %[-+]?(0?\d+([.]\d+)?)?[lh]?[iduscpxo]
     173                                
     174 005014 112765  000040  177776  10$:	movb	#<' >,p.fil(r5)		; blank fill
     175 005022 105065  177777          	clrb	p.flg(r5)		; clear flags
     176 005026 005065  177774          	clr	p.wid(r5)		; init width spec
     177 005032 005065  177772          	clr	p.pre(r5)		; init precision spec
     178 005036 005065  177770          	clr	p.len(r5)		; no digits yet
     179                                
     180 005042                         11$:	call	900$			; get next format character
       1 005042 004737  005632          	jsr	pc,900$
     181 005046 002045                  	bge	40$			; br if [A-DEL]
     182 005050 120227  000045          	cmpb	r2,#<'%>		; check for '%'
     183 005054 001732                  	beq	2$			; br if yes
     184                                
     185                                	; some character in range [NUL-@]
     186                                
     187 005056 120227  000055          	cmpb	r2,#<'->		; check for '-'
     188 005062 001004                  	bne	12$			; br if not
     189 005064 152765  000001  177777  	bisb	#pf.ljus,p.flg(r5)	; yes, set a flag
     190 005072 000763                  	br	11$			; loop
     191 005074 120227  000053          12$:	cmpb	r2,#<'+>		; check for '+'
     192 005100 001004                  	bne	13$			; br if not
     193 005102 152765  000002  177777  	bisb	#pf.sign,p.flg(r5)	; yes, set a flag
     194 005110 000754                  	br	11$			; loop
     195 005112 120227  000043          13$:	cmpb	r2,#<'#>		; check for '#'
     196 005116 001004                  	bne	20$			; br if not
     197 005120 152765  000004  177777  	bisb	#pf.altr,p.flg(r5)	; yes, set a flag
     198 005126 000745                  	br	11$			; loop
     199                                
     200 005130                         20$:	call	800$			; get a number if present
       1 005130 004737  005536          	jsr	pc,800$
     201 005134 010165  177774          	mov	r1,p.wid(r5)		; save number as width
     202                                
     203 005140 120227  000056          	cmpb	r2,#<'.>		; check for .
     204 005144 001006                  	bne	40$			; br if not, should be alpha
     205 005146                         	call	900$			; get next character
       1 005146 004737  005632          	jsr	pc,900$
     206                                
     207 005152                         	call	800$			; get a number if present
       1 005152 004737  005536          	jsr	pc,800$
     208 005156 010165  177772          	mov	r1,p.pre(r5)		; save number as precision
     209                                
     210                                	; flag is in range [A-Za-z]
     211                                
     212 005162 005000                  40$:	clr	r0			; zap numerics
     213 005164 005001                  	clr	r1			;
     214 005166 120227  000101          41$:	cmpb	r2,#<'A>		; check for [:-@]
     215 005172 002663                  	blt	2$			; br if yes
     216 005174 120227  000172          	cmpb	r2,#<'z>		; check for [{-DEL]
     217 005200 003260                  	bgt	2$			; br if yes
     218 005202 120227  000141          	cmpb	r2,#<'a>		; check for [a-z]
     219 005206 002003                  	bge	42$			; br if yes
     220 005210 120227  000132          	cmpb	r2,#<'Z>		; check for [A-Z]
     221 005214 003252                  	bgt	2$			; br if no
     222 005216 042702  000040          42$:	bic	#40,r2			; force to [a-z] to [A-Z] range
     223 005222 012401                  	mov	(r4)+,r1		; get the next value as lsb
     224 005224 006302                  	asl	r2			; char*2 for word offset
     225 005226 000172  005030          	jmp	@400$-<2*'A>(r2)	; dispatch
     226                                
     227                                400$:	;----	aaaa,bbbb,cccc,dddd,eeee,ffff,gggg,hhhh,iiii,jjjj,kkkk,llll,mmmm
     228 005232 005316  005522  005362  	.word	401$,470$,420$,430$,401$,401$,401$,401$,430$,401$,401$,405$,401$
         005240 005402  005316  005316  
         005246 005316  005316  005402  
         005254 005316  005316  005332  
         005262 005316                  
     229                                	;----	nnnn,oooo,pppp,qqqq,rrrr,ssss,tttt,uuuu,vvvv,wwww,xxxx,yyyy,zzzz
     230 005264 005316  005472  005472  	.word	401$,450$,450$,401$,401$,410$,401$,440$,401$,401$,460$,401$,401$
         005272 005316  005316  005350  
         005300 005316  005456  005316  
         005306 005316  005506  005316  
         005314 005316                  
     231                                
     232 005316 005744                  401$:	tst	-(r4)			; %<illegal>: backup argument pointer
     233 005320 005002                  	clr	r2			; zap
     234 005322 156302  177777          	bisb	-1(r3),r2		; retrieve last character
     235 005326 000137  004742          	jmp	2$			; just go print
     236                                
     237 005332                         405$:	call	900$			; %l: get next character
       1 005332 004737  005632          	jsr	pc,900$
     238 005336 152765  000010  177777  	bisb	#pf.long,p.flg(r5)	; indicate longword value
     239 005344 010100                  	mov	r1,r0			; copy 1st arg to msb
     240 005346 000707                  	br	41$			; and go parse next flag
     241                                
     242 005350 010102                  410$:	mov	r1,r2			; %s: get next arg as string address
     243 005352                         	call	prtstr			; print as a string
       1 005352 004737  006272          	jsr	pc,prtstr
     244 005356 000137  004722          	jmp	1$			; continue at the top
     245                                
     246 005362 005046                  420$:	clr	-(sp)			; %c: zap upper byte
     247 005364 110116                  	movb	r1,(sp)			; insert the character
     248 005366 010602                  	mov	sp,r2			; point at string
     249 005370                         	call	prtstr			; print as a string
       1 005370 004737  006272          	jsr	pc,prtstr
     250 005374 005726                  	tst	(sp)+			; flush temp string
     251 005376 000137  004722          	jmp	1$			; continue at the top
     252                                
     253 005402 012702  000012          430$:	mov	#10.,r2			; %d,%i: decimal radix
     254 005406 132765  000010  177777  	bitb	#pf.long,p.flg(r5)	; longword value?
     255 005414 001004                  	bne	431$			; br if yes
     256 005416 005000                  	clr	r0			; zap
     257 005420 005701                  	tst	r1			; no; test lsb sign
     258 005422 100001                  	bpl	431$			; br if plus/zero
     259 005424 005100                  	com	r0			; extend -1 to msb
     260 005426 005700                  431$:	tst	r0			; test msb sign
     261 005430 002006                  	bge	439$			; br if zero or positive
     262 005432 005400                  	neg	r0			; negative; make positive
     263 005434 005401                  	neg	r1			;
     264 005436 005600                  	sbc	r0			;
     265 005440 152765  000020  177777  	bisb	#pf.nega,p.flg(r5)	; set flag indicating negative
     266 005446                         439$:	call	prt32u			; print as unsigned decimal w/sign
       1 005446 004737  005722          	jsr	pc,prt32u
     267 005452 000137  004722          	jmp	1$			; continue at the top
     268                                
     269 005456 012702  000012          440$:	mov	#10.,r2			; %u: decimal radix
     270 005462                         	call	prt32u			; print as an unsigned decimal
       1 005462 004737  005722          	jsr	pc,prt32u
     271 005466 000137  004722          	jmp	1$			; continue at the top
     272                                
     273 005472 012702  000010          450$:	mov	#8.,r2			; %o,%p: octal radix
     274 005476                         	call	prt32u			; print as an unsigned hex
       1 005476 004737  005722          	jsr	pc,prt32u
     275 005502 000137  004722          	jmp	1$			; continue at the top
     276                                
     277 005506 012702  000020          460$:	mov	#16.,r2			; %x: hexadecimal radix
     278 005512                         	call	prt32u			; print as an unsigned hex
       1 005512 004737  005722          	jsr	pc,prt32u
     279 005516 000137  004722          	jmp	1$			; continue at the top
     280                                
     281 005522 012702  000002          470$:	mov	#2.,r2			; %b: binary radix
     282 005526                         	call	prt32u			; print as an unsigned binary
       1 005526 004737  005722          	jsr	pc,prt32u
     283 005532 000137  004722          	jmp	1$			; continue at the top
     284                                
     285                                	; ---------------------------------------------------------
     286                                	; get a number as '[0-9]+' or '*'
     287                                
     288 005536 120227  000052          800$:	cmpb	r2,#<'*>		; check for '*' indirection
     289 005542 001427                  	beq	880$			; br if yes
     290 005544 120227  000060          	cmpb	r2,#<'0>		; check for leading '0' character
     291 005550 001002                  	bne	810$			; br if not
     292 005552 110265  177776          	movb	r2,p.fil(r5)		; yes, set a flag
     293 005556 005001                  810$:	clr	r1			; number accumulated here
     294 005560 120227  000060          820$:	cmpb	r2,#<'0>		; check for '0'
     295 005564 002421                  	blt	890$			; br if less that a '0'
     296 005566 120227  000071          	cmpb	r2,#<'9>		; check for '9'
     297 005572 003016                  	bgt	890$			; br if greater than '9'
     298 005574 162702  000060          	sub	#<'0>,r2		; offset to range 0..9
     299 005600 006301                  	asl	r1			; number *= 2.
     300 005602 010100                  	mov	r1,r0			; (number*2.)
     301 005604 006300                  	asl	r0			; (number*4.)
     302 005606 006300                  	asl	r0			; (number*8.)
     303 005610 060001                  	add	r0,r1			; number = number*8. + number*2.
     304 005612 060201                  	add	r2,r1			; add in this digit
     305 005614                         	call	900$			; get next format character
       1 005614 004737  005632          	jsr	pc,900$
     306 005620 000757                  	br	820$			; and loop
     307 005622 012401                  880$:	mov	(r4)+,r1		; get next arg as number
     308 005624                         	call	900$			; get next character
       1 005624 004737  005632          	jsr	pc,900$
     309 005630                         890$:	return				; return
       1 005630 000207                  	rts	pc
     310                                
     311                                	; ---------------------------------------------------------
     312                                	; get next character (or exit) routine; result in r2
     313                                
     314 005632 112302                  900$:	movb	(r3)+,r2		; get next format character
     315 005634 042702  177600          	bic	#^c177,r2		; 7bit ascii only
     316 005640 001403                  	beq	990$			; end of string seen
     317 005642 120227  000101          	cmpb	r2,#<'A>		; check for [A-DEL]
     318 005646                         	return				; leave CC set with result
       1 005646 000207                  	rts	pc
     319                                
     320 005650 010506                  990$:	mov	r5,sp			; flush frame
     321 005652 012605                  	mov	(sp)+,r5		; restore reg
     322 005654 012604                  	mov	(sp)+,r4		;
     323 005656 012603                  	mov	(sp)+,r3		;
     324 005660 012602                  	mov	(sp)+,r2		;
     325 005662 012601                  	mov	(sp)+,r1		;
     326 005664 012600                  	mov	(sp)+,r0		;
     327 005666                         	return				; return
       1 005666 000207                  	rts	pc
     328                                
     329                                	; ---------------------------------------------------------
     330                                	; escaped character table
     331                                1000$:	;	aaa bbb ccc ddd eee fff ggg hhh iii jjj kkk lll mmm
     332                                	;	BEL  BS         ESC  FF
     333 005670    007     010     143  	.byte	007,010,143,144,033,014,147,150,151,152,153,154,155
         005673    144     033     014  
         005676    147     150     151  
         005701    152     153     154  
         005704    155                  
     334                                	;	nnn ooo ppp qqq rrr sss ttt uuu vvv www xxx yyy zzz
     335                                	;	 LF              CR      HT      VT
     336 005705    012     157     160  	.byte	012,157,160,161,015,163,011,165,013,167,170,172,172
         005710    161     015     163  
         005713    011     165     013  
         005716    167     170     172  
         005721    172                  
     337                                	; ---------------------------------------------------------
     338                                
     339                                ; --------------------------------------------------------------------------------
     340                                ;
     341                                ; digit print routine .. print a 32b value as unsigned digits
     342                                ;
     343                                ;	call:	mov	datahi,r0
     344                                ;		mov	datalo,r1
     345                                ;		mov	#radix,r2 ; 2. or 8. or 10. or 16.
     346                                ;		call	prt32u
     347                                ;
     348                                ;		r0 - data msb      (not saved)
     349                                ;		r1 - data lsb      (not saved)
     350                                ;		r2 - radix         (not saved)
     351                                ;		r3 - ptr to format     (saved)
     352                                ;		r4 - ptr to arglist    (saved) [input not used]
     353                                ;		r5 - ptr to flags      (saved)
     354                                ;
     355 005722 010346                  prt32u:	mov	r3,-(sp)		; save regs we use
     356 005724 010446                  	mov	r4,-(sp)		;
     357                                
     358                                	; render all the digits onto the stack (lsd first, msd last)
     359                                
     360 005726 005046                  	clr	-(sp)			; zero flag
     361 005730 010246                  1$:	mov	r2,-(sp)		; radix lsb
     362 005732 005046                  	clr	-(sp)			;   and msb
     363 005734 010146                  	mov	r1,-(sp)		; number lsb
     364 005736 010046                  	mov	r0,-(sp)		;    and msb
     365 005740                         	call	uldiv			; get quo and rem
       1 005740 004737  006540          	jsr	pc,uldiv
     366 005744 016602  000006          	mov	6.(sp),r2		; restore radix from stack
     367 005750 062706  000010          	add	#8.,sp			; flush args
     368 005754 062703  000060          	add	#<'0>,r3		; make rem lsb a digit
     369 005760 020327  000071          	cmp	r3,#<'9>		; still a valid digit?
     370 005764 003402                  	ble	2$			; br if yes
     371 005766 062703  000007          	add	#<'A>-<':>,r3		; offset to 'A...'Z range
     372 005772 010346                  2$:	mov	r3,-(sp)		; save
     373 005774 005265  177770          	inc	p.len(r5)		; count digits
     374 006000 005701                  	tst	r1			; any lsb left?
     375 006002 001352                  	bne	1$			; br if yes
     376 006004 005700                  	tst	r0			; any msb left?
     377 006006 001350                  	bne	1$			; br if yes
     378                                
     379                                	; check if we generated the minimum number of digits requested
     380                                
     381 006010 026565  177770  177772  10$:	cmp	p.len(r5),p.pre(r5)	; compare length to precision
     382 006016 103005                  	bhis	20$			; br we're OK
     383 006020 012746  000060          	mov	#<'0>,-(sp)		; nope, add another digit
     384 006024 005265  177770          	inc	p.len(r5)		; count digits
     385 006030 000767                  	br	10$			; and loop	
     386                                
     387                                	; check for options (#) flag
     388                                
     389 006032 132765  000004  177777  20$:	bitb	#pf.altf,p.flg(r5)	; check for options flag
     390 006040 001422                  	beq	30$			; br if not set
     391 006042 020227  000020          	cmp	r2,#16.			; radix 16?
     392 006046 001407                  	beq	21$			; br if yes
     393 006050 020227  000010          	cmp	r2,#8.			; radix 8?
     394 006054 001014                  	bne	30$			; br if not
     395 006056 022716  000060          	cmp	#<'0>,(sp)		; first digit already zero?
     396 006062 001411                  	beq	30$			; yes, no need to add
     397 006064 000404                  	br	22$			; no, add a leading zero
     398 006066 012746  000170          21$:	mov	#<'x>,-(sp)		; add a '0x' prefix
     399 006072 005265  177770          	inc	p.len(r5)		; count it
     400 006076 012746  000060          22$:	mov	#<'0>,-(sp)		;
     401 006102 005265  177770          	inc	p.len(r5)		; count it
     402                                
     403                                	; check if we need a sign (+/-/none)
     404                                
     405 006106 132765  000020  177777  30$:	bitb	#pf.nega,p.flg(r5)	; was original value negative?
     406 006114 001403                  	beq	31$			; br if not
     407 006116 012746  000055          	mov	#<'->,-(sp)		; minus sign
     408 006122 000406                  	br	32$			;
     409 006124 132765  000002  177777  31$:	bitb	#pf.sign,p.flg(r5)	; sign always requested?
     410 006132 001404                  	beq	50$			; br if not
     411 006134 012746  000053          	mov	#<'+>,-(sp)		; plus sign
     412 006140 005265  177770          32$:	inc	p.len(r5)		; count all chars generated
     413                                
     414                                	; processing for right justification
     415                                
     416 006144 132765  000001  177777  50$:	bitb	#pf.ljus,p.flg(r5)	; check left-justify flag
     417 006152 001020                  	bne	70$			; br if left justified
     418 006154 116501  177776          	movb	p.fil(r5),r1		; get fill character
     419 006160 026565  177770  177774  51$:	cmp	p.len(r5),p.wid(r5)	; compare length to width
     420 006166 103012                  	bhis	70$			; br if we're OK
     421 006170 011600                  	mov	(sp),r0			; copy last character
     422 006172 010146                  	mov	r1,-(sp)		; add a fill character
     423 006174 020100                  	cmp	r1,r0			; check fill/last char order
     424 006176 101403                  	blos	52$			; br if order OK
     425 006200 010016                  	mov	r0,(sp)			; copy sign/last char
     426 006202 010166  000002          	mov	r1,2(sp)		; insert fill after sign
     427 006206 005265  177770          52$:	inc	p.len(r5)		; count it
     428 006212 000762                  	br	51$			; loop
     429                                
     430                                	; print all digits in order (sign..msd..lsd)
     431                                
     432 006214 005001                  70$:	clr	r1			; count characters output
     433 006216 012600                  71$:	mov	(sp)+,r0		; get a digit
     434 006220 001404                  	beq	80$			; br if no more
     435 006222                         	call	@p.out(r5)		; print it
       1 006222 004775  177766          	jsr	pc,@p.out(r5)
     436 006226 005201                  	inc	r1			; count it
     437 006230 000772                  	br	71$			; loop
     438                                
     439                                	; processing for left justification
     440                                
     441 006232 132765  000001  177777  80$:	bitb	#pf.ljus,p.flg(r5)	; check left-justify flag
     442 006240 001411                  	beq	90$			; br if is right justified
     443 006242 012700  000040          	mov	#<' >,r0		; space fill on right
     444 006246 020165  177774          81$:	cmp	r1,p.wid(r5)		; compare length to width
     445 006252 103004                  	bhis	90$			; br we're OK
     446 006254                         	call	@p.out(r5)		; print it
       1 006254 004775  177766          	jsr	pc,@p.out(r5)
     447 006260 005201                  	inc	r1			; count characters
     448 006262 000771                  	br	81$			; and loop	
     449                                
     450                                	; and done
     451                                
     452 006264 012604                  90$:	mov	(sp)+,r4		; restore regs
     453 006266 012603                  	mov	(sp)+,r3		;
     454 006270                         	return				; return
       1 006270 000207                  	rts	pc
     455                                
     456                                ; --------------------------------------------------------------------------------
     457                                ;
     458                                ; asciz string print routine
     459                                ;
     460                                ;	call:	mov	#strptr,r2
     461                                ;		call	prtstr
     462                                ;
     463                                ;		r0 - temp          (not saved)
     464                                ;		r1 - temp          (not saved)
     465                                ;		r2 - ptr to string (not saved)
     466                                ;		r3 - ptr to format     (saved) [input not used]
     467                                ;		r4 - ptr to arglist    (saved) [input not used]
     468                                ;		r5 - ptr to flags      (saved)
     469                                ;
     470 006272 010346                  prtstr:	mov	r3,-(sp)		; save regs
     471 006274 010446                  	mov	r4,-(sp)		;
     472                                
     473                                	; compute length of string
     474                                
     475 006276 010203                  	mov	r2,r3			; copy ptr to string
     476 006300 105723                  1$:	tstb	(r3)+			; check a byte
     477 006302 001376                  	bne	1$			; br if more string
     478 006304 160203                  	sub	r2,r3			; compute length
     479 006306 005303                  	dec	r3			; minus the trailing null	
     480                                
     481                                	; set precision to length if precision is zero
     482                                
     483 006310 005765  177772          	tst	p.pre(r5)		; check requested precision
     484 006314 001002                  	bne	20$			; br if nonzero
     485 006316 010365  177772          	mov	r3,p.pre(r5)		; else set to string length
     486 006322 020365  177772          20$:	cmp	r3,p.pre(r5)		; compare actual length to precision
     487 006326 101402                  	blos	50$			; br if actual <= precision
     488 006330 016503  177772          	mov	p.pre(r5),r3		; else set actual to precision
     489                                
     490                                	; processing for right justification
     491                                
     492 006334 132765  000001  177777  50$:	bitb	#pf.ljus,p.flg(r5)	; check left-justify flag
     493 006342 001002                  	bne	70$			; br if left justified
     494 006344                         	call	100$			; do fill
       1 006344 004737  006412          	jsr	pc,100$
     495                                
     496                                	; print string 
     497                                
     498 006350 010301                  70$:	mov	r3,r1			; copy length
     499 006352 001406                  	beq	80$			; br if no characters
     500 006354 112200                  71$:	movb	(r2)+,r0		; get a character
     501 006356 001404                  	beq	80$			; br if no characters
     502 006360                         	call	@p.out(r5)		; print it
       1 006360 004775  177766          	jsr	pc,@p.out(r5)
     503 006364 005301                  	dec	r1			; count
     504 006366 001372                  	bne	71$			; loop
     505                                
     506                                	; processing for left justification
     507                                
     508 006370 132765  000001  177777  80$:	bitb	#pf.ljus,p.flg(r5)	; check left-justify flag
     509 006376 001402                  	beq	90$			; br if is right justified
     510 006400                         	call	100$			; do fill
       1 006400 004737  006412          	jsr	pc,100$
     511                                
     512                                	; and done
     513                                
     514 006404 012604                  90$:	mov	(sp)+,r4		; restore
     515 006406 012603                  	mov	(sp)+,r3		;
     516 006410                         	return				; return
       1 006410 000207                  	rts	pc
     517                                
     518                                	; ----------------------------------------------------
     519                                	; generate fill characters
     520                                
     521 006412 016501  177774          100$:	mov	p.wid(r5),r1		; requested width
     522 006416 160301                  	sub	r3,r1			; subtract string width
     523 006420 101406                  	blos	102$			; br if no fill needed
     524 006422 116500  177776          	movb	p.fil(r5),r0		; get fill character
     525 006426                         101$:	call	@p.out(r5)		; print a fill character
       1 006426 004775  177766          	jsr	pc,@p.out(r5)
     526 006432 005301                  	dec	r1			; count
     527 006434 001374                  	bne	101$			; loop
     528 006436                         102$:	return				; done
       1 006436 000207                  	rts	pc
     529                                
     530                                ; --------------------------------------------------------------------------------
     531                                
     532                                .include "mac/muldiv.mac"
       1                                ;=================================================================================
       2                                ; muldiv.mac - 32b mul/div routines for macro11 diagnostics
       3                                ; (C) 2009-2016 Donald North. All rights reserved.
       4                                ;=================================================================================
       5                                
       6                                ; --------------------------------------------------------------------------------
       7                                ;
       8                                ; unsigned 32b * 32b => 32b multiplication
       9                                ; 
      10                                ; from the 2.9BSD stdio C lib, using simple shift/add algorithm
      11                                ; 
      12                                ;	call:	mov	#b.lo,-(sp)
      13                                ;		mov	#b.hi,-(sp)
      14                                ;		mov	#a.lo,-(sp)
      15                                ;		mov	#a.hi,-(sp)
      16                                ;		call	ulmul
      17                                ;		add	#8.,sp
      18                                ;		mov	r1,q.lo
      19                                ;		mov	r0,q.hi
      20                                ;
      21 006440 010246                  ulmul::	mov	r2,-(sp)		; save
      22 006442 010346                  	mov	r3,-(sp)		;
      23 006444 010446                  	mov	r4,-(sp)		;
      24 006446 010546                  	mov	r5,-(sp)		;
      25                                
      26 006450 016605  000020          	mov	8.+8.(sp),r5		; b.lo
      27 006454 016604  000016          	mov	6.+8.(sp),r4		; b.hi
      28 006460 016603  000014          	mov	4.+8.(sp),r3		; a.lo
      29 006464 016602  000012          	mov	2.+8.(sp),r2		; a.hi
      30 006470 005001                  	clr	r1			; q.lo
      31 006472 005000                  	clr	r0			; q.hi
      32                                
      33 006474 000241                  1$:	clc				; shiftin zeroes
      34 006476 006004                  	ror	r4			; shift multiplier right one
      35 006500 006005                  	ror	r5			;
      36 006502 103003                  	bcc	2$			; br if shifted out a zero
      37 006504 060301                  	add	r3,r1			; else add multiplicand to product
      38 006506 005500                  	adc	r0			; propagate C
      39 006510 060200                  	add	r2,r0			;
      40 006512 006303                  2$:	asl	r3			; shift multiplicant left one
      41 006514 006102                  	rol	r2			;
      42 006516 005704                  	tst	r4			; any high multiplier bits left?
      43 006520 001365                  	bne	1$			; br if yes
      44 006522 005705                  	tst	r5			; any low multiplier bits left?
      45 006524 001363                  	bne	1$			; br if yes
      46                                
      47 006526 012605                  	mov	(sp)+,r5		; restore
      48 006530 012604                  	mov	(sp)+,r4		;
      49 006532 012603                  	mov	(sp)+,r3		;
      50 006534 012602                  	mov	(sp)+,r2		;
      51 006536                         	return				; done
       1 006536 000207                  	rts	pc
      52                                
      53                                ; --------------------------------------------------------------------------------
      54                                ;
      55                                ; unsigned 32b / 32b => 32b, 32b division with remainder
      56                                ; 
      57                                ; from Hennessey & Patterson Appendix A
      58                                ;
      59                                ;	call:	mov	#den.lo,-(sp)	; 8.(sp)
      60                                ;		mov	#den.hi,-(sp)	; 6.(sp)
      61                                ;		mov	#num.lo,-(sp)	; 4.(sp)
      62                                ;		mov	#num.hi,-(sp)	; 2.(sp)
      63                                ;		call	uldiv
      64                                ;		add	#8.,sp
      65                                ;		mov	r3,rem.lo
      66                                ;		mov	r2,rem.hi
      67                                ;		mov	r1,quo.lo
      68                                ;		mov	r0,quo.hi
      69                                ;
      70 006540 010446                  uldiv::	mov	r4,-(sp)		; save
      71 006542 010546                  	mov	r5,-(sp)		;
      72                                
      73 006544 016601  000010          	mov	4.+4.(sp),r1		; num.lo
      74 006550 016600  000006          	mov	2.+4.(sp),r0		; num.hi
      75                                
      76 006554 005005                  	clr	r5			; tmp.lo
      77 006556 005004                  	clr	r4			; tmp.hi
      78                                
      79 006560 012746  000037          	mov	#31.,-(sp)		; bit count
      80                                
      81 006564 006301                  1$:	asl	r1			; (tmp,num) <<= 1
      82 006566 006100                  	rol	r0			;
      83 006570 006105                  	rol	r5			;
      84 006572 006104                  	rol	r4			;
      85                                
      86 006574 010503                  	mov	r5,r3			; rem = tmp - den
      87 006576 010402                  	mov	r4,r2			;
      88 006600 166603  000016          	sub	8.+6.(sp),r3		;
      89 006604 005602                  	sbc	r2			;
      90 006606 166602  000014          	sub	6.+6.(sp),r2		;
      91                                
      92 006612 100403                  	bmi	2$			; br if rem < 0
      93                                
      94 006614 005201                  	inc	r1			; quo |= 1
      95 006616 010305                  	mov	r3,r5			; tmp = rem
      96 006620 010204                  	mov	r2,r4			;
      97                                
      98 006622 005316                  2$:	dec	(sp)			; count bits
      99 006624 002357                  	bge	1$			; loop if more
     100 006626 005726                  	tst	(sp)+			; flush counter
     101                                
     102 006630 005702                  	tst	r2			; test for rem < 0
     103 006632 002005                  	bge	3$			; br if not
     104                                
     105 006634 066603  000014          	add	8.+4.(sp),r3		; rem += den correction
     106 006640 005502                  	adc	r2			;
     107 006642 066602  000012          	add	6.+4.(sp),r2		;
     108                                
     109 006646 012605                  3$:	mov	(sp)+,r5		; restore
     110 006650 012604                  	mov	(sp)+,r4		;
     111 006652                         	return				; done
       1 006652 000207                  	rts	pc
     112                                
     113                                ; --------------------------------------------------------------------------------
     114                                ;
     115                                ; signed 32b / 32b => 32b, 32b division with remainder
     116                                ; 
     117                                ;	call:	mov	#den.lo,-(sp)	; 8.(sp)
     118                                ;		mov	#den.hi,-(sp)	; 6.(sp)
     119                                ;		mov	#num.lo,-(sp)	; 4.(sp)
     120                                ;		mov	#num.hi,-(sp)	; 2.(sp)
     121                                ;		call	sldiv
     122                                ;		add	#8.,sp
     123                                ;		mov	r3,rem.lo
     124                                ;		mov	r2,rem.hi
     125                                ;		mov	r1,quo.lo
     126                                ;		mov	r0,quo.hi
     127                                ;
     128 006654 010446                  sldiv::	mov	r4,-(sp)		; save
     129                                
     130 006656 016603  000012          	mov	8.+2.(sp),r3		; den.lo
     131 006662 016602  000010          	mov	6.+2.(sp),r2		; den.hi
     132 006666 016601  000006          	mov	4.+2.(sp),r1		; num.lo
     133 006672 016600  000004          	mov	2.+2.(sp),r0		; num.hi
     134                                
     135 006676 005004                  	clr	r4			; pos
     136                                
     137 006700 005700                  	tst	r0			; num sign
     138 006702 002006                  	bge	10$			; br if pos
     139                                
     140 006704 005104                  	com	r4			; neg
     141                                
     142 006706 005101                  	com	r1			; negate num
     143 006710 005100                  	com	r0			;
     144 006712 062701  000001          	add	#1,r1			;
     145 006716 005500                  	adc	r0			; 
     146                                
     147 006720 005702                  10$:	tst	r2			; den sign
     148 006722 002006                  	bge	20$			; br if pos
     149                                
     150 006724 105104                  	comb	r4			; neg
     151                                
     152 006726 005103                  	com	r3			; negate den
     153 006730 005102                  	com	r2			;
     154 006732 062703  000001          	add	#1,r3			;
     155 006736 005502                  	adc	r2			; 
     156                                	
     157 006740 010346                  20$:	mov	r3,-(sp)		; den.lo
     158 006742 010246                  	mov	r2,-(sp)		; den.hi
     159 006744 010146                  	mov	r1,-(sp)		; num.lo
     160 006746 010046                  	mov	r0,-(sp)		; num.hi
     161 006750                         	call	uldiv			;
       1 006750 004737  006540          	jsr	pc,uldiv
     162 006754 062706  000010          	add	#8.,sp			; 
     163                                
     164 006760 005704                  	tst	r4			; invert result
     165 006762 002005                  	bge	30$			;
     166                                
     167 006764 005103                   	com	r3			; negate rem
     168 006766 005102                  	com	r2			;
     169 006770 062703  000001          	add	#1,r3			;
     170 006774 005502                  	adc	r2			; 
     171                                
     172 006776 105704                  30$:	tstb	r4			; invert result
     173 007000 002005                  	bge	40$			;
     174                                
     175 007002 005101                  	com	r1			; negate quo
     176 007004 005100                  	com	r0			;
     177 007006 062701  000001          	add	#1,r1			;
     178 007012 005500                  	adc	r0			; 
     179                                
     180 007014 012604                  40$:	mov	(sp)+,r4		; restore
     181 007016                         	return				; done
       1 007016 000207                  	rts	pc
     182                                
     183                                ;================================================================================
     184                                ; end of muldiv.mac
     185                                ;================================================================================
     185                                
     533                                
     534                                ; --------------------------------------------------------------------------------
     535                                
     536        000000                  .iif ne,pf.sep,	.end
     537                                
     538                                ;=================================================================================
     539                                ; end of printf.mac
     540                                ;=================================================================================
     540                                
     160                                
     161                                ; --------------------------------------------------------------------------------
     162                                
     163                                .end
     163                                


Symbol table

$$NUM  =000002           21$6   =006066   L       501$1  =004224   L       BIT09  =001000           P.PTR  =177764           
$$POS  =000200           22$6   =006076   L       51$6   =006160   L       BIT1   =000002           P.SR0  =000012           
$ENDAD =004512           3$5    =004752   L       52$6   =006206   L       BIT10  =002000           P.SR1  =000010           
$SAV42 =002002           3$9    =006646   L       70$6   =006214   L       BIT11  =004000           P.SR2  =000006           
.      =******           30$10  =006776   L       70$7   =006350   L       BIT12  =010000           P.SR3  =000004           
1$3    =004614   L       30$6   =006106   L       71$6   =006216   L       BIT13  =020000           P.SR4  =000002           
1$4    =004674   L       31$6   =006124   L       71$7   =006354   L       BIT14  =040000           P.SR5  =000000           
1$5    =004722   L       32$6   =006140   L       710$1  =004224   L       BIT15  =100000           P.WID  =177774           
1$6    =005730   L       32768$0=002220   L       711$1  =004362   L       BIT2   =000004           PASSES =002004           
1$7    =006300   L       32769$0=002226   L       712$1  =004422   L       BIT3   =000010           PF.ALT =000004           
1$8    =006474   L       32770$0=002244   L       80$6   =006232   L       BIT4   =000020           PF.LJU =000001           
1$9    =006564   L       32771$0=002256   L       80$7   =006370   L       BIT5   =000040           PF.LON =000010           
10$10  =006720   L       4$5    =005006   L       800$5  =005536   L       BIT6   =000100           PF.NEG =000020           
10$2   =004530   L       40$10  =007014   L       81$6   =006246   L       BIT7   =000200           PF.SEP =000000           
10$5   =005014   L       40$5   =005162   L       810$5  =005556   L       BIT8   =000400           PF.SIG =000002           
10$6   =006010   L       400$5  =005232   L       820$5  =005560   L       BIT9   =001000           PRINTF =004550 G         
100$1  =002320   L       401$5  =005316   L       880$5  =005622   L       CONSOL =165144 G         PRT32U =005722           
100$7  =006412   L       405$5  =005332   L       890$5  =005630   L       CR     =000015           PRTSTR =006272           
1000$5 =005670   L       41$5   =005166   L       90$6   =006264   L       DONE   =004466           PSW    =177776 G         
101$7  =006426   L       410$5  =005350   L       90$7   =006404   L       DPYREG =177570 G         SLDIV  =006654 G         
102$7  =006436   L       42$5   =005216   L       900$5  =005632   L       LF     =000012           SPRINT =004630 G         
11$5   =005042   L       420$5  =005362   L       990$5  =005650   L       LOOP   =002300           STACK  =002000           
12$5   =005074   L       430$5  =005402   L       BIT0   =000001           MSG1   =002006           START  =002200           
13$5   =005112   L       431$5  =005426   L       BIT00  =000001           MSG2   =002046           SWIREG =177570 G         
2$5    =004742   L       439$5  =005446   L       BIT01  =000002           N.ARGS =000016           TST$NO =000001           
2$6    =005772   L       440$5  =005456   L       BIT02  =000004           N.LAST =000014           TTRBUF =177562 G         
2$8    =006512   L       450$5  =005472   L       BIT03  =000010           NOXXDP =004526           TTRCSR =177560 G         
2$9    =006622   L       460$5  =005506   L       BIT04  =000020           P.FIL  =177776           TTXBUF =177566 G         
20$10  =006740   L       470$5  =005522   L       BIT05  =000040           P.FLG  =177777           TTXCSR =177564 G         
20$5   =005130   L       50$6   =006144   L       BIT06  =000100           P.LEN  =177770           ULDIV  =006540 G         
20$6   =006032   L       50$7   =006334   L       BIT07  =000200           P.OUT  =177766           ULMUL  =006440 G         
20$7   =006322   L       500$1  =002434   L       BIT08  =000400           P.PRE  =177772           XPRINT =004720           


Program sections:

. ABS.  007020    000   (RW,I,GBL,ABS,OVR,NOSAV)
        000000    001   (RW,I,LCL,REL,CON,NOSAV)
