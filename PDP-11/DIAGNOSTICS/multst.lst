       1                                .title	MULTIPLY Instruction Test
       2                                
       3                                ; (C) 2016 Donald North. All rights reserved.
       4                                
       5                                .include "mac/stddef.mac"
       1                                ;================================================================================
       2                                ; stddef.mac - standard definitions
       3                                ; (C) 2009 Donald North. All rights reserved.
       4                                ;================================================================================
       5                                .macro	align	arg1
      16                                ;================================================================================
      17                                .macro	savreg	arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8
      28                                ;================================================================================
      29                                .macro	resreg	arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8
      40                                ;================================================================================
      41                                .macro	call	proc
      44                                .macro	return
      47                                .macro	calls	proc arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8 arg9 arg10 arg11 arg12 arg13 arg14 arg15 arg16
      67                                ;================================================================================
      68                                .macro	jeq	label ?a1
      73                                .macro	jne	label ?a1
      78                                .macro	jpl	label ?a1
      83                                .macro	jmi	label ?a1
      88                                .macro	jlo	label ?a1
      93                                .macro	jhis	label ?a1
      98                                .macro	jlos	label ?a1
     103                                .macro	jhi	label ?a1
     108                                .macro	jlt	label ?a1
     113                                .macro	jge	label ?a1
     118                                .macro	jle	label ?a1
     123                                .macro	jgt	label ?a1
     128                                .macro	jcc	label ?a1
     133                                .macro	jcs	label ?a1
     138                                .macro	jvc	label ?a1
     143                                .macro	jvs	label ?a1
     148                                ;================================================================================
     149                                .macro	printf	arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8 arg9 arg10 arg11 arg12 arg13 arg14 arg15 arg16
     152                                .macro	sprintf	arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8 arg9 arg10 arg11 arg12 arg13 arg14 arg15 arg16
     155                                ;================================================================================
     156                                .macro	ipl	lvl
     161                                ;================================================================================
     162                                .macro	trapcatcher	list ?a1 ?a2 ?a3 ?a4
     176                                ;================================================================================
     177        000001                  tst$no	= 1
     178                                .macro	test	title
     198                                ;================================================================================
     199                                ; end of stddef.mac
     200                                ;================================================================================
     200                                
       6                                
       7                                ; --------------------------------------------------------------------------------
       8                                
       9                                .sbttl	general definitions
      10                                
      11                                .include "mac/bits.mac"
       1                                ;================================================================================
       2                                ; bits.mac - standard bit definitions
       3                                ;================================================================================
       4                                
       5                                ;  system global fixed addresses
       6                                
       7        177776                  psw	==177776		; processor status word
       8                                
       9        165144                  console	==165144		; console routine start
      10                                
      11        177570                  swireg	==177570		; console switch register
      12        177570                  dpyreg	==swireg		; console display register
      13                                
      14        177560                  ttrcsr	==177560		; console serial device
      15        177562                  ttrbuf	==ttrcsr+2		;
      16        177564                  ttxcsr	==ttrcsr+4		;
      17        177566                  ttxbuf	==ttrcsr+6		;
      18                                
      19                                ; common values
      20                                
      21        000015                  cr	=015			; ascii CR
      22        000012                  lf	=012			; ascii LF
      23                                
      24        000001                  bit00	=000001			; bit positions
      25        000002                  bit01	=000002			;
      26        000004                  bit02	=000004			;
      27        000010                  bit03	=000010			;
      28        000020                  bit04	=000020			;
      29        000040                  bit05	=000040			;
      30        000100                  bit06	=000100			;
      31        000200                  bit07	=000200			;
      32        000400                  bit08	=000400			;
      33        001000                  bit09	=001000			;
      34        002000                  bit10	=002000			;
      35        004000                  bit11	=004000			;
      36        010000                  bit12	=010000			;
      37        020000                  bit13	=020000			;
      38        040000                  bit14	=040000			;
      39        100000                  bit15	=100000			;
      40                                	
      41        000001                  bit0	=bit00			; also
      42        000002                  bit1	=bit01			;
      43        000004                  bit2	=bit02			;
      44        000010                  bit3	=bit03			;
      45        000020                  bit4	=bit04			;
      46        000040                  bit5	=bit05			;
      47        000100                  bit6	=bit06			;
      48        000200                  bit7	=bit07			;
      49        000400                  bit8	=bit08			;
      50        001000                  bit9	=bit09			;
      51                                
      52                                ;================================================================================
      53                                ; end of bits.mac
      54                                ;================================================================================
      54                                
      12                                
      13                                ; --------------------------------------------------------------------------------
      14                                
      15                                .sbttl	low memory
      16                                
      17                                   	.enabl	ama			; change all mode 67 references to 37
      18                                
      19 000000                           	.asect				; absolute load image;	
      20                                
      21        000046                  	.=46
      22 000046 004040                  	.word	$endad			; address of JSR PC,(R0)
      23        000052                  	.=52
      24 000052 000000                  	.word	0			; run options
      25                                
      26        000200                  	.=200
      27 000200 000137  002200          	jmp	@#start			; standard diagnostic entry
      28                                
      29                                ; --------------------------------------------------------------------------------
      30                                
      31                                .sbttl	global variables
      32                                
      33        002000                  	.=2000
      34 002000 177777                  stack:	.word	-1			; top of stack
      35 002002 000000                  $sav42:	.word	0			; XXDP restart address
      36 002004 000000                  passes:	.word	0			; count passes
      37 002006 000000                  msgptr:	.word	0			; message pointer
      38 002010 000000                  errflg:	.word	0			; error flag
      39 002012 000000                  srcr0:	.word	0			; source registers
      40 002014 000000                  srcr1:	.word	0			; 
      41 002016 000000                  srcr2:	.word	0			;
      42 002020 000000                  expr0:	.word	0			; expected registers
      43 002022 000000                  expr1:	.word	0			; 
      44 002024 000000                  expr2:	.word	0			; 
      45 002026 000000                  expcc:	.word	0			; 
      46 002030 000000                  rcvr0:	.word	0			; expected registers
      47 002032 000000                  rcvr1:	.word	0			; 
      48 002034 000000                  rcvr2:	.word	0			; 
      49 002036 000000                  rcvcc:	.word	0			; 
      50 002040    015     012     015  msg1:	.asciz	<cr><lf><cr><lf>"Test of MULTIPLY Instruction"<cr><lf><cr><lf>
         002043    012     124     145  
         002046    163     164     040  
         002051    157     146     040  
         002054    115     125     114  
         002057    124     111     120  
         002062    114     131     040  
         002065    111     156     163  
         002070    164     162     165  
         002073    143     164     151  
         002076    157     156     015  
         002101    012     015     012  
         002104    000                  
      51 002105    015     012     107  msg2:	.asciz	<cr><lf>"Goodbye"<cr><lf>
         002110    157     157     144  
         002113    142     171     145  
         002116    015     012     000  
      52 002121    000                  	.even
      53                                
      54        000001                  prtall	=1				; 1 always print, 0 only on error
      55                                
      56                                ; --------------------------------------------------------------------------------
      57                                
      58                                .sbttl	program start
      59                                
      60 002122                         	align	7			; pc alignment
       9                                .list
      61                                
      62 002200 012706  002000          start:	mov	#stack,sp		; setup a stack
      63 002204 000005                  	reset				; reset the world
      64 002206 013737  000042  002002  	mov	@#42,$sav42		; save XXDP restart
      65                                
      66 002214                         	trapcatcher <2,200,206,400>	; setup a trapcatcher in low vector space
       1 002214 012700  002244          	mov	#32770$,r0    		; ptr to table
       2 002220 012001                  32768$:	mov	(r0)+,r1		; start addr
       3 002222 100415                  	bmi	32771$			; done?
       4 002224 012002                  	mov	(r0)+,r2		; end addr
       5 002226 010161  177776          32769$:	mov	r1,-2(r1)		; point vector at next word
       6 002232 005011                  	clr	(r1)			; <0> which is a halt
       7 002234 022121                  	cmp	(r1)+,(r1)+		; add four to ptr
       8 002236 020102                  	cmp	r1,r2			; reached end?
       9 002240 003772                  	ble	32769$			; not yet
      10 002242 000766                  	br	32768$			; more
      11 002244 000002  000200  000206  32770$:	.word	2,200,206,400, -1
         002252 000400  177777          
      12 002256 000240                  32771$:	nop				; placeholder
      67                                
      68 002260                         	printf	#msg1			; say hello
       1 002260                         	calls	printf #msg1               
       8                                .list
       9 002260 012746  002040          	mov	#msg1,-(sp)
       1                                .list
       2 002264                         	call	printf
       1 002264 004737  004250          	jsr	pc,printf
       3 002270 062706  000002          	add	#2,sp
      18                                .list
      69                                
      70 002274 005037  002004          	clr	passes			;
      71                                
      72 002300                         loop:	printf	#710$			; header
       1 002300                         	calls	printf #710$               
       8                                .list
       9 002300 012746  003246          	mov	#710$,-(sp)
       1                                .list
       2 002304                         	call	printf
       1 002304 004737  004250          	jsr	pc,printf
       3 002310 062706  000002          	add	#2,sp
      18                                .list
      73 002314 012705  002756          	mov	#500$,r5		; data table
      74                                
      75 002320 012537  002012          100$:	mov	(r5)+,srcr0		; source data
      76 002324 012537  002016          	mov	(r5)+,srcr2		;
      77 002330 013700  002012          	mov	srcr0,r0		; setup
      78 002334 013702  002016          	mov	srcr2,r2		;
      79 002340 010001                  	mov	r0,r1			;
      80 002342 074201                  	xor	r2,r1			;
      81 002344 000301                  	swab	r1			; 
      82 002346 010137  002014          	mov	r1,srcr1		; junk
      83 002352 000257                  	ccc				;
      84                                
      85 002354 070002                  	mul	r2,r0			; *** do it ***
      86                                
      87 002356 013737  177776  002036  	mov	@#psw,rcvcc		; processor status
      88 002364 042737  177760  002036  	bic	#^c17,rcvcc		; mask all except NZVC
      89                                
      90 002372 010037  002030          	mov	r0,rcvr0		; save results
      91 002376 010137  002032          	mov	r1,rcvr1		;
      92 002402 010237  002034          	mov	r2,rcvr2
      93                                
      94 002406 013700  002012          	mov	srcr0,r0		; setup
      95 002412 013701  002014          	mov	srcr1,r1		;
      96 002416 013702  002016          	mov	srcr2,r2		;
      97 002422 000257                  	ccc				; 
      98                                
      99 002424                         	call	mulply			; *** do it ***
       1 002424 004737  004076          	jsr	pc,mulply
     100                                
     101 002430 013737  177776  002026  	mov	@#psw,expcc		; processor status
     102 002436 042737  177760  002026  	bic	#^c17,expcc		; mask all except NZVC
     103                                
     104 002444 010037  002020          	mov	r0,expr0		; save results
     105 002450 010137  002022          	mov	r1,expr1		;
     106 002454 010237  002024          	mov	r2,expr2		; 
     107                                
     108 002460 005037  002010          	clr	errflg			; no error
     109 002464 012737  004002  002006  	mov	#740$,msgptr		; assume pass
     110 002472 023737  002020  002030  	cmp	expr0,rcvr0		; check results
     111 002500 001014                  	bne	150$			;
     112 002502 023737  002022  002032  	cmp	expr1,rcvr1		;
     113 002510 001010                  	bne	150$			;
     114 002512 023737  002024  002034  	cmp	expr2,rcvr2		;
     115 002520 001004                  	bne	150$			;
     116 002522 023737  002026  002036  	cmp	expcc,rcvcc		;
     117 002530 001405                  	beq	155$			;
     118 002532 012737  004007  002006  150$:	mov	#741$,msgptr		; nope, fail
     119 002540 005237  002010          	inc	errflg			; signal error
     120 002544 000240                  155$:	nop				; 
     121                                
     122        000001                  .if eq prtall
     123                                	tst	errflg			; error?
     124                                	beq	200$			; br if not
     125                                .endc
     126 002546                         	printf	#711$,srcr0,srcr1,srcr2,srcr0,srcr2       ; print source
       1 002546                         	calls	printf #711$ srcr0 srcr1 srcr2 srcr0 srcr2          
       8                                .list
       9 002546 013746  002016          	mov	srcr2,-(sp)
      14                                .list
      15 002552 013746  002012          	mov	srcr0,-(sp)
      20                                .list
      21 002556 013746  002016          	mov	srcr2,-(sp)
      26                                .list
      27 002562 013746  002014          	mov	srcr1,-(sp)
      32                                .list
      33 002566 013746  002012          	mov	srcr0,-(sp)
      38                                .list
      39 002572 012746  003702          	mov	#711$,-(sp)
       1                                .list
       2 002576                         	call	printf
       1 002576 004737  004250          	jsr	pc,printf
       3 002602 062706  000014          	add	#14,sp
      18                                .list
     127 002606                         	printf	#712$,rcvr0,rcvr1,rcvr2,rcvcc,rcvr0,rcvr1 ; print instruction result
       1 002606                         	calls	printf #712$ rcvr0 rcvr1 rcvr2 rcvcc rcvr0 rcvr1         
       8                                .list
       9 002606 013746  002032          	mov	rcvr1,-(sp)
      14                                .list
      15 002612 013746  002030          	mov	rcvr0,-(sp)
      20                                .list
      21 002616 013746  002036          	mov	rcvcc,-(sp)
      26                                .list
      27 002622 013746  002034          	mov	rcvr2,-(sp)
      32                                .list
      33 002626 013746  002032          	mov	rcvr1,-(sp)
      38                                .list
      39 002632 013746  002030          	mov	rcvr0,-(sp)
      44                                .list
      45 002636 012746  003740          	mov	#712$,-(sp)
       1                                .list
       2 002642                         	call	printf
       1 002642 004737  004250          	jsr	pc,printf
       3 002646 062706  000016          	add	#16,sp
      18                                .list
     128 002652                         	printf	#712$,expr0,expr1,expr2,expcc,expr0,expr1 ; print emulation result
       1 002652                         	calls	printf #712$ expr0 expr1 expr2 expcc expr0 expr1         
       8                                .list
       9 002652 013746  002022          	mov	expr1,-(sp)
      14                                .list
      15 002656 013746  002020          	mov	expr0,-(sp)
      20                                .list
      21 002662 013746  002026          	mov	expcc,-(sp)
      26                                .list
      27 002666 013746  002024          	mov	expr2,-(sp)
      32                                .list
      33 002672 013746  002022          	mov	expr1,-(sp)
      38                                .list
      39 002676 013746  002020          	mov	expr0,-(sp)
      44                                .list
      45 002702 012746  003740          	mov	#712$,-(sp)
       1                                .list
       2 002706                         	call	printf
       1 002706 004737  004250          	jsr	pc,printf
       3 002712 062706  000016          	add	#16,sp
      18                                .list
     129 002716                         	printf	#713$,msgptr		; print messages
       1 002716                         	calls	printf #713$ msgptr              
       8                                .list
       9 002716 013746  002006          	mov	msgptr,-(sp)
      14                                .list
      15 002722 012746  003774          	mov	#713$,-(sp)
       1                                .list
       2 002726                         	call	printf
       1 002726 004737  004250          	jsr	pc,printf
       3 002732 062706  000004          	add	#4,sp
      18                                .list
     130 002736 000240                  200$:	nop				; 
     131                                
     132 002740 020527  003246          	cmp	r5,#501$		; end of table
     133 002744                         	jne	100$
       1 002744 001402                  	beq	32768$
       2 002746 000137  002320          	jmp	100$
       3                                32768$:
     134 002752 000137  004014          	jmp	done			; all done
     135                                
     136                                	;          Arg1     Arg2
     137                                	;            R0       R2
     138 002756 000000  177777          500$:	.word	     0.,     -1.
     139 002762 177777  000000          	.word	    -1.,      0.
     140 002766 000000  000000          	.word	     0.,      0.
     141 002772 177777  177777          	.word	    -1.,     -1.
     142 002776 000003  000004          	.word	     3.,      4.
     143 003002 177775  000004          	.word	    -3.,      4.
     144 003006 000003  177774          	.word	     3.,     -4.
     145 003012 177775  177774          	.word	    -3.,     -4.
     146 003016 177777  177777          	.word	    -1.,     -1.
     147 003022 023420  023420          	.word	 10000.,  10000.
     148 003026 154360  023420          	.word	-10000.,  10000.
     149 003032 023420  154360          	.word	 10000., -10000.
     150 003036 154360  154360          	.word	-10000., -10000.
     151 003042 177777  177777          	.word	    -1.,     -1.
     152 003046 077777  077777          	.word	 32767.,  32767.
     153 003052 100000  077777          	.word	-32768.,  32767.
     154 003056 077777  100000          	.word	 32767., -32768.
     155 003062 100000  100000          	.word	-32768., -32768.
     156 003066 177777  177777          	.word	    -1.,     -1.
     157 003072 000400  000100          	.word	   256.,     64.
     158 003076 000400  000200          	.word	   256.,    128.
     159 003102 000400  000400          	.word	   256.,    256.
     160 003106 000400  001000          	.word	   256.,    512.
     161 003112 177400  000100          	.word	  -256.,     64.
     162 003116 177400  000200          	.word	  -256.,    128.
     163 003122 177400  000400          	.word	  -256.,    256.
     164 003126 177400  001000          	.word	  -256.,    512.
     165 003132 000400  177700          	.word	   256.,    -64.
     166 003136 000400  177600          	.word	   256.,   -128.
     167 003142 000400  177400          	.word	   256.,   -256.
     168 003146 000400  177000          	.word	   256.,   -512.
     169 003152 177400  177700          	.word	  -256.,    -64.
     170 003156 177400  177600          	.word	  -256.,   -128.
     171 003162 177400  177400          	.word	  -256.,   -256.
     172 003166 177400  177000          	.word	  -256.,   -512.
     173 003172 177777  177777          	.word	    -1.,     -1.
     174 003176 030071  023420          	.word	 12345.,  10000.
     175 003202 030071  001750          	.word	 12345.,   1000.
     176 003206 030071  000144          	.word	 12345.,    100.
     177 003212 030071  000012          	.word	 12345.,     10.
     178 003216 030071  000001          	.word	 12345.,      1.
     179 003222 030071  177777          	.word	 12345.,     -1.
     180 003226 030071  177766          	.word	 12345.,    -10.
     181 003232 030071  177634          	.word	 12345.,   -100.
     182 003236 030071  176030          	.word	 12345.,  -1000.
     183 003242 030071  154360          	.word	 12345., -10000.
     184                                501$:
     185                                
     186 003246    040     040     055  710$:	.ascii	"  --------------INPUT-------------------   "
         003251    055     055     055  
         003254    055     055     055  
         003257    055     055     055  
         003262    055     055     055  
         003265    055     111     116  
         003270    120     125     124  
         003273    055     055     055  
         003276    055     055     055  
         003301    055     055     055  
         003304    055     055     055  
         003307    055     055     055  
         003312    055     055     055  
         003315    055     040     040  
         003320    040                  
     187 003321    040     055     055  	.ascii	" ----------RECEIVED OUTPUT--------------"
         003324    055     055     055  
         003327    055     055     055  
         003332    055     055     122  
         003335    105     103     105  
         003340    111     126     105  
         003343    104     040     117  
         003346    125     124     120  
         003351    125     124     055  
         003354    055     055     055  
         003357    055     055     055  
         003362    055     055     055  
         003365    055     055     055  
         003370    055                  
     188 003371    040     055     055  	.ascii	" ----------EXPECTED OUTPUT--------------"
         003374    055     055     055  
         003377    055     055     055  
         003402    055     055     105  
         003405    130     120     105  
         003410    103     124     105  
         003413    104     040     117  
         003416    125     124     120  
         003421    125     124     055  
         003424    055     055     055  
         003427    055     055     055  
         003432    055     055     055  
         003435    055     055     055  
         003440    055                  
     189 003441    040     055     055  	.ascii	" ----------INFO----------"<cr><lf>
         003444    055     055     055  
         003447    055     055     055  
         003452    055     055     111  
         003455    116     106     117  
         003460    055     055     055  
         003463    055     055     055  
         003466    055     055     055  
         003471    055     015     012  
     190 003474    040     040     056  	.ascii	"  ..R0.. ..R1.. ..R2.. ..ARG1.. ..ARG2.. =>"
         003477    056     122     060  
         003502    056     056     040  
         003505    056     056     122  
         003510    061     056     056  
         003513    040     056     056  
         003516    122     062     056  
         003521    056     040     056  
         003524    056     101     122  
         003527    107     061     056  
         003532    056     040     056  
         003535    056     101     122  
         003540    107     062     056  
         003543    056     040     075  
         003546    076                  
     191 003547    040     056     056  	.ascii	" ..R0.. ..R1.. ..R2.. NZVC .....MPY....."
         003552    122     060     056  
         003555    056     040     056  
         003560    056     122     061  
         003563    056     056     040  
         003566    056     056     122  
         003571    062     056     056  
         003574    040     116     132  
         003577    126     103     040  
         003602    056     056     056  
         003605    056     056     115  
         003610    120     131     056  
         003613    056     056     056  
         003616    056                  
     192 003617    040     056     056  	.asciz	" ..R0.. ..R1.. ..R2.. NZVC .....MPY..... Notes"<cr><lf><cr><lf>
         003622    122     060     056  
         003625    056     040     056  
         003630    056     122     061  
         003633    056     056     040  
         003636    056     056     122  
         003641    062     056     056  
         003644    040     116     132  
         003647    126     103     040  
         003652    056     056     056  
         003655    056     056     115  
         003660    120     131     056  
         003663    056     056     056  
         003666    056     040     116  
         003671    157     164     145  
         003674    163     015     012  
         003677    015     012     000  
     193 003702    040     040     045  711$:	.asciz	"  %.6o %.6o %.6o %7d. %7d. =>"
         003705    056     066     157  
         003710    040     045     056  
         003713    066     157     040  
         003716    045     056     066  
         003721    157     040     045  
         003724    067     144     056  
         003727    040     045     067  
         003732    144     056     040  
         003735    075     076     000  
     194 003740    040     045     056  712$:	.asciz	" %.6o %.6o %.6o %.4b %12ld."
         003743    066     157     040  
         003746    045     056     066  
         003751    157     040     045  
         003754    056     066     157  
         003757    040     045     056  
         003762    064     142     040  
         003765    045     061     062  
         003770    154     144     056  
         003773    000                  
     195 003774    040     045     163  713$:	.asciz	" %s"<cr><lf>
         003777    015     012     000  
     196 004002    160     141     163  740$:	.asciz	"pass"
         004005    163     000          
     197 004007    106     101     111  741$:	.asciz	"FAIL"
         004012    114     000          
     198                                	.even
     199                                
     200                                ; --------------------------------------------------------------------------------
     201                                
     202 004014                         done:	printf	#msg2			; say goodbye
       1 004014                         	calls	printf #msg2               
       8                                .list
       9 004014 012746  002105          	mov	#msg2,-(sp)
       1                                .list
       2 004020                         	call	printf
       1 004020 004737  004250          	jsr	pc,printf
       3 004024 062706  000002          	add	#2,sp
      18                                .list
     203                                
     204 004030 013700  002002          	mov	$sav42,r0		; check if loaded by XXDP
     205 004034 001407                  	beq	noxxdp			; br if not
     206 004036 000005                  	reset				; yes, reset the world
     207 004040 004710                  $endad:	jsr	pc,(r0)			; return back to XXDP
     208 004042 000240                  	nop				; standard sequence
     209 004044 000240                  	nop				;
     210 004046 000240                  	nop				;
     211 004050 000137  002300          	jmp	loop			; back for more
     212                                
     213 004054 005000                  noxxdp:	clr	r0			;
     214 004056 005300                  10$:	dec	r0			; 
     215 004060 001376                  	bne	10$			; some delay
     216 004062 000005                  	reset				; zap the world
     217 004064 012746  000340          	mov	#<7>*bit5,-(sp)		; prio7 in psw
     218 004070 012746  165144          	mov	#console,-(sp)		; go there
     219 004074 000002                  	rti				; reload psw
     220                                
     221                                ; --------------------------------------------------------------------------------
     222                                ;
     223                                ; MULTIPLY instruction emulator
     224                                ;
     225                                ;	mov	arg1lo,r0
     226                                ;	mov	arg2lo,r2
     227                                ;	call	mulply
     228                                ;	mov	r0,mpyhi
     229                                ;	mov	r1,mpylo
     230                                ; 
     231 004076 010046                  mulply:	mov	r0,-(sp)		; arg1 lo
     232 004100 006746                  	sxt	-(sp)			; arg1 hi
     233 004102 010246                  	mov	r2,-(sp)		; arg2 lo
     234 004104 006746                  	sxt	-(sp)			; arg2 hi
     235 004106                         	call	ulmul			; do 32*32=>32 multiply
       1 004106 004737  006140          	jsr	pc,ulmul
     236 004112 062706  000010          	add	#8.,sp			; pop args
     237                                
     238        000000                  .if ne 0
     239                                	printf	#500$,r0,r1,r2,r3	; debug results
     240                                .endc
     241                                
     242 004116 010046                  	mov	r0,-(sp)		; hi result
     243 004120 050126                  	bis	r1,(sp)+		; or'ed with lo result
     244 004122 001427                  	beq	90$			; br if all zero
     245 004124 005700                  	tst	r0			; hi result
     246 004126 000244                  	clz				; but not zero
     247 004130 013746  177776          	mov	@#psw,-(sp)		; save
     248                                
     249 004134 020027  000000          	cmp	r0,#000000		; hi all zero?
     250 004140 100405                  	bmi	60$			; br if 100000..177777
     251 004142 003013                  	bgt	70$			; br if 000001..077777
     252 004144 020127  077777          	cmp	r1,#077777		; max positive +32767.
     253 004150 101010                  	bhi	70$			; yup
     254 004152 000411                  	br	80$			; else ok
     255                                
     256 004154 020027  177777          60$:	cmp	r0,#177777		; hi all ones?
     257 004160 001004                  	bne	70$			; br if not
     258 004162 020127  100000          	cmp	r1,#100000		; max negative -32768.
     259 004166 103401                  	blo	70$			; yup
     260 004170 000402                  	br	80$			; else ok
     261                                
     262 004172 052716  000001          70$:	bis	#01,(sp)		; set c bit
     263 004176 012637  177776          80$:	mov	(sp)+,@#psw		; restore
     264 004202                         90$:	return				; done
       1 004202 000207                  	rts	pc
     265                                
     266 004204    040     050     122  500$:	.asciz	" (R0/%.6o R1/%.6o R2/%.6o R3/%.6o) "
         004207    060     057     045  
         004212    056     066     157  
         004215    040     122     061  
         004220    057     045     056  
         004223    066     157     040  
         004226    122     062     057  
         004231    045     056     066  
         004234    157     040     122  
         004237    063     057     045  
         004242    056     066     157  
         004245    051     040     000  
     267                                
     268                                ; --------------------------------------------------------------------------------
     269                                
     270                                .include "mac/printf.mac"
       1                                ;================================================================================
       2                                ; printf.mac - printf routines for macro11 diagnostics
       3                                ; (C) 2009-2016 Donald North. All rights reserved.
       4                                ;================================================================================
       5                                
       6                                .if ndf ttxcsr
       7                                	
       8                                	; separate psect (if console registers not defined)
       9                                	.psect	printf
      10                                
      11                                	; external tty references
      12                                	.globl	ttxcsr, ttxbuf
      13                                
      14                                	; standard macro definitions
      15                                 	.include "mac/stddef.mac"
      16                                
      17                                pf.sep	=1 ; flag separate compilation
      18                                
      19                                .iff
      20                                
      21        000000                  pf.sep	=0 ; flag unified compilation (via include)
      22                                	
      23                                .endc
      24                                ; 
      25                                ; global registers:
      26                                ;
      27                                ;  R5 - frame pointer
      28                                ;  R4 - argument pointer
      29                                ;  R3 - format string pointer
      30                                ;  R2 - current format character
      31                                ;  R1 - temp
      32                                ;  R0 - temp
      33                                ;
      34                                ; note:	for 11/04-05-10 compatibility, do NOT use SXT/XOR/SOB and MUL/DIV/ASH/ASHC
      35                                ; 
      36                                ; offsets from frame pointer (r5):
      37                                ; 
      38        000012                  p.sr0	=+10.	; saved r0
      39        000010                  p.sr1	=+8.	; saved r1
      40        000006                  p.sr2	=+6.	; saved r2
      41        000004                  p.sr3	=+4.	; saved r3
      42        000002                  p.sr4	=+2.	; saved r4
      43        000000                  p.sr5	=+0.	; saved r5
      44        177777                  p.flg	=-1.	; format flags (byte)
      45        177776                  p.fil	=-2.	; fill character (byte)
      46        177774                  p.wid	=-4.	; format numeric width (word)
      47        177772                  p.pre	=-6.	; format numeric precision (word)
      48        177770                  p.len	=-8.	; number of digits generated (word)
      49        177766                  p.out	=-10.	; addr(char print routine)
      50        177764                  p.ptr	=-12.	; sprintf output buffer pointer
      51                                ; 
      52        000014                  n.last	=+12.	; number of bytes allocated on stack
      53        000016                  n.args	=+14.	; offset to first argument on stack
      54                                ; 
      55                                ; bits in p.flg byte:
      56                                ; 
      57        000001                  pf.ljus	=1	; set for left justified ('-' seen)
      58        000002                  pf.sign	=2	; set for sign requested ('+' seen)
      59        000004                  pf.altf	=4	; set for alt flag ('#' seen)
      60        000010                  pf.long	=10	; set for long value (%...l. seen)
      61        000020                  pf.nega	=20	; set for negative value (msb set)
      62                                
      63                                ; --------------------------------------------------------------------------------
      64                                ;
      65                                ; printf routine .. 'C' printf(format,arg1,arg2,..,argn) ..  called in 'C' style
      66                                ;
      67                                ;	call:	mov	argN,-(sp)
      68                                ;		...
      69                                ;		mov	arg2,-(sp)
      70                                ;		mov	arg1,-(sp)
      71                                ;		mov	format,-(sp)
      72                                ;		call	printf
      73                                ;		add	#2*N,sp
      74                                ;
      75 004250 010046                  printf::mov	r0,-(sp)		; save reg
      76 004252 010146                  	mov	r1,-(sp)		;
      77 004254 010246                  	mov	r2,-(sp)		;
      78 004256 010346                  	mov	r3,-(sp)		;
      79 004260 010446                  	mov	r4,-(sp)		;
      80 004262 010546                  	mov	r5,-(sp)		;
      81                                	
      82 004264 010605                  	mov	sp,r5			; frame pointer
      83 004266 162706  000014          	sub	#n.last,sp		; reserve space on stack
      84                                	
      85 004272 010504                  	mov	r5,r4			; get frame ptr
      86 004274 062704  000016          	add	#n.args,r4		; offset to first argument
      87                                	
      88 004300 012765  004314  177766  	mov	#1$,p.out(r5)		; character output routine
      89 004306 005065  177764          	clr	p.ptr(r5)		; bufptr not used here
      90                                	
      91 004312 000442                  	br	xprintf			; continue
      92                                
      93                                	; ---------------------------------------------------------
      94                                	
      95                                	; character output to console
      96                                	
      97 004314 105737  177564          1$:	tstb	@#ttxcsr		; check if ready
      98 004320 100375                  	bpl	1$			; not yet
      99 004322 110037  177566          	movb	r0,@#ttxbuf		; send character
     100 004326                         	return				; return
       1 004326 000207                  	rts	pc
     101                                	
     102                                ; --------------------------------------------------------------------------------
     103                                ;
     104                                ; sprintf routine .. 'C' sprintf(buffer,format,arg1,arg2,..,argn) ..  called in 'C' style
     105                                ;
     106                                ;	call:	mov	argN,-(sp)
     107                                ;		...
     108                                ;		mov	arg2,-(sp)
     109                                ;		mov	arg1,-(sp)
     110                                ;		mov	format,-(sp)
     111                                ;		mov	buffer,-(sp)
     112                                ;		call	sprintf
     113                                ;		add	#2*N,sp
     114                                ;
     115 004330 010046                  sprintf::mov	r0,-(sp)		; save reg
     116 004332 010146                  	mov	r1,-(sp)		;
     117 004334 010246                  	mov	r2,-(sp)		;
     118 004336 010346                  	mov	r3,-(sp)		;
     119 004340 010446                  	mov	r4,-(sp)		;
     120 004342 010546                  	mov	r5,-(sp)		;
     121                                	
     122 004344 010605                  	mov	sp,r5			; frame pointer
     123 004346 162706  000014          	sub	#n.last,sp		; reserve space on stack
     124                                	
     125 004352 010504                  	mov	r5,r4			; get frame ptr
     126 004354 062704  000016          	add	#n.args,r4		; offset to first argument
     127                                	
     128 004360 012765  004374  177766  	mov	#1$,p.out(r5)		; character output routine
     129 004366 012465  177764          	mov	(r4)+,p.ptr(r5)		; init bufptr from argument
     130                                	
     131 004372 000412                  	br	xprintf			; continue
     132                                
     133                                	; ---------------------------------------------------------
     134                                	
     135                                	; character output to buffer
     136                                	
     137 004374 110075  177764          1$:	movb	r0,@p.ptr(r5)		; store character
     138 004400 005265  177764          	inc	p.ptr(r5)		; bump pointer
     139 004404 105075  177764          	clrb	@p.ptr(r5)		; null terminate
     140 004410 016565  177764  000012  	mov	p.ptr(r5),p.sr0(r5)	; return updated ptr in saved r0
     141 004416                         	return				; return
       1 004416 000207                  	rts	pc
     142                                	
     143                                ; --------------------------------------------------------------------------------
     144                                
     145                                	; process main format
     146                                
     147 004420 012403                  xprintf:mov	(r4)+,r3		; prime format string pointer
     148                                
     149 004422                         1$:	call	900$			; get next format character
       1 004422 004737  005332          	jsr	pc,900$
     150 004426 120227  000045          	cmpb	r2,#<'%>		; hit a format flag?
     151 004432 001430                  	beq	10$			; yes, go process
     152 004434 120227  000134          	cmpb	r2,#<'\>		; hit an escape flag?
     153 004440 001404                  	beq	3$			; yes, go process
     154 004442 010200                  2$:	mov	r2,r0			; char to print
     155 004444                         	call	@p.out(r5)		; no, just print it
       1 004444 004775  177766          	jsr	pc,@p.out(r5)
     156 004450 000764                  	br	1$			; loop
     157                                
     158                                	; process escaped character \a .. \z
     159                                
     160 004452                         3$:	call	900$			; get the escaped character
       1 004452 004737  005332          	jsr	pc,900$
     161 004456 002771                  	blt	2$			; quick exit for [NUL-@] range
     162 004460 120227  000172          	cmpb	r2,#<'z>		;
     163 004464 003366                  	bgt	2$			; exit if [{-DEL]
     164 004466 120227  000141          	cmpb	r2,#<'a>		;
     165 004472 002005                  	bge	4$			; br if [a-z]	
     166 004474 120227  000132          	cmpb	r2,#<'Z>		;
     167 004500 003360                  	bgt	2$			; br if [[-`]
     168 004502 152702  000040          	bisb	#40,r2			; force to [a-z] range
     169 004506 116202  005227          4$:	movb	1000$-<'a>(r2),r2	; translate a..z to escaped
     170 004512 000753                  	br	2$			; go print
     171                                
     172                                	; process format flag %[-+]?(0?\d+([.]\d+)?)?[lh]?[iduscpxo]
     173                                
     174 004514 112765  000040  177776  10$:	movb	#<' >,p.fil(r5)		; blank fill
     175 004522 105065  177777          	clrb	p.flg(r5)		; clear flags
     176 004526 005065  177774          	clr	p.wid(r5)		; init width spec
     177 004532 005065  177772          	clr	p.pre(r5)		; init precision spec
     178 004536 005065  177770          	clr	p.len(r5)		; no digits yet
     179                                
     180 004542                         11$:	call	900$			; get next format character
       1 004542 004737  005332          	jsr	pc,900$
     181 004546 002045                  	bge	40$			; br if [A-DEL]
     182 004550 120227  000045          	cmpb	r2,#<'%>		; check for '%'
     183 004554 001732                  	beq	2$			; br if yes
     184                                
     185                                	; some character in range [NUL-@]
     186                                
     187 004556 120227  000055          	cmpb	r2,#<'->		; check for '-'
     188 004562 001004                  	bne	12$			; br if not
     189 004564 152765  000001  177777  	bisb	#pf.ljus,p.flg(r5)	; yes, set a flag
     190 004572 000763                  	br	11$			; loop
     191 004574 120227  000053          12$:	cmpb	r2,#<'+>		; check for '+'
     192 004600 001004                  	bne	13$			; br if not
     193 004602 152765  000002  177777  	bisb	#pf.sign,p.flg(r5)	; yes, set a flag
     194 004610 000754                  	br	11$			; loop
     195 004612 120227  000043          13$:	cmpb	r2,#<'#>		; check for '#'
     196 004616 001004                  	bne	20$			; br if not
     197 004620 152765  000004  177777  	bisb	#pf.altr,p.flg(r5)	; yes, set a flag
     198 004626 000745                  	br	11$			; loop
     199                                
     200 004630                         20$:	call	800$			; get a number if present
       1 004630 004737  005236          	jsr	pc,800$
     201 004634 010165  177774          	mov	r1,p.wid(r5)		; save number as width
     202                                
     203 004640 120227  000056          	cmpb	r2,#<'.>		; check for .
     204 004644 001006                  	bne	40$			; br if not, should be alpha
     205 004646                         	call	900$			; get next character
       1 004646 004737  005332          	jsr	pc,900$
     206                                
     207 004652                         	call	800$			; get a number if present
       1 004652 004737  005236          	jsr	pc,800$
     208 004656 010165  177772          	mov	r1,p.pre(r5)		; save number as precision
     209                                
     210                                	; flag is in range [A-Za-z]
     211                                
     212 004662 005000                  40$:	clr	r0			; zap numerics
     213 004664 005001                  	clr	r1			;
     214 004666 120227  000101          41$:	cmpb	r2,#<'A>		; check for [:-@]
     215 004672 002663                  	blt	2$			; br if yes
     216 004674 120227  000172          	cmpb	r2,#<'z>		; check for [{-DEL]
     217 004700 003260                  	bgt	2$			; br if yes
     218 004702 120227  000141          	cmpb	r2,#<'a>		; check for [a-z]
     219 004706 002003                  	bge	42$			; br if yes
     220 004710 120227  000132          	cmpb	r2,#<'Z>		; check for [A-Z]
     221 004714 003252                  	bgt	2$			; br if no
     222 004716 042702  000040          42$:	bic	#40,r2			; force to [a-z] to [A-Z] range
     223 004722 012401                  	mov	(r4)+,r1		; get the next value as lsb
     224 004724 006302                  	asl	r2			; char*2 for word offset
     225 004726 000172  004530          	jmp	@400$-<2*'A>(r2)	; dispatch
     226                                
     227                                400$:	;----	aaaa,bbbb,cccc,dddd,eeee,ffff,gggg,hhhh,iiii,jjjj,kkkk,llll,mmmm
     228 004732 005016  005222  005062  	.word	401$,470$,420$,430$,401$,401$,401$,401$,430$,401$,401$,405$,401$
         004740 005102  005016  005016  
         004746 005016  005016  005102  
         004754 005016  005016  005032  
         004762 005016                  
     229                                	;----	nnnn,oooo,pppp,qqqq,rrrr,ssss,tttt,uuuu,vvvv,wwww,xxxx,yyyy,zzzz
     230 004764 005016  005172  005172  	.word	401$,450$,450$,401$,401$,410$,401$,440$,401$,401$,460$,401$,401$
         004772 005016  005016  005050  
         005000 005016  005156  005016  
         005006 005016  005206  005016  
         005014 005016                  
     231                                
     232 005016 005744                  401$:	tst	-(r4)			; %<illegal>: backup argument pointer
     233 005020 005002                  	clr	r2			; zap
     234 005022 156302  177777          	bisb	-1(r3),r2		; retrieve last character
     235 005026 000137  004442          	jmp	2$			; just go print
     236                                
     237 005032                         405$:	call	900$			; %l: get next character
       1 005032 004737  005332          	jsr	pc,900$
     238 005036 152765  000010  177777  	bisb	#pf.long,p.flg(r5)	; indicate longword value
     239 005044 010100                  	mov	r1,r0			; copy 1st arg to msb
     240 005046 000707                  	br	41$			; and go parse next flag
     241                                
     242 005050 010102                  410$:	mov	r1,r2			; %s: get next arg as string address
     243 005052                         	call	prtstr			; print as a string
       1 005052 004737  005772          	jsr	pc,prtstr
     244 005056 000137  004422          	jmp	1$			; continue at the top
     245                                
     246 005062 005046                  420$:	clr	-(sp)			; %c: zap upper byte
     247 005064 110116                  	movb	r1,(sp)			; insert the character
     248 005066 010602                  	mov	sp,r2			; point at string
     249 005070                         	call	prtstr			; print as a string
       1 005070 004737  005772          	jsr	pc,prtstr
     250 005074 005726                  	tst	(sp)+			; flush temp string
     251 005076 000137  004422          	jmp	1$			; continue at the top
     252                                
     253 005102 012702  000012          430$:	mov	#10.,r2			; %d,%i: decimal radix
     254 005106 132765  000010  177777  	bitb	#pf.long,p.flg(r5)	; longword value?
     255 005114 001004                  	bne	431$			; br if yes
     256 005116 005000                  	clr	r0			; zap
     257 005120 005701                  	tst	r1			; no; test lsb sign
     258 005122 100001                  	bpl	431$			; br if plus/zero
     259 005124 005100                  	com	r0			; extend -1 to msb
     260 005126 005700                  431$:	tst	r0			; test msb sign
     261 005130 002006                  	bge	439$			; br if zero or positive
     262 005132 005400                  	neg	r0			; negative; make positive
     263 005134 005401                  	neg	r1			;
     264 005136 005600                  	sbc	r0			;
     265 005140 152765  000020  177777  	bisb	#pf.nega,p.flg(r5)	; set flag indicating negative
     266 005146                         439$:	call	prt32u			; print as unsigned decimal w/sign
       1 005146 004737  005422          	jsr	pc,prt32u
     267 005152 000137  004422          	jmp	1$			; continue at the top
     268                                
     269 005156 012702  000012          440$:	mov	#10.,r2			; %u: decimal radix
     270 005162                         	call	prt32u			; print as an unsigned decimal
       1 005162 004737  005422          	jsr	pc,prt32u
     271 005166 000137  004422          	jmp	1$			; continue at the top
     272                                
     273 005172 012702  000010          450$:	mov	#8.,r2			; %o,%p: octal radix
     274 005176                         	call	prt32u			; print as an unsigned hex
       1 005176 004737  005422          	jsr	pc,prt32u
     275 005202 000137  004422          	jmp	1$			; continue at the top
     276                                
     277 005206 012702  000020          460$:	mov	#16.,r2			; %x: hexadecimal radix
     278 005212                         	call	prt32u			; print as an unsigned hex
       1 005212 004737  005422          	jsr	pc,prt32u
     279 005216 000137  004422          	jmp	1$			; continue at the top
     280                                
     281 005222 012702  000002          470$:	mov	#2.,r2			; %b: binary radix
     282 005226                         	call	prt32u			; print as an unsigned binary
       1 005226 004737  005422          	jsr	pc,prt32u
     283 005232 000137  004422          	jmp	1$			; continue at the top
     284                                
     285                                	; ---------------------------------------------------------
     286                                	; get a number as '[0-9]+' or '*'
     287                                
     288 005236 120227  000052          800$:	cmpb	r2,#<'*>		; check for '*' indirection
     289 005242 001427                  	beq	880$			; br if yes
     290 005244 120227  000060          	cmpb	r2,#<'0>		; check for leading '0' character
     291 005250 001002                  	bne	810$			; br if not
     292 005252 110265  177776          	movb	r2,p.fil(r5)		; yes, set a flag
     293 005256 005001                  810$:	clr	r1			; number accumulated here
     294 005260 120227  000060          820$:	cmpb	r2,#<'0>		; check for '0'
     295 005264 002421                  	blt	890$			; br if less that a '0'
     296 005266 120227  000071          	cmpb	r2,#<'9>		; check for '9'
     297 005272 003016                  	bgt	890$			; br if greater than '9'
     298 005274 162702  000060          	sub	#<'0>,r2		; offset to range 0..9
     299 005300 006301                  	asl	r1			; number *= 2.
     300 005302 010100                  	mov	r1,r0			; (number*2.)
     301 005304 006300                  	asl	r0			; (number*4.)
     302 005306 006300                  	asl	r0			; (number*8.)
     303 005310 060001                  	add	r0,r1			; number = number*8. + number*2.
     304 005312 060201                  	add	r2,r1			; add in this digit
     305 005314                         	call	900$			; get next format character
       1 005314 004737  005332          	jsr	pc,900$
     306 005320 000757                  	br	820$			; and loop
     307 005322 012401                  880$:	mov	(r4)+,r1		; get next arg as number
     308 005324                         	call	900$			; get next character
       1 005324 004737  005332          	jsr	pc,900$
     309 005330                         890$:	return				; return
       1 005330 000207                  	rts	pc
     310                                
     311                                	; ---------------------------------------------------------
     312                                	; get next character (or exit) routine; result in r2
     313                                
     314 005332 112302                  900$:	movb	(r3)+,r2		; get next format character
     315 005334 042702  177600          	bic	#^c177,r2		; 7bit ascii only
     316 005340 001403                  	beq	990$			; end of string seen
     317 005342 120227  000101          	cmpb	r2,#<'A>		; check for [A-DEL]
     318 005346                         	return				; leave CC set with result
       1 005346 000207                  	rts	pc
     319                                
     320 005350 010506                  990$:	mov	r5,sp			; flush frame
     321 005352 012605                  	mov	(sp)+,r5		; restore reg
     322 005354 012604                  	mov	(sp)+,r4		;
     323 005356 012603                  	mov	(sp)+,r3		;
     324 005360 012602                  	mov	(sp)+,r2		;
     325 005362 012601                  	mov	(sp)+,r1		;
     326 005364 012600                  	mov	(sp)+,r0		;
     327 005366                         	return				; return
       1 005366 000207                  	rts	pc
     328                                
     329                                	; ---------------------------------------------------------
     330                                	; escaped character table
     331                                1000$:	;	aaa bbb ccc ddd eee fff ggg hhh iii jjj kkk lll mmm
     332                                	;	BEL  BS         ESC  FF
     333 005370    007     010     143  	.byte	007,010,143,144,033,014,147,150,151,152,153,154,155
         005373    144     033     014  
         005376    147     150     151  
         005401    152     153     154  
         005404    155                  
     334                                	;	nnn ooo ppp qqq rrr sss ttt uuu vvv www xxx yyy zzz
     335                                	;	 LF              CR      HT      VT
     336 005405    012     157     160  	.byte	012,157,160,161,015,163,011,165,013,167,170,172,172
         005410    161     015     163  
         005413    011     165     013  
         005416    167     170     172  
         005421    172                  
     337                                	; ---------------------------------------------------------
     338                                
     339                                ; --------------------------------------------------------------------------------
     340                                ;
     341                                ; digit print routine .. print a 32b value as unsigned digits
     342                                ;
     343                                ;	call:	mov	datahi,r0
     344                                ;		mov	datalo,r1
     345                                ;		mov	#radix,r2 ; 2. or 8. or 10. or 16.
     346                                ;		call	prt32u
     347                                ;
     348                                ;		r0 - data msb      (not saved)
     349                                ;		r1 - data lsb      (not saved)
     350                                ;		r2 - radix         (not saved)
     351                                ;		r3 - ptr to format     (saved)
     352                                ;		r4 - ptr to arglist    (saved) [input not used]
     353                                ;		r5 - ptr to flags      (saved)
     354                                ;
     355 005422 010346                  prt32u:	mov	r3,-(sp)		; save regs we use
     356 005424 010446                  	mov	r4,-(sp)		;
     357                                
     358                                	; render all the digits onto the stack (lsd first, msd last)
     359                                
     360 005426 005046                  	clr	-(sp)			; zero flag
     361 005430 010246                  1$:	mov	r2,-(sp)		; radix lsb
     362 005432 005046                  	clr	-(sp)			;   and msb
     363 005434 010146                  	mov	r1,-(sp)		; number lsb
     364 005436 010046                  	mov	r0,-(sp)		;    and msb
     365 005440                         	call	uldiv			; get quo and rem
       1 005440 004737  006240          	jsr	pc,uldiv
     366 005444 016602  000006          	mov	6.(sp),r2		; restore radix from stack
     367 005450 062706  000010          	add	#8.,sp			; flush args
     368 005454 062703  000060          	add	#<'0>,r3		; make rem lsb a digit
     369 005460 020327  000071          	cmp	r3,#<'9>		; still a valid digit?
     370 005464 003402                  	ble	2$			; br if yes
     371 005466 062703  000007          	add	#<'A>-<':>,r3		; offset to 'A...'Z range
     372 005472 010346                  2$:	mov	r3,-(sp)		; save
     373 005474 005265  177770          	inc	p.len(r5)		; count digits
     374 005500 005701                  	tst	r1			; any lsb left?
     375 005502 001352                  	bne	1$			; br if yes
     376 005504 005700                  	tst	r0			; any msb left?
     377 005506 001350                  	bne	1$			; br if yes
     378                                
     379                                	; check if we generated the minimum number of digits requested
     380                                
     381 005510 026565  177770  177772  10$:	cmp	p.len(r5),p.pre(r5)	; compare length to precision
     382 005516 103005                  	bhis	20$			; br we're OK
     383 005520 012746  000060          	mov	#<'0>,-(sp)		; nope, add another digit
     384 005524 005265  177770          	inc	p.len(r5)		; count digits
     385 005530 000767                  	br	10$			; and loop	
     386                                
     387                                	; check for options (#) flag
     388                                
     389 005532 132765  000004  177777  20$:	bitb	#pf.altf,p.flg(r5)	; check for options flag
     390 005540 001422                  	beq	30$			; br if not set
     391 005542 020227  000020          	cmp	r2,#16.			; radix 16?
     392 005546 001407                  	beq	21$			; br if yes
     393 005550 020227  000010          	cmp	r2,#8.			; radix 8?
     394 005554 001014                  	bne	30$			; br if not
     395 005556 022716  000060          	cmp	#<'0>,(sp)		; first digit already zero?
     396 005562 001411                  	beq	30$			; yes, no need to add
     397 005564 000404                  	br	22$			; no, add a leading zero
     398 005566 012746  000170          21$:	mov	#<'x>,-(sp)		; add a '0x' prefix
     399 005572 005265  177770          	inc	p.len(r5)		; count it
     400 005576 012746  000060          22$:	mov	#<'0>,-(sp)		;
     401 005602 005265  177770          	inc	p.len(r5)		; count it
     402                                
     403                                	; check if we need a sign (+/-/none)
     404                                
     405 005606 132765  000020  177777  30$:	bitb	#pf.nega,p.flg(r5)	; was original value negative?
     406 005614 001403                  	beq	31$			; br if not
     407 005616 012746  000055          	mov	#<'->,-(sp)		; minus sign
     408 005622 000406                  	br	32$			;
     409 005624 132765  000002  177777  31$:	bitb	#pf.sign,p.flg(r5)	; sign always requested?
     410 005632 001404                  	beq	50$			; br if not
     411 005634 012746  000053          	mov	#<'+>,-(sp)		; plus sign
     412 005640 005265  177770          32$:	inc	p.len(r5)		; count all chars generated
     413                                
     414                                	; processing for right justification
     415                                
     416 005644 132765  000001  177777  50$:	bitb	#pf.ljus,p.flg(r5)	; check left-justify flag
     417 005652 001020                  	bne	70$			; br if left justified
     418 005654 116501  177776          	movb	p.fil(r5),r1		; get fill character
     419 005660 026565  177770  177774  51$:	cmp	p.len(r5),p.wid(r5)	; compare length to width
     420 005666 103012                  	bhis	70$			; br if we're OK
     421 005670 011600                  	mov	(sp),r0			; copy last character
     422 005672 010146                  	mov	r1,-(sp)		; add a fill character
     423 005674 020100                  	cmp	r1,r0			; check fill/last char order
     424 005676 101403                  	blos	52$			; br if order OK
     425 005700 010016                  	mov	r0,(sp)			; copy sign/last char
     426 005702 010166  000002          	mov	r1,2(sp)		; insert fill after sign
     427 005706 005265  177770          52$:	inc	p.len(r5)		; count it
     428 005712 000762                  	br	51$			; loop
     429                                
     430                                	; print all digits in order (sign..msd..lsd)
     431                                
     432 005714 005001                  70$:	clr	r1			; count characters output
     433 005716 012600                  71$:	mov	(sp)+,r0		; get a digit
     434 005720 001404                  	beq	80$			; br if no more
     435 005722                         	call	@p.out(r5)		; print it
       1 005722 004775  177766          	jsr	pc,@p.out(r5)
     436 005726 005201                  	inc	r1			; count it
     437 005730 000772                  	br	71$			; loop
     438                                
     439                                	; processing for left justification
     440                                
     441 005732 132765  000001  177777  80$:	bitb	#pf.ljus,p.flg(r5)	; check left-justify flag
     442 005740 001411                  	beq	90$			; br if is right justified
     443 005742 012700  000040          	mov	#<' >,r0		; space fill on right
     444 005746 020165  177774          81$:	cmp	r1,p.wid(r5)		; compare length to width
     445 005752 103004                  	bhis	90$			; br we're OK
     446 005754                         	call	@p.out(r5)		; print it
       1 005754 004775  177766          	jsr	pc,@p.out(r5)
     447 005760 005201                  	inc	r1			; count characters
     448 005762 000771                  	br	81$			; and loop	
     449                                
     450                                	; and done
     451                                
     452 005764 012604                  90$:	mov	(sp)+,r4		; restore regs
     453 005766 012603                  	mov	(sp)+,r3		;
     454 005770                         	return				; return
       1 005770 000207                  	rts	pc
     455                                
     456                                ; --------------------------------------------------------------------------------
     457                                ;
     458                                ; asciz string print routine
     459                                ;
     460                                ;	call:	mov	#strptr,r2
     461                                ;		call	prtstr
     462                                ;
     463                                ;		r0 - temp          (not saved)
     464                                ;		r1 - temp          (not saved)
     465                                ;		r2 - ptr to string (not saved)
     466                                ;		r3 - ptr to format     (saved) [input not used]
     467                                ;		r4 - ptr to arglist    (saved) [input not used]
     468                                ;		r5 - ptr to flags      (saved)
     469                                ;
     470 005772 010346                  prtstr:	mov	r3,-(sp)		; save regs
     471 005774 010446                  	mov	r4,-(sp)		;
     472                                
     473                                	; compute length of string
     474                                
     475 005776 010203                  	mov	r2,r3			; copy ptr to string
     476 006000 105723                  1$:	tstb	(r3)+			; check a byte
     477 006002 001376                  	bne	1$			; br if more string
     478 006004 160203                  	sub	r2,r3			; compute length
     479 006006 005303                  	dec	r3			; minus the trailing null	
     480                                
     481                                	; set precision to length if precision is zero
     482                                
     483 006010 005765  177772          	tst	p.pre(r5)		; check requested precision
     484 006014 001002                  	bne	20$			; br if nonzero
     485 006016 010365  177772          	mov	r3,p.pre(r5)		; else set to string length
     486 006022 020365  177772          20$:	cmp	r3,p.pre(r5)		; compare actual length to precision
     487 006026 101402                  	blos	50$			; br if actual <= precision
     488 006030 016503  177772          	mov	p.pre(r5),r3		; else set actual to precision
     489                                
     490                                	; processing for right justification
     491                                
     492 006034 132765  000001  177777  50$:	bitb	#pf.ljus,p.flg(r5)	; check left-justify flag
     493 006042 001002                  	bne	70$			; br if left justified
     494 006044                         	call	100$			; do fill
       1 006044 004737  006112          	jsr	pc,100$
     495                                
     496                                	; print string 
     497                                
     498 006050 010301                  70$:	mov	r3,r1			; copy length
     499 006052 001406                  	beq	80$			; br if no characters
     500 006054 112200                  71$:	movb	(r2)+,r0		; get a character
     501 006056 001404                  	beq	80$			; br if no characters
     502 006060                         	call	@p.out(r5)		; print it
       1 006060 004775  177766          	jsr	pc,@p.out(r5)
     503 006064 005301                  	dec	r1			; count
     504 006066 001372                  	bne	71$			; loop
     505                                
     506                                	; processing for left justification
     507                                
     508 006070 132765  000001  177777  80$:	bitb	#pf.ljus,p.flg(r5)	; check left-justify flag
     509 006076 001402                  	beq	90$			; br if is right justified
     510 006100                         	call	100$			; do fill
       1 006100 004737  006112          	jsr	pc,100$
     511                                
     512                                	; and done
     513                                
     514 006104 012604                  90$:	mov	(sp)+,r4		; restore
     515 006106 012603                  	mov	(sp)+,r3		;
     516 006110                         	return				; return
       1 006110 000207                  	rts	pc
     517                                
     518                                	; ----------------------------------------------------
     519                                	; generate fill characters
     520                                
     521 006112 016501  177774          100$:	mov	p.wid(r5),r1		; requested width
     522 006116 160301                  	sub	r3,r1			; subtract string width
     523 006120 101406                  	blos	102$			; br if no fill needed
     524 006122 116500  177776          	movb	p.fil(r5),r0		; get fill character
     525 006126                         101$:	call	@p.out(r5)		; print a fill character
       1 006126 004775  177766          	jsr	pc,@p.out(r5)
     526 006132 005301                  	dec	r1			; count
     527 006134 001374                  	bne	101$			; loop
     528 006136                         102$:	return				; done
       1 006136 000207                  	rts	pc
     529                                
     530                                ; --------------------------------------------------------------------------------
     531                                
     532                                .include "mac/muldiv.mac"
       1                                ;=================================================================================
       2                                ; muldiv.mac - 32b mul/div routines for macro11 diagnostics
       3                                ; (C) 2009-2016 Donald North. All rights reserved.
       4                                ;=================================================================================
       5                                
       6                                ; --------------------------------------------------------------------------------
       7                                ;
       8                                ; unsigned 32b * 32b => 32b multiplication
       9                                ; 
      10                                ; from the 2.9BSD stdio C lib, using simple shift/add algorithm
      11                                ; 
      12                                ;	call:	mov	#b.lo,-(sp)
      13                                ;		mov	#b.hi,-(sp)
      14                                ;		mov	#a.lo,-(sp)
      15                                ;		mov	#a.hi,-(sp)
      16                                ;		call	ulmul
      17                                ;		add	#8.,sp
      18                                ;		mov	r1,q.lo
      19                                ;		mov	r0,q.hi
      20                                ;
      21 006140 010246                  ulmul::	mov	r2,-(sp)		; save
      22 006142 010346                  	mov	r3,-(sp)		;
      23 006144 010446                  	mov	r4,-(sp)		;
      24 006146 010546                  	mov	r5,-(sp)		;
      25                                
      26 006150 016605  000020          	mov	8.+8.(sp),r5		; b.lo
      27 006154 016604  000016          	mov	6.+8.(sp),r4		; b.hi
      28 006160 016603  000014          	mov	4.+8.(sp),r3		; a.lo
      29 006164 016602  000012          	mov	2.+8.(sp),r2		; a.hi
      30 006170 005001                  	clr	r1			; q.lo
      31 006172 005000                  	clr	r0			; q.hi
      32                                
      33 006174 000241                  1$:	clc				; shiftin zeroes
      34 006176 006004                  	ror	r4			; shift multiplier right one
      35 006200 006005                  	ror	r5			;
      36 006202 103003                  	bcc	2$			; br if shifted out a zero
      37 006204 060301                  	add	r3,r1			; else add multiplicand to product
      38 006206 005500                  	adc	r0			; propagate C
      39 006210 060200                  	add	r2,r0			;
      40 006212 006303                  2$:	asl	r3			; shift multiplicant left one
      41 006214 006102                  	rol	r2			;
      42 006216 005704                  	tst	r4			; any high multiplier bits left?
      43 006220 001365                  	bne	1$			; br if yes
      44 006222 005705                  	tst	r5			; any low multiplier bits left?
      45 006224 001363                  	bne	1$			; br if yes
      46                                
      47 006226 012605                  	mov	(sp)+,r5		; restore
      48 006230 012604                  	mov	(sp)+,r4		;
      49 006232 012603                  	mov	(sp)+,r3		;
      50 006234 012602                  	mov	(sp)+,r2		;
      51 006236                         	return				; done
       1 006236 000207                  	rts	pc
      52                                
      53                                ; --------------------------------------------------------------------------------
      54                                ;
      55                                ; unsigned 32b / 32b => 32b, 32b division with remainder
      56                                ; 
      57                                ; from Hennessey & Patterson Appendix A
      58                                ;
      59                                ;	call:	mov	#den.lo,-(sp)	; 8.(sp)
      60                                ;		mov	#den.hi,-(sp)	; 6.(sp)
      61                                ;		mov	#num.lo,-(sp)	; 4.(sp)
      62                                ;		mov	#num.hi,-(sp)	; 2.(sp)
      63                                ;		call	uldiv
      64                                ;		add	#8.,sp
      65                                ;		mov	r3,rem.lo
      66                                ;		mov	r2,rem.hi
      67                                ;		mov	r1,quo.lo
      68                                ;		mov	r0,quo.hi
      69                                ;
      70 006240 010446                  uldiv::	mov	r4,-(sp)		; save
      71 006242 010546                  	mov	r5,-(sp)		;
      72                                
      73 006244 016601  000010          	mov	4.+4.(sp),r1		; num.lo
      74 006250 016600  000006          	mov	2.+4.(sp),r0		; num.hi
      75                                
      76 006254 005005                  	clr	r5			; tmp.lo
      77 006256 005004                  	clr	r4			; tmp.hi
      78                                
      79 006260 012746  000037          	mov	#31.,-(sp)		; bit count
      80                                
      81 006264 006301                  1$:	asl	r1			; (tmp,num) <<= 1
      82 006266 006100                  	rol	r0			;
      83 006270 006105                  	rol	r5			;
      84 006272 006104                  	rol	r4			;
      85                                
      86 006274 010503                  	mov	r5,r3			; rem = tmp - den
      87 006276 010402                  	mov	r4,r2			;
      88 006300 166603  000016          	sub	8.+6.(sp),r3		;
      89 006304 005602                  	sbc	r2			;
      90 006306 166602  000014          	sub	6.+6.(sp),r2		;
      91                                
      92 006312 100403                  	bmi	2$			; br if rem < 0
      93                                
      94 006314 005201                  	inc	r1			; quo |= 1
      95 006316 010305                  	mov	r3,r5			; tmp = rem
      96 006320 010204                  	mov	r2,r4			;
      97                                
      98 006322 005316                  2$:	dec	(sp)			; count bits
      99 006324 002357                  	bge	1$			; loop if more
     100 006326 005726                  	tst	(sp)+			; flush counter
     101                                
     102 006330 005702                  	tst	r2			; test for rem < 0
     103 006332 002005                  	bge	3$			; br if not
     104                                
     105 006334 066603  000014          	add	8.+4.(sp),r3		; rem += den correction
     106 006340 005502                  	adc	r2			;
     107 006342 066602  000012          	add	6.+4.(sp),r2		;
     108                                
     109 006346 012605                  3$:	mov	(sp)+,r5		; restore
     110 006350 012604                  	mov	(sp)+,r4		;
     111 006352                         	return				; done
       1 006352 000207                  	rts	pc
     112                                
     113                                ; --------------------------------------------------------------------------------
     114                                ;
     115                                ; signed 32b / 32b => 32b, 32b division with remainder
     116                                ; 
     117                                ;	call:	mov	#den.lo,-(sp)	; 8.(sp)
     118                                ;		mov	#den.hi,-(sp)	; 6.(sp)
     119                                ;		mov	#num.lo,-(sp)	; 4.(sp)
     120                                ;		mov	#num.hi,-(sp)	; 2.(sp)
     121                                ;		call	sldiv
     122                                ;		add	#8.,sp
     123                                ;		mov	r3,rem.lo
     124                                ;		mov	r2,rem.hi
     125                                ;		mov	r1,quo.lo
     126                                ;		mov	r0,quo.hi
     127                                ;
     128 006354 010446                  sldiv::	mov	r4,-(sp)		; save
     129                                
     130 006356 016603  000012          	mov	8.+2.(sp),r3		; den.lo
     131 006362 016602  000010          	mov	6.+2.(sp),r2		; den.hi
     132 006366 016601  000006          	mov	4.+2.(sp),r1		; num.lo
     133 006372 016600  000004          	mov	2.+2.(sp),r0		; num.hi
     134                                
     135 006376 005004                  	clr	r4			; pos
     136                                
     137 006400 005700                  	tst	r0			; num sign
     138 006402 002006                  	bge	10$			; br if pos
     139                                
     140 006404 005104                  	com	r4			; neg
     141                                
     142 006406 005101                  	com	r1			; negate num
     143 006410 005100                  	com	r0			;
     144 006412 062701  000001          	add	#1,r1			;
     145 006416 005500                  	adc	r0			; 
     146                                
     147 006420 005702                  10$:	tst	r2			; den sign
     148 006422 002006                  	bge	20$			; br if pos
     149                                
     150 006424 105104                  	comb	r4			; neg
     151                                
     152 006426 005103                  	com	r3			; negate den
     153 006430 005102                  	com	r2			;
     154 006432 062703  000001          	add	#1,r3			;
     155 006436 005502                  	adc	r2			; 
     156                                	
     157 006440 010346                  20$:	mov	r3,-(sp)		; den.lo
     158 006442 010246                  	mov	r2,-(sp)		; den.hi
     159 006444 010146                  	mov	r1,-(sp)		; num.lo
     160 006446 010046                  	mov	r0,-(sp)		; num.hi
     161 006450                         	call	uldiv			;
       1 006450 004737  006240          	jsr	pc,uldiv
     162 006454 062706  000010          	add	#8.,sp			; 
     163                                
     164 006460 005704                  	tst	r4			; invert result
     165 006462 002005                  	bge	30$			;
     166                                
     167 006464 005103                   	com	r3			; negate rem
     168 006466 005102                  	com	r2			;
     169 006470 062703  000001          	add	#1,r3			;
     170 006474 005502                  	adc	r2			; 
     171                                
     172 006476 105704                  30$:	tstb	r4			; invert result
     173 006500 002005                  	bge	40$			;
     174                                
     175 006502 005101                  	com	r1			; negate quo
     176 006504 005100                  	com	r0			;
     177 006506 062701  000001          	add	#1,r1			;
     178 006512 005500                  	adc	r0			; 
     179                                
     180 006514 012604                  40$:	mov	(sp)+,r4		; restore
     181 006516                         	return				; done
       1 006516 000207                  	rts	pc
     182                                
     183                                ;================================================================================
     184                                ; end of muldiv.mac
     185                                ;================================================================================
     185                                
     533                                
     534                                ; --------------------------------------------------------------------------------
     535                                
     536        000000                  .iif ne,pf.sep,	.end
     537                                
     538                                ;=================================================================================
     539                                ; end of printf.mac
     540                                ;=================================================================================
     540                                
     271                                
     272                                ; --------------------------------------------------------------------------------
     273                                
     274                                .end
     274                                


Symbol table

$$NUM  = 000002           3$6    = 004452   L       71$7   = 005716   L       BIT14  = 040000           P.SR4  = 000002           
$$POS  = 000200           30$11  = 006476   L       71$8   = 006054   L       BIT15  = 100000           P.SR5  = 000000           
$ENDAD = 004040           30$7   = 005606   L       710$1  = 003246   L       BIT2   = 000004           P.WID  = 177774           
$SAV42 = 002002           31$7   = 005624   L       711$1  = 003702   L       BIT3   = 000010           PASSES = 002004           
.      = 006520           32$7   = 005640   L       712$1  = 003740   L       BIT4   = 000020           PF.ALT = 000004           
1$10   = 006264   L       32768$0= 002220   L       713$1  = 003774   L       BIT5   = 000040           PF.LJU = 000001           
1$4    = 004314   L       32768$1= 002752   L       740$1  = 004002   L       BIT6   = 000100           PF.LON = 000010           
1$5    = 004374   L       32769$0= 002226   L       741$1  = 004007   L       BIT7   = 000200           PF.NEG = 000020           
1$6    = 004422   L       32770$0= 002244   L       80$3   = 004176   L       BIT8   = 000400           PF.SEP = 000000           
1$7    = 005430   L       32771$0= 002256   L       80$7   = 005732   L       BIT9   = 001000           PF.SIG = 000002           
1$8    = 006000   L       4$6    = 004506   L       80$8   = 006070   L       CONSOL = 165144 G         PRINTF = 004250 G         
1$9    = 006174   L       40$11  = 006514   L       800$6  = 005236   L       CR     = 000015           PRT32U = 005422           
10$11  = 006420   L       40$6   = 004662   L       81$7   = 005746   L       DONE   = 004014           PRTALL = 000001           
10$2   = 004056   L       400$6  = 004732   L       810$6  = 005256   L       DPYREG = 177570 G         PRTSTR = 005772           
10$6   = 004514   L       401$6  = 005016   L       820$6  = 005260   L       ERRFLG = 002010           PSW    = 177776 G         
10$7   = 005510   L       405$6  = 005032   L       880$6  = 005322   L       EXPCC  = 002026           RCVCC  = 002036           
100$1  = 002320   L       41$6   = 004666   L       890$6  = 005330   L       EXPR0  = 002020           RCVR0  = 002030           
100$8  = 006112   L       410$6  = 005050   L       90$3   = 004202   L       EXPR1  = 002022           RCVR1  = 002032           
1000$6 = 005370   L       42$6   = 004716   L       90$7   = 005764   L       EXPR2  = 002024           RCVR2  = 002034           
101$8  = 006126   L       420$6  = 005062   L       90$8   = 006104   L       LF     = 000012           SLDIV  = 006354 G         
102$8  = 006136   L       430$6  = 005102   L       900$6  = 005332   L       LOOP   = 002300           SPRINT = 004330 G         
11$6   = 004542   L       431$6  = 005126   L       990$6  = 005350   L       MSG1   = 002040           SRCR0  = 002012           
12$6   = 004574   L       439$6  = 005146   L       BIT0   = 000001           MSG2   = 002105           SRCR1  = 002014           
13$6   = 004612   L       440$6  = 005156   L       BIT00  = 000001           MSGPTR = 002006           SRCR2  = 002016           
150$1  = 002532   L       450$6  = 005172   L       BIT01  = 000002           MULPLY = 004076           STACK  = 002000           
155$1  = 002544   L       460$6  = 005206   L       BIT02  = 000004           N.ARGS = 000016           START  = 002200           
2$10   = 006322   L       470$6  = 005222   L       BIT03  = 000010           N.LAST = 000014           SWIREG = 177570 G         
2$6    = 004442   L       50$7   = 005644   L       BIT04  = 000020           NOXXDP = 004054           TST$NO = 000001           
2$7    = 005472   L       50$8   = 006034   L       BIT05  = 000040           P.FIL  = 177776           TTRBUF = 177562 G         
2$9    = 006212   L       500$1  = 002756   L       BIT06  = 000100           P.FLG  = 177777           TTRCSR = 177560 G         
20$11  = 006440   L       500$3  = 004204   L       BIT07  = 000200           P.LEN  = 177770           TTXBUF = 177566 G         
20$6   = 004630   L       501$1  = 003246   L       BIT08  = 000400           P.OUT  = 177766           TTXCSR = 177564 G         
20$7   = 005532   L       51$7   = 005660   L       BIT09  = 001000           P.PRE  = 177772           ULDIV  = 006240 G         
20$8   = 006022   L       52$7   = 005706   L       BIT1   = 000002           P.PTR  = 177764           ULMUL  = 006140 G         
200$1  = 002736   L       60$3   = 004154   L       BIT10  = 002000           P.SR0  = 000012           XPRINT = 004420           
21$7   = 005566   L       70$3   = 004172   L       BIT11  = 004000           P.SR1  = 000010           
22$7   = 005576   L       70$7   = 005714   L       BIT12  = 010000           P.SR2  = 000006           
3$10   = 006346   L       70$8   = 006050   L       BIT13  = 020000           P.SR3  = 000004           


Program sections:

. ABS.  006520    000   (RW,I,GBL,ABS,OVR,NOSAV)
        000000    001   (RW,I,LCL,REL,CON,NOSAV)
