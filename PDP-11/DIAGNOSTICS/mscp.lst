       1                                .title	MSCP Controller Diagnostic Test
       2                                
       3                                ; (C) 2010 Donald North. All rights reserved.
       4                                
       5                                .include "mac/stddef.mac"
       1                                ;================================================================================
       2                                ; stddef.mac - standard definitions
       3                                ; (C) 2009 Donald North. All rights reserved.
       4                                ;================================================================================
       5                                .macro	align	arg1
      16                                ;================================================================================
      17                                .macro	savreg	arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8
      28                                ;================================================================================
      29                                .macro	resreg	arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8
      40                                ;================================================================================
      41                                .macro	call	proc
      44                                .macro	return
      47                                .macro	calls	proc arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8 arg9 arg10 arg11 arg12 arg13 arg14 arg15 arg16
      67                                ;================================================================================
      68                                .macro	jeq	label ?a1
      73                                .macro	jne	label ?a1
      78                                .macro	jpl	label ?a1
      83                                .macro	jmi	label ?a1
      88                                .macro	jlo	label ?a1
      93                                .macro	jhis	label ?a1
      98                                .macro	jlos	label ?a1
     103                                .macro	jhi	label ?a1
     108                                .macro	jlt	label ?a1
     113                                .macro	jge	label ?a1
     118                                .macro	jle	label ?a1
     123                                .macro	jgt	label ?a1
     128                                .macro	jcc	label ?a1
     133                                .macro	jcs	label ?a1
     138                                .macro	jvc	label ?a1
     143                                .macro	jvs	label ?a1
     148                                ;================================================================================
     149                                .macro	printf	arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8 arg9 arg10 arg11 arg12 arg13 arg14 arg15 arg16
     152                                .macro	sprintf	arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8 arg9 arg10 arg11 arg12 arg13 arg14 arg15 arg16
     155                                ;================================================================================
     156                                .macro	ipl	lvl
     161                                ;================================================================================
     162                                .macro	trapcatcher	list ?a1 ?a2 ?a3 ?a4
     176                                ;================================================================================
     177        000001                  tst$no	= 1
     178                                .macro	test	title
     198                                ;================================================================================
     199                                ; end of stddef.mac
     200                                ;================================================================================
     200                                
       6                                
       7                                ; --------------------------------------------------------------------------------
       8                                
       9                                .sbttl	general definitions
      10                                
      11        000001                  UC17	=1			; 1 for UC17/UC18, 0 for UDA50
      12                                
      13                                .include "mac/bits.mac"
       1                                ;================================================================================
       2                                ; bits.mac - standard bit definitions
       3                                ;================================================================================
       4                                
       5                                ;  system global fixed addresses
       6                                
       7        177776                  psw	==177776		; processor status word
       8                                
       9        165144                  console	==165144		; console routine start
      10                                
      11        177570                  swireg	==177570		; console switch register
      12        177570                  dpyreg	==swireg		; console display register
      13                                
      14        177560                  ttrcsr	==177560		; console serial device
      15        177562                  ttrbuf	==ttrcsr+2		;
      16        177564                  ttxcsr	==ttrcsr+4		;
      17        177566                  ttxbuf	==ttrcsr+6		;
      18                                
      19                                ; common values
      20                                
      21        000015                  cr	=015			; ascii CR
      22        000012                  lf	=012			; ascii LF
      23                                
      24        000001                  bit00	=000001			; bit positions
      25        000002                  bit01	=000002			;
      26        000004                  bit02	=000004			;
      27        000010                  bit03	=000010			;
      28        000020                  bit04	=000020			;
      29        000040                  bit05	=000040			;
      30        000100                  bit06	=000100			;
      31        000200                  bit07	=000200			;
      32        000400                  bit08	=000400			;
      33        001000                  bit09	=001000			;
      34        002000                  bit10	=002000			;
      35        004000                  bit11	=004000			;
      36        010000                  bit12	=010000			;
      37        020000                  bit13	=020000			;
      38        040000                  bit14	=040000			;
      39        100000                  bit15	=100000			;
      40                                	
      41        000001                  bit0	=bit00			; also
      42        000002                  bit1	=bit01			;
      43        000004                  bit2	=bit02			;
      44        000010                  bit3	=bit03			;
      45        000020                  bit4	=bit04			;
      46        000040                  bit5	=bit05			;
      47        000100                  bit6	=bit06			;
      48        000200                  bit7	=bit07			;
      49        000400                  bit8	=bit08			;
      50        001000                  bit9	=bit09			;
      51                                
      52                                ;================================================================================
      53                                ; end of bits.mac
      54                                ;================================================================================
      54                                
      14                                
      15                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      16                                
      17                                .sbttl	local definitions
      18                                
      19                                ; LCLK registers
      20                                
      21        177546                  lk$csr	=177546			; line clock csr
      22        000200                  lk_mon	=000200			; monitor but
      23        000100                  lk_ien	=000100			; intr enb bit
      24        000100                  lk$vec	=100			; vector
      25        000006                  lk_pri	=6			; priority
      26                                
      27                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      28                                
      29                                .sbttl	MSCP definitions
      30                                
      31                                .include "mscp/define.mac"
       1                                ; --------------------------------------------------------------------------------
       2                                ; define.mac - mscp/tmscp register definitions
       3                                ; (C) 2010 Donald North. All rights reserved.
       4                                ; --------------------------------------------------------------------------------
       5                                
       6                                ; MSCP controller registers
       7                                
       8                                ; SA register universal bits
       9                                
      10        003777                  sa_erc	=003777			; error code
      11        004000                  sa_st1	=004000			; step 1 state
      12        010000                  sa_st2	=010000			; step 2 state
      13        020000                  sa_st3	=020000			; step 3 state
      14        040000                  sa_st4	=040000			; step 4 state
      15        100000                  sa_err	=100000			; error indicator
      16                                
      17                                ; SA register S1 response bits
      18                                
      19        000001                  sa_rs0	=000001			; reserved lsb
      20        000377                  sa_rsv	=000377			; reserved
      21        000400                  sa_edp	=000400			; enhanced diagnostics present
      22        001000                  sa_a22	=001000			; 22b addressing present
      23        002000                  sa_nsv	=002000			; non-settable intr vector
      24                                
      25                                ; SA register S1 send bits
      26                                
      27        000177                  sa_vec	=000177			; intr vector (div by 4)
      28        000200                  sa_int	=000200			; intr enable during init
      29        000400                  sa_rl0	=000400			; response ring length lsb
      30        003400                  sa_rll	=003400			; response ring length
      31        004000                  sa_cl0	=004000			; command ring length lsb
      32        034000                  sa_cll	=034000			; command ring length
      33        040000                  sa_wrp	=040000			; wrap bit
      34        100000                  sa_stp	=100000			; step bit
      35                                
      36                                ; SA register S2 response bits
      37                                
      38        000007                  sa_rle	=000007			; response ring length echo
      39        000070                  sa_cle	=000070			; command ring length echo
      40        000200                  sa_ste	=000200			; step echo
      41        003400                  sa_cty	=003400			; controller type
      42                                
      43                                ; SA register S2 send bits
      44                                
      45        000001                  sa_prg	=000001			; enable UBA purge interrupt
      46        177776                  sa_rgl	=177776			; ring(lo) address
      47                                
      48                                ; SA register S3 response bits
      49                                
      50        000177                  sa_vee	=000177			; intr vector (div4) echo
      51        000200                  sa_ine	=000200			; intr enable echo
      52        000400                  sa_vpe	=000400			; vector-programmable echo
      53                                
      54                                ; SA register S3 send bits
      55                                
      56        077777                  sa_rgh	=077777			; ring(hi) address
      57        100000                  sa_ppt	=100000			; purge poll test enable
      58                                
      59                                ; SA register S4 response bits
      60                                
      61        000001                  sa_mc0	=000001			; microcode rev level lsb
      62        000017                  sa_mcv	=000017			; microcode rev level
      63        000020                  sa_cn0	=000020			; controller type lsb
      64        000360                  sa_cnt	=000360			; controller type
      65                                
      66                                ; SA register S4 send bits
      67                                
      68        000001                  sa_go	=000001			; controller GO bit
      69        000002                  sa_lfc	=000002			; last failure code request
      70        000374                  sa_bst	=000374			; burst level
      71                                
      72                                ; controller types in SA_CNT field
      73                                
      74        000002                  t_ud50	=2.			; UDA50 unibus disk
      75        000005                  t_tu81	=5.			; TU81 tape
      76        000006                  t_ud5a	=6.			; UDA50A unibus disk
      77        000011                  t_tk50	=9.			; TK50/TQK50 tape
      78        000016                  t_tk70	=14.			; TK70/TQK70 tape
      79        000023                  t_rqd3	=19.			; RQDX3 qbus disk
      80                                
      81                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      82                                
      83                                ; *** MSCP protocol definitions ***
      84                                
      85                                ; command/response packet offsets
      86                                
      87                                ; generic:
      88        177774                  p_len	=-4	; [2] command length, bytes
      89        177776                  p_type	=-2	; [1] msg type and credits
      90        177777                  p_cid	=-1	; [1] connection id
      91        000000                  p_crf	=0	; [4] command reference number
      92        000004                  p_unit	=4	; [2] unit number
      93        000010                  p_opcd	=10	; [1] opcode
      94        000012                  p_mod	=12	; [2] modifiers
      95        000014                  p_bcnt	=14	; [4] byte count
      96        000020                  p_buff	=20	; [12] buffer descriptor
      97        000034                  p_lbn	=34	; [4] logical block number
      98                                ; abort, get command status:
      99        000014                  p_otrf	=14	; [4] outstanding reference number
     100                                ; online, set unit characteristics:
     101        000016                  p_unfl	=16	; [2] unit flags
     102        000034                  p_dvpm	=34	; [4] device dependent parameters
     103                                ; replace:
     104        000014                  p_rbn	=14	; [4] replacement block number
     105                                ; set controller characteristics:
     106        000014                  p_vrsn	=14	; [2] MSCP version
     107        000016                  p_cntf	=16	; [2] controller flags
     108        000020                  p_htmo	=20	; [2] host timeout
     109        000024                  p_time	=24	; [8] quadword time/date
     110                                ; generic end message:
     111        000011                  p_flgs	=11	; [1] flags
     112        000012                  p_sts	=12	; [2] status
     113        000034                  p_fbbk	=34	; [4] first bad block
     114                                ; get command status end message:
     115        000020                  p_cmst	=20	; [4] command status
     116                                ; get unit status end message:
     117        000014                  p_mlun	=14	; [2] multi-unit code
     118        000024                  p_unti	=24	; [8] unit ID
     119        000034                  p_medi	=34	; [4] media ID
     120        000040                  p_shun	=40	; [2] shadow unit
     121        000044                  p_trck	=44	; [2] track size
     122        000046                  p_grp	=46	; [2] groups size
     123        000050                  p_cyl	=50	; [2] cylinder size
     124        000054                  p_rcts	=54	; [2] RCT table size
     125        000056                  p_rbns	=56	; [1] RBNs/track
     126        000057                  p_rctc	=57	; [1] RCT copies
     127                                ; online, set unit characteristics end message:
     128        000044                  p_unsz	=44	; [4] unit size
     129        000050                  p_vser	=50	; [4] volume serial number
     130                                ; set controller characteristics end message:
     131        000020                  p_ctmo	=20	; [2] controller timeout
     132        000024                  p_cnti	=24	; [8] controller ID
     133                                ;
     134        000060                  p_csiz	=60	; max command size, bytes
     135        000060                  p_msiz	=60	; max message size, bytes
     136                                
     137                                ; MSCP error log message offsets
     138                                
     139                                ; generic:
     140        000000                  l_crf	=0	; [4] command reference number
     141        000004                  l_unit	=4	; [2] unit number
     142        000006                  l_seq	=6	; [2] sequence number
     143        000010                  l_fmt	=10	; [1] format
     144        000011                  l_flgs	=11	; [1] flags
     145        000012                  l_evnt	=12	; [2] event code
     146        000014                  l_cnti	=14	; [8] controller ID
     147        000024                  l_csvr	=24	; [1] controller s/w version
     148        000025                  l_chvr	=25	; [1] controller h/w version
     149        000026                  l_mlun	=26	; [2] multi-unit code
     150        000030                  l_unti	=30	; [8] unit ID
     151        000040                  l_usvr	=40	; [1] unit s/w version
     152        000041                  l_uhvr	=41	; [1] unit h/w version
     153        000044                  l_vser	=44	;  [4] volume serial number
     154                                ; host memory access errors:
     155        000004                  l_badr	=4	; [4] bus address
     156                                ; disk transfer errors:
     157        000042                  l_lvl	=42	; [1] level
     158        000043                  l_rtry	=43	; [1] retry
     159        000050                  l_hdcd	=50	; [4] header code
     160                                ; sdi errors:
     161        000054                  l_sdi	=54	; [12] sdi information
     162                                
     163                                ; MSCP command opcodes
     164                                
     165        000000                  op_nil	=0.	; [b] nop
     166        000001                  op_abo	=1.	; [b] abort
     167        000002                  op_gcs	=2.	; [b] get command status
     168        000003                  op_gus	=3.	; [b] get unit status
     169        000004                  op_scc	=4.	; [b] set controller characteristics
     170        000010                  op_avl	=8.	; [b] available
     171        000011                  op_onl	=9.	; [b] online
     172        000012                  op_suc	=10.	; [b] set unit characteristics
     173        000013                  op_dap	=11.	; [b] determine access paths
     174        000020                  op_acc	=16.	; [b] access
     175        000021                  op_ccd	=17.	; [d] compare
     176        000022                  op_ers	=18.	; [b] erase
     177        000023                  op_flu	=19.	; [d] flush
     178        000024                  op_rpl	=20.	; [?] replace
     179        000026                  op_erg	=22.	; [t] erase gap
     180        000040                  op_cmp	=32.	; [b] compare
     181        000041                  op_rd	=33.	; [b] read
     182        000042                  op_wr	=34.	; [b] write
     183        000044                  op_wtm	=36.	; [t] write tape mark
     184        000045                  op_pos	=37.	; [t] reposition
     185        000057                  op_fmt	=47.	; [d] format
     186        000077                  op_ill	=63.	; [b] illegal
     187        000100                  op_ava	=64.	; [b] available attention message
     188        000101                  op_dup	=65.	; [b] duplicate unit message
     189        000102                  op_acp	=66.	; [b] access path attention message
     190        000103                  op_rwa	=67.	; [t] rewind attention message
     191        000200                  op_end	=128.	; [b] end message flag
     192                                
     193                                ; MSCP command modifiers
     194                                
     195        100000                  md_exp	=100000	; [d] express NI
     196        040000                  md_cmp	=40000	; [b] compare NI
     197        020000                  md_cse	=20000	; [b] clear serious error
     198        010000                  md_err	=10000	; [d] force error NI
     199        010000                  md_cdl	=10000	; [t] clear data lost NI
     200        004000                  md_sch	=4000	; [t] supr cache highspeed NI
     201        002000                  md_scl	=2000	; [t] supr cache lowspeed NI
     202        001000                  md_sec	=1000	; [b] suppress error correction
     203        000400                  md_ser	=400	; [b] suppress error recovery
     204        000200                  md_dle	=200	; [t,pos] detect LEOT
     205        000100                  md_imm	=100	; [t] immediate NI
     206        000040                  md_exa	=40	; [b] excl access NI
     207        000020                  md_shd	=20	; [d] shadow NI
     208        000020                  md_unl	=20	; [t] unload
     209        000010                  md_erw	=10	; [t,wr] enable rewrite
     210        000010                  md_rev	=10	; [t,rd|pos] reverse
     211        000004                  md_swp	=4	; [b,suc] enb set wri prot
     212        000004                  md_obc	=4	; [t,pos] obj count
     213        000002                  md_imf	=2	; [d,onl] ignore fmt err NI
     214        000002                  md_rwd	=2	; [t,pos] rewind
     215        000002                  md_acl	=2	; [t,avl] all class NI
     216        000001                  md_nxu	=1	; [b,gus] next unit
     217        000001                  md_spn	=1	; [d,avl] spin down NI
     218        000001                  md_rip	=1	; [d,onl] allow rip NI
     219                                
     220                                ; MSCP end message flags
     221                                
     222        000200                  ef_bbr	=200	; [d] bad block reported
     223        000100                  ef_bbu	=100	; [d] bsd block unreported
     224        000040                  ef_log	=40	; [b] error log generated
     225        000020                  ef_sxc	=20	; [b] serious exception
     226        000010                  ef_eot	=10	; [t] end of tape
     227        000004                  ef_pls	=4	; [t] position lost
     228        000002                  ef_dls	=2	; [t] cached data lost
     229                                
     230                                ; MSCP controller flags
     231                                
     232        100000                  cf_rpl	=100000	; ctlr bad block repl
     233        000200                  cf_atn	=200	; enable attention messages
     234        000100                  cf_msc	=100	; enable misc error log messages
     235        000040                  cf_oth	=40	; enable other host's error log messages
     236        000020                  cf_ths	=20	; enable this host's error log messages
     237                                
     238                                ; MSCP unit flags
     239                                
     240        100000                  uf_rpl	=100000	; [d] report bad blocks
     241        100000                  uf_cac	=100000	; [t] cache write back
     242        020000                  uf_wph	=20000	; [b] write protect (h/w)
     243        010000                  uf_wps	=10000	; [b] write protect (s/w)
     244        004000                  uf_sch	=4000	; [t] supr cache NI
     245        002000                  uf_exa	=2000	; [b] exclusive NI
     246        001000                  uf_lod	=1000	; [t] tape loader present
     247        000400                  uf_wpd	=400	; [b] wr prot data NI
     248        000200                  uf_rmv	=200	; [d] removable media
     249        000100                  uf_wbn	=100	; [t] write back NI
     250        000040                  uf_vss	=40	; [t] supr var speed NI
     251        000020                  uf_vsu	=20	; [t] var speed unit NI
     252        000010                  uf_ewr	=10	; [t] enh write recovery NI
     253        000004                  uf_cfl	=4	; [t] cache has been flushed
     254        000002                  uf_cmw	=2	; [b] compare writes
     255        000001                  uf_cmr	=1	; [b] compare reads
     256                                
     257                                ; MSCP error log message flags
     258                                
     259        000200                  lf_suc	=200	; [b] operation successful
     260        000100                  lf_con	=100	; [b] operation continuing
     261        000040                  lf_bbr	=40	; [d] bad block repl NI
     262        000020                  lf_rct	=20	; [d] err in block repl NI
     263        000002                  lf_inf	=2	; [d] info
     264        000001                  lf_snr	=1	; [b] sequence number reset
     265                                
     266                                ; MSCP error log message formats
     267                                
     268        000000                  fm_cnt	=0.	; [b] controller errors
     269        000001                  fm_bad	=1.	; [b] host memory access errors
     270        000002                  fm_dsk	=2.	; [d] disk errors
     271        000003                  fm_sdi	=3.	; [d] SDI errors
     272        000004                  fm_sde	=4.	; [d] small disk error
     273        000005                  fm_tap	=5.	; [t] tape error
     274        000006                  fm_sti	=6.	; [t] STI comm error
     275        000007                  fm_std	=7.	; [t] STI drive error
     276        000010                  fm_stf	=8.	; [t] STI formatter error
     277        000011                  fm_rpl	=9.	; [d] bad block repl error
     278        000012                  fm_ldr	=10.	; [t] media loader error
     279        000013                  fm_ibm	=11.	; [t] sense data error log
     280                                
     281                                ; major status return codes
     282                                
     283        000000                  st_suc	=0.	; [b] success
     284        000001                  st_cmd	=1.	; [b] command invalid
     285        000002                  st_abo	=2.	; [b] command aborted
     286        000003                  st_ofl	=3.	; [b] unit offline
     287        000004                  st_avl	=4.	; [b] unit available
     288        000005                  st_mfe	=5.	; [b] media format error
     289        000006                  st_wpr	=6.	; [b] write protected
     290        000007                  st_cmp	=7.	; [b] compare error
     291        000010                  st_dat	=8.	; [b] data error
     292        000011                  st_hst	=9.	; [b] host buffer access error
     293        000012                  st_cnt	=10.	; [b] controller error
     294        000013                  st_drv	=11.	; [b] drive error
     295        000014                  st_fmt	=12.	; [t] formatter error
     296        000015                  st_bot	=13.	; [t] BOT encountered
     297        000016                  st_tmk	=14.	; [t] tape mark
     298        000020                  st_rdt	=16.	; [t] record truncated
     299        000021                  st_pol	=17.	; [t] position lost
     300        000022                  st_sxc	=18.	; [b] serious exception
     301        000023                  st_led	=19.	; [t] LEOT detect
     302        000024                  st_bbr	=20.	; [d] bad block complete
     303        000025                  st_inv	=21.	; [b] invalid parameter
     304        000026                  st_inf	=22.	; [b] information message
     305        000027                  st_ldr	=23.	; [t] media loader error
     306        000037                  st_dia	=31.	; [b] diagnostic message
     307                                	
     308        000037                  st_msk	=37	; [b] status mask
     309        000040                  st_sub	=40	; [b] subcode multiplier
     310                                
     311                                ; MSCP misc values
     312                                
     313        100000                  ds_own	=100000	; OWN bit in comm structure
     314        040000                  ds_int	=040000	; INTR bit in comm structure
     315                                
     316                                ; --------------------------------------------------------------------------------
     317                                ; end of define.mac
     318                                ; --------------------------------------------------------------------------------
     318                                
      32                                
      33        000001                  .if ne UC17
      34                                ; UC17/UC18
      35        000000                  sa_opt	=0			; step1 response reserved bits
      36        000006                  sa_ucv	=6			; step4 code version
      37        000006                  sa_ctyp	=6			; step4 disk controller type
      38                                .iff
      39                                ; UDA50 (in SIMH)
      40                                sa_opt	=100			; step1 response reserved bits
      41                                sa_ucv	=3			; step4 code version
      42                                sa_ctyp	=23			; step4 disk controller type
      43                                .endc
      44                                
      45        000000                  tstcid	=0			; disk connection id
      46                                
      47                                ; --------------------------------------------------------------------------------
      48                                
      49                                .sbttl	low memory
      50                                
      51                                	.enabl	ama			; change all mode 67 references to 37
      52                                
      53 000000                         	.asect				; absolute load image
      54                                
      55        000046                  	.=46
      56 000046 022362                  	.word	$endad			; address of JSR PC,(R0)
      57        000052                  	.=52
      58 000052 000000                  	.word	0			; run options
      59                                
      60        000200                  	.=200
      61 000200 000137  012400          	jmp	@#start			; standard diagnostic entry
      62                                
      63                                ; --------------------------------------------------------------------------------
      64                                
      65                                .sbttl	global variables
      66                                
      67        002000                  	.=2000
      68 002000 177777                  stack:	.word	-1			; top of stack
      69 002002 000000                  optswi:	.word	0			; option switches (bit0=verbose_printout)
      70 002004 000002                  numpas:	.word	2.			; number of passes to run
      71 002006 172150                  m$base:	.word	172150			; disk controller csr base
      72 002010 000154                  m$vect:	.word	154			; disk controller std vector
      73 002012 001130                  runtil:	.word	10.*60.			; number of ticks to run read loop
      74 002014 000000                  csr_ip:	.word	0			; disk controller IP register (stored)
      75 002016 000000                  csr_sa:	.word	0			; disk controller SA register (stored)
      76 002020 000000                  errors:	.word	0			; count errors
      77 002022 000000                  passes:	.word	0			; count passes
      78 002024 000000                  $sav42:	.word	0			; XXDP restart address
      79 002026 000000  000000          ticker:	.word	0,0			; tickcount lo,hi
      80 002032 000000                  dlycnt:	.word	0			; delay count
      81 002034 000000                  runcnt:	.word	0			; run count
      82 002036 000000                  testno:	.word	0			; current test number
      83 002040 000000                  unitno:	.word	0			; unit number
      84 002042 000000  000000          refnum:	.word	0,0			; refnum lo,hi
      85 002046 000000  000000          blknum:	.word	0,0			; block number lo,hi
      86 002052 000000  000000          blkcnt:	.word	0,0			; block count lo,hi
      87 002056 000000  000000  000000  devsiz:	.word	0,0, 0,0, 0,0, 0,0	; block size of each unit lo,hi
         002064 000000  000000  000000  
         002072 000000  000000          
      88 002076 000000  000000  000000  	.word	0,0, 0,0, 0,0, 0,0	; 
         002104 000000  000000  000000  
         002112 000000  000000          
      89 002116    000                  online:	.byte	0			; bitmask of online units (bit set for online)
      90                                
      91                                	; MSCP buffers
      92                                
      93 002117    000                  	.even				; align
      94                                
      95        000010                  bufsiz	=8.				; size in blocks
      96        001000                  blklen	=512.				; size in bytes
      97        010000                  buflen	=bufsiz*blklen			; size in bytes
      98                                
      99        002120                  buffer:	.blkb	buflen			; data buffer
     100        012120                  bufend:	.blkb	0			; end
     101                                
     102 012120    377     377          	.byte	-1,-1			; spacing
     103                                	
     104                                	.even				; align
     105        012122                  	.blkb	4.			; header
     106        012126                  comm:	.blkb	8.			; comm structure
     107                                
     108 012136    377     377          	.byte	-1,-1			; spacing
     109                                	
     110        000060                  rlen	=p_msiz				; size in bytes
     111                                	.even				; align
     112        012140                  	.blkb	4.			; header
     113        012144                  rpkt:	.blkb	rlen			; resp desc structure
     114        012224                  rend:	.blkb	0			; end
     115                                
     116 012224    377     377          	.byte	-1,-1			; spacing
     117                                	
     118        000060                  clen	=p_csiz				; size in bytes
     119                                	.even				; align
     120        012226                  	.blkb	4.			; header
     121        012232                  cpkt:	.blkb	clen			; cmd desc structure
     122        012312                  cend:	.blkb	0			; end
     123                                
     124 012312    377     377          	.byte	-1,-1			; spacing
     125                                
     126                                	.even				; align
     127                                
     128                                ; --------------------------------------------------------------------------------
     129                                
     130                                .sbttl	program start
     131                                
     132 012314                         	align	7			; pc alignment
       9                                .list
     133                                
     134 012400 012706  002000          start:	mov	#stack,sp		; setup a stack
     135 012404 000005                  	reset				; reset the world
     136 012406 013737  000042  002024  	mov	@#42,$sav42		; save XXDP restart
     137                                
     138 012414                         	trapcatcher <2,200,206,400>	; setup a trapcatcher in low vector space
       1 012414 012700  012444          	mov	#32770$,r0    		; ptr to table
       2 012420 012001                  32768$:	mov	(r0)+,r1		; start addr
       3 012422 100415                  	bmi	32771$			; done?
       4 012424 012002                  	mov	(r0)+,r2		; end addr
       5 012426 010161  177776          32769$:	mov	r1,-2(r1)		; point vector at next word
       6 012432 005011                  	clr	(r1)			; <0> which is a halt
       7 012434 022121                  	cmp	(r1)+,(r1)+		; add four to ptr
       8 012436 020102                  	cmp	r1,r2			; reached end?
       9 012440 003772                  	ble	32769$			; not yet
      10 012442 000766                  	br	32768$			; more
      11 012444 000002  000200  000206  32770$:	.word	2,200,206,400, -1
         012452 000400  177777          
      12 012456 000240                  32771$:	nop				; placeholder
     139                                
     140 012460                         	printf	#msg1			; say hello
       1 012460                         	calls	printf #msg1               
       8                                .list
       9 012460 012746  022434          	mov	#msg1,-(sp)
       1                                .list
       2 012464                         	call	printf
       1 012464 004737  025102          	jsr	pc,printf
       3 012470 062706  000002          	add	#2,sp
      18                                .list
     141                                
     142 012474 005037  002020          	clr	errors			; none yet
     143 012500 005037  002022          	clr	passes			; ditto
     144                                
     145                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     146                                
     147                                .sbttl	setup misc devices
     148                                
     149 012504 005037  002026          	clr	ticker+0		; clear tick counter
     150 012510 005037  002030          	clr	ticker+2		;
     151                                
     152 012514 005037  002034          	clr	runcnt			; clear run counter
     153                                	
     154 012520 012737  022552  000100  	mov	#lkintr,lk$vec+0	; intr routine for line clock
     155 012526 012737  000300  000102  	mov	#lk_pri*bit5,lk$vec+2	; psw for intr service
     156 012534 052737  000100  177546  	bis	#lk_ien,@#lk$csr	; enable line clock interrupts
     157                                
     158 012542 005037  002042          	clr	refnum+0		; clear refnum
     159 012546 005037  002044          	clr	refnum+2		;
     160                                
     161                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     162                                
     163                                .sbttl	set psw to zero
     164                                
     165 012552 005046                  	clr	-(sp)			; zap psw
     166 012554 012746  012562          	mov	#loop,-(sp)		; fake pc
     167 012560 000002                  	rti				; reload psw
     168                                
     169                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     170                                
     171 012562 012737  000001  002036  loop:	mov	#1,testno		; starting test number
     172                                
     173                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     174                                
     175 012570                         	test	<basic controller access>
       1                                .list
       2                                
       3                                	;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       4                                	.sbttl	Test1 - basic controller access
       5                                	;------------------------------------------------------------
       6                                
       7                                test1:	; start of test
       8                                
       9 012570 022737  000001  002036  	cmp	#1,testno		; check for sequence error
      10 012576 001401                  	beq	.+4			; OK, skip over halt
      11 012600 000000                  	halt				; FATAL - SEQUENCE ERROR
      18                                .list
     176                                
     177 012602                         	printf	#1010$,testno		; header message
       1 012602                         	calls	printf #1010$ testno              
       8                                .list
       9 012602 013746  002036          	mov	testno,-(sp)
      14                                .list
      15 012606 012746  012726          	mov	#1010$,-(sp)
       1                                .list
       2 012612                         	call	printf
       1 012612 004737  025102          	jsr	pc,printf
       3 012616 062706  000004          	add	#4,sp
      18                                .list
     178                                
     179 012622 013700  002006          	mov	m$base,r0		; base csr address (IP)
     180 012626 010037  002014          	mov	r0,csr_ip		; save as IP address
     181 012632                         	call	adrchk			; check if responds
       1 012632 004737  025030          	jsr	pc,adrchk
     182 012636 103402                  	bcs	100$			; br if OK
     183 012640                         	call	300$			; error message
       1 012640 004737  012676          	jsr	pc,300$
     184                                
     185 012644 013700  002006          100$:	mov	m$base,r0		; base csr address (IP)
     186 012650 062700  000002          	add	#2,r0			; base csr address (SA)
     187 012654 010037  002016          	mov	r0,csr_sa		; save as SA address
     188 012660                         	call	adrchk			; check if responds
       1 012660 004737  025030          	jsr	pc,adrchk
     189 012664 103402                  	bcs	110$			; br if OK
     190 012666                         	call	300$			; error message
       1 012666 004737  012676          	jsr	pc,300$
     191                                
     192 012672 000137  013044          110$:	jmp	9999$			; next test
     193                                
     194                                	; - - - - - - - - - - - - - - - - - - - - - - - - -
     195                                
     196 012676                         300$:	printf	#1020$,testno,r0	; format, bad address
       1 012676                         	calls	printf #1020$ testno r0             
       8                                .list
       9 012676 010046                  	mov	r0,-(sp)
      14                                .list
      15 012700 013746  002036          	mov	testno,-(sp)
      20                                .list
      21 012704 012746  012777          	mov	#1020$,-(sp)
       1                                .list
       2 012710                         	call	printf
       1 012710 004737  025102          	jsr	pc,printf
       3 012714 062706  000006          	add	#6,sp
      18                                .list
     197 012720 005237  002020          	inc	errors			; incre error count
     198 012724                         	return				; return
       1 012724 000207                  	rts	pc
     199                                
     200                                	; - - - - - - - - - - - - - - - - - - - - - - - - -
     201                                
     202 012726    015     012     124  1010$:	.asciz	<cr><lf>"Test%d: basic MSCP controller access"<cr><lf>
         012731    145     163     164  
         012734    045     144     072  
         012737    040     142     141  
         012742    163     151     143  
         012745    040     115     123  
         012750    103     120     040  
         012753    143     157     156  
         012756    164     162     157  
         012761    154     154     145  
         012764    162     040     141  
         012767    143     143     145  
         012772    163     163     015  
         012775    012     000          
     203 012777    124     145     163  1020$:	.asciz	"Test%d: non-existent address %.6o"<cr><lf>
         013002    164     045     144  
         013005    072     040     156  
         013010    157     156     055  
         013013    145     170     151  
         013016    163     164     145  
         013021    156     164     040  
         013024    141     144     144  
         013027    162     145     163  
         013032    163     040     045  
         013035    056     066     157  
         013040    015     012     000  
     204 013043    000                  	.even
     205                                
     206 013044 005237  002036          9999$:	inc	testno			; to next test
     207                                
     208                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     209                                
     210 013050                         	test	<basic controller initialization sequence>
       1                                .list
       2                                
       3                                	;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       4                                	.sbttl	Test2 - basic controller initialization sequence
       5                                	;------------------------------------------------------------
       6                                
       7                                test2:	; start of test
       8                                
       9 013050 022737  000002  002036  	cmp	#2,testno		; check for sequence error
      10 013056 001401                  	beq	.+4			; OK, skip over halt
      11 013060 000000                  	halt				; FATAL - SEQUENCE ERROR
      18                                .list
     211                                
     212 013062                         	printf	#2010$,testno		; header message
       1 013062                         	calls	printf #2010$ testno              
       8                                .list
       9 013062 013746  002036          	mov	testno,-(sp)
      14                                .list
      15 013066 012746  013436          	mov	#2010$,-(sp)
       1                                .list
       2 013072                         	call	printf
       1 013072 004737  025102          	jsr	pc,printf
       3 013076 062706  000004          	add	#4,sp
      18                                .list
     213                                
     214 013102 012705  013350          	mov	#1010$,r5		; data structure
     215                                
     216 013106 013704  002014          	mov	csr_ip,r4		; base csr address (IP)
     217 013112 005024                  	clr	(r4)+			; start init sequence, bump to (SA)
     218                                
     219                                	; wait for SA step N
     220                                
     221 013114 011403                  100$:	mov	(r4),r3			; check SA contents
     222 013116 100013                  	bpl	110$			; ER error bit clear
     223                                
     224 013120                         	printf	#2011$,testno,(r5),r3	; format, expected, received
       1 013120                         	calls	printf #2011$ testno (r5) r3            
       8                                .list
       9 013120 010346                  	mov	r3,-(sp)
      14                                .list
      15 013122 011546                  	mov	(r5),-(sp)
      20                                .list
      21 013124 013746  002036          	mov	testno,-(sp)
      26                                .list
      27 013130 012746  013512          	mov	#2011$,-(sp)
       1                                .list
       2 013134                         	call	printf
       1 013134 004737  025102          	jsr	pc,printf
       3 013140 062706  000010          	add	#10,sp
      18                                .list
     225 013144 000472                  	br	390$			; exit
     226                                
     227 013146 036503  000002          110$:	bit	2(r5),r3		; check other state bits clear
     228 013152 001413                  	beq	120$			; br if OK
     229                                
     230 013154                         	printf	#2012$,testno,(r5),r3	; format, expected, received
       1 013154                         	calls	printf #2012$ testno (r5) r3            
       8                                .list
       9 013154 010346                  	mov	r3,-(sp)
      14                                .list
      15 013156 011546                  	mov	(r5),-(sp)
      20                                .list
      21 013160 013746  002036          	mov	testno,-(sp)
      26                                .list
      27 013164 012746  013623          	mov	#2012$,-(sp)
       1                                .list
       2 013170                         	call	printf
       1 013170 004737  025102          	jsr	pc,printf
       3 013174 062706  000010          	add	#10,sp
      18                                .list
     231 013200 000454                  	br	390$			; exit
     232                                
     233 013202 031503                  120$:	bit	(r5),r3			; check current state bit set
     234 013204 001743                  	beq	100$			; br if not yet
     235                                
     236                                	; SA step N - response at 0->1 transition
     237                                
     238 013206 020365  000004          	cmp	r3,4(r5)		; check rcv:exp
     239 013212 001416                  	beq	130$			; br if OK
     240                                
     241 013214                         	printf	#2013$,testno,(r5),4(r5),r3 ; format, state, expected, received
       1 013214                         	calls	printf #2013$ testno (r5) 4(r5) r3           
       8                                .list
       9 013214 010346                  	mov	r3,-(sp)
      14                                .list
      15 013216 016546  000004          	mov	4(r5),-(sp)
      20                                .list
      21 013222 011546                  	mov	(r5),-(sp)
      26                                .list
      27 013224 013746  002036          	mov	testno,-(sp)
      32                                .list
      33 013230 012746  013741          	mov	#2013$,-(sp)
       1                                .list
       2 013234                         	call	printf
       1 013234 004737  025102          	jsr	pc,printf
       3 013240 062706  000012          	add	#12,sp
      18                                .list
     242 013244 005237  002020          	inc	errors			; incre error count
     243                                
     244                                	; SA step N - send
     245                                
     246 013250 016514  000006          130$:	mov	6(r5),(r4)		; set step N send data
     247                                
     248                                	; SA step N - step complete at 1->0 transition
     249                                
     250 013254 016537  000010  002032  	mov	10(r5),dlycnt		; state must complete in this time
     251                                
     252 013262 005737  002032          140$:	tst	dlycnt			; has delay count expired?
     253 013266 003012                  	bgt	150$			; not yet
     254                                
     255 013270                         	printf	#2014$,testno,(r5)	; format, state
       1 013270                         	calls	printf #2014$ testno (r5)             
       8                                .list
       9 013270 011546                  	mov	(r5),-(sp)
      14                                .list
      15 013272 013746  002036          	mov	testno,-(sp)
      20                                .list
      21 013276 012746  014072          	mov	#2014$,-(sp)
       1                                .list
       2 013302                         	call	printf
       1 013302 004737  025102          	jsr	pc,printf
       3 013306 062706  000006          	add	#6,sp
      18                                .list
     256 013312 000407                  	br	390$			; exit
     257                                
     258 013314 031514                  150$:	bit	(r5),(r4)		; check current state bit cleared
     259 013316 001361                  	bne	140$			; loop if still set	
     260                                
     261 013320 062705  000012          	add	#1011$-1010$,r5		; next state
     262 013324 005715                  	tst	(r5)			; more states?
     263 013326 001272                  	bne	100$			; br if yes
     264 013330 000402                  	br	490$			; br if done
     265                                
     266                                	; done, reset controller and exit
     267                                
     268 013332 005237  002020          390$:	inc	errors			; incr error count
     269                                	
     270 013336 012777  000000  166450  490$:	mov	#0,@csr_ip		; reset controller
     271 013344 000137  014162          	jmp	9999$			; next test
     272                                
     273                                	; - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     274                                
     275                                	; step 1
     276                                
     277 013350 004000  070000          1010$:	.word	sa_st1, sa_st2+sa_st3+sa_st4
     278 013354 004400                  	.word	sa_st1+<0*sa_nsv>+<0*sa_a22>+<1*sa_edp>+<sa_opt*sa_rs0>
     279 013356 100000                  	.word	sa_stp+<0*sa_cl0>+<0*sa_rl0>+<0*sa_int>+<0*sa_vec>
     280 013360 001130                  	.word	10.*60.
     281                                
     282                                	; step 2
     283                                
     284 013362 010000  064000          1011$:	.word	sa_st2, sa_st1+sa_st3+sa_st4
     285 013366 010200                  	.word	sa_st2+<0*sa_cty>+<1*sa_ste>+<0*sa_cle>+<0*sa_rle>
     286 013370 013426                  	.word	1020$+<0*sa_prg>
     287 013372 001130                  	.word	10.*60.
     288                                
     289                                	; step 3
     290                                
     291 013374 020000  054000          1012$:	.word	sa_st3, sa_st1+sa_st2+sa_st4
     292 013400 020000                  	.word	sa_st3+<0*sa_vpe>+<0*sa_ine>+<0*sa_vee>
     293 013402 000000                  	.word	<0*sa_ppt>+<0*sa_rgh>
     294 013404 001130                  	.word	10.*60.
     295                                
     296                                	; step 4
     297                                
     298 013406 040000  034000          1013$:	.word	sa_st4, sa_st1+sa_st2+sa_st3
     299 013412 040146                  	.word	sa_st4+<sa_ctyp*sa_cn0>+<sa_ucv*sa_mc0>
     300 013414 000001                  	.word	<1*sa_go>
     301 013416 001130                  	.word	10.*60.
     302                                
     303 013420 000000                  1014$:	.word	0
     304                                
     305                                	; - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     306                                
     307 013422 000000  000000          	.word	0,0			; intr flags
     308 013426 012144  000000          1020$:	.word	rpkt,0			; rsp desc (host owned)
     309 013432 012232  000000          	.word	cpkt,0			; cmd desc (host owned)
     310                                
     311                                	; - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     312                                
     313 013436    015     012     124  2010$:	.asciz	<cr><lf>"Test%d: basic controller initialization"<cr><lf>
         013441    145     163     164  
         013444    045     144     072  
         013447    040     142     141  
         013452    163     151     143  
         013455    040     143     157  
         013460    156     164     162  
         013463    157     154     154  
         013466    145     162     040  
         013471    151     156     151  
         013474    164     151     141  
         013477    154     151     172  
         013502    141     164     151  
         013505    157     156     015  
         013510    012     000          
     314 013512    124     145     163  2011$:	.ascii	"Test%d: init ER bit set in SA register"<cr><lf>
         013515    164     045     144  
         013520    072     040     151  
         013523    156     151     164  
         013526    040     105     122  
         013531    040     142     151  
         013534    164     040     163  
         013537    145     164     040  
         013542    151     156     040  
         013545    123     101     040  
         013550    162     145     147  
         013553    151     163     164  
         013556    145     162     015  
         013561    012                  
     315 013562    040     040     105  	.ascii	"  Exp'ed  Rcv'ed"<cr><lf>
         013565    170     160     047  
         013570    145     144     040  
         013573    040     122     143  
         013576    166     047     145  
         013601    144     015     012  
     316 013604    040     040     045  	.asciz	"  %.6o  %.6o"<cr><lf>
         013607    056     066     157  
         013612    040     040     045  
         013615    056     066     157  
         013620    015     012     000  
     317 013623    124     145     163  2012$:	.ascii	"Test%d: S1-S4 sequence error in SA register"<cr><lf>
         013626    164     045     144  
         013631    072     040     123  
         013634    061     055     123  
         013637    064     040     163  
         013642    145     161     165  
         013645    145     156     143  
         013650    145     040     145  
         013653    162     162     157  
         013656    162     040     151  
         013661    156     040     123  
         013664    101     040     162  
         013667    145     147     151  
         013672    163     164     145  
         013675    162     015     012  
     318 013700    040     040     105  	.ascii	"  Exp'ed  Rcv'ed"<cr><lf>
         013703    170     160     047  
         013706    145     144     040  
         013711    040     122     143  
         013714    166     047     145  
         013717    144     015     012  
     319 013722    040     040     045  	.asciz	"  %.6o  %.6o"<cr><lf>
         013725    056     066     157  
         013730    040     040     045  
         013733    056     066     157  
         013736    015     012     000  
     320 013741    124     145     163  2013$:	.ascii	"Test%d: step response data compare error"<cr><lf>
         013744    164     045     144  
         013747    072     040     163  
         013752    164     145     160  
         013755    040     162     145  
         013760    163     160     157  
         013763    156     163     145  
         013766    040     144     141  
         013771    164     141     040  
         013774    143     157     155  
         013777    160     141     162  
         014002    145     040     145  
         014005    162     162     157  
         014010    162     015     012  
     321 014013    040     040     123  	.ascii	"  StpBit  Exp'ed  Rcv'ed"<cr><lf>
         014016    164     160     102  
         014021    151     164     040  
         014024    040     105     170  
         014027    160     047     145  
         014032    144     040     040  
         014035    122     143     166  
         014040    047     145     144  
         014043    015     012          
     322 014045    040     040     045  	.asciz	"  %.6o  %.6o  %.6o"<cr><lf>
         014050    056     066     157  
         014053    040     040     045  
         014056    056     066     157  
         014061    040     040     045  
         014064    056     066     157  
         014067    015     012     000  
     323 014072    124     145     163  2014$:	.ascii	"Test%d: step response timeout error"<cr><lf>
         014075    164     045     144  
         014100    072     040     163  
         014103    164     145     160  
         014106    040     162     145  
         014111    163     160     157  
         014114    156     163     145  
         014117    040     164     151  
         014122    155     145     157  
         014125    165     164     040  
         014130    145     162     162  
         014133    157     162     015  
         014136    012                  
     324 014137    040     040     123  	.ascii	"  StpBit"<cr><lf>
         014142    164     160     102  
         014145    151     164     015  
         014150    012                  
     325 014151    040     040     045  	.asciz	"  %.6o"<cr><lf>
         014154    056     066     157  
         014157    015     012     000  
     326                                	.even
     327                                
     328 014162 005237  002036          9999$:	inc	testno			; to next test
     329                                
     330                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     331                                
     332 014166                         	test	<check controller illegal opcode response>
       1                                .list
       2                                
       3                                	;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       4                                	.sbttl	Test3 - check controller illegal opcode response
       5                                	;------------------------------------------------------------
       6                                
       7                                test3:	; start of test
       8                                
       9 014166 022737  000003  002036  	cmp	#3,testno		; check for sequence error
      10 014174 001401                  	beq	.+4			; OK, skip over halt
      11 014176 000000                  	halt				; FATAL - SEQUENCE ERROR
      18                                .list
     333                                
     334 014200                         	printf	#2010$,testno		; header message
       1 014200                         	calls	printf #2010$ testno              
       8                                .list
       9 014200 013746  002036          	mov	testno,-(sp)
      14                                .list
      15 014204 012746  014514          	mov	#2010$,-(sp)
       1                                .list
       2 014210                         	call	printf
       1 014210 004737  025102          	jsr	pc,printf
       3 014214 062706  000004          	add	#4,sp
      18                                .list
     335                                
     336 014220                         	call	init			; init controller
       1 014220 004737  023712          	jsr	pc,init
     337 014224 103402                  	bcs	100$			; br if ok
     338 014226 000137  014502          	jmp	590$			; else error
     339                                
     340 014232                         100$:	call	bufini			; init buffers
       1 014232 004737  024714          	jsr	pc,bufini
     341                                
     342 014236 112737  000077  012242  	movb	#op_ill,cpkt+p_opcd	; set an illegal opcode
     343                                	
     344 014244 012737  000074  002032  	mov	#1.*60.,dlycnt		; timeout interval
     345 014252                         	call	wt4dun			; wait for done
       1 014252 004737  022612          	jsr	pc,wt4dun
     346 014256 103402                  	bcs	110$			; br if OK
     347 014260 000137  014456          	jmp	390$			; else error
     348                                
     349 014264                         110$:	call	dmphdr			; dump headers
       1 014264 004737  022704          	jsr	pc,dmphdr
     350                                
     351 014270 017700  165522          	mov	@csr_sa,r0		; check error status
     352 014274 100013                  	bpl	200$			; br if no error flagged
     353 014276                         	printf	#2014$,testno,r0	; error message
       1 014276                         	calls	printf #2014$ testno r0             
       8                                .list
       9 014276 010046                  	mov	r0,-(sp)
      14                                .list
      15 014300 013746  002036          	mov	testno,-(sp)
      20                                .list
      21 014304 012746  015036          	mov	#2014$,-(sp)
       1                                .list
       2 014310                         	call	printf
       1 014310 004737  025102          	jsr	pc,printf
       3 014314 062706  000006          	add	#6,sp
      18                                .list
     354 014320 005237  002020          	inc	errors			; count
     355                                
     356 014324 023737  002042  012144  200$:	cmp	refnum+0,rpkt+p_crf+0	; check lower refnum
     357 014332 001004                  	bne	210$			; br if error
     358 014334 023737  002044  012146  	cmp	refnum+2,rpkt+p_crf+2	; check higher refnum
     359 014342 001422                  	beq	220$			; br if OK
     360 014344                         210$:	printf	#2013$,testno,refnum+2,refnum+0,rpkt+p_crf+2,rpkt+p_crf+0 ; wrong status
       1 014344                         	calls	printf #2013$ testno refnum+2 refnum+0 rpkt+p_crf+2 rpkt+p_crf+0          
       8                                .list
       9 014344 013746  012144          	mov	rpkt+p_crf+0,-(sp)
      14                                .list
      15 014350 013746  012146          	mov	rpkt+p_crf+2,-(sp)
      20                                .list
      21 014354 013746  002042          	mov	refnum+0,-(sp)
      26                                .list
      27 014360 013746  002044          	mov	refnum+2,-(sp)
      32                                .list
      33 014364 013746  002036          	mov	testno,-(sp)
      38                                .list
      39 014370 012746  014731          	mov	#2013$,-(sp)
       1                                .list
       2 014374                         	call	printf
       1 014374 004737  025102          	jsr	pc,printf
       3 014400 062706  000014          	add	#14,sp
      18                                .list
     361 014404 005237  002020          	inc	errors			; count
     362                                
     363 014410 013700  012156          220$:	mov	rpkt+p_sts,r0		; get response status
     364 014414 012701  004001          	mov	#st_cmd+<p_opcd*400>,r1	; expected status
     365 014420 020001                  	cmp	r0,r1			; check
     366 014422 001427                  	beq	590$			; br if OK
     367 014424                         	printf	#2011$,testno,r1,r0	; wrong status
       1 014424                         	calls	printf #2011$ testno r1 r0            
       8                                .list
       9 014424 010046                  	mov	r0,-(sp)
      14                                .list
      15 014426 010146                  	mov	r1,-(sp)
      20                                .list
      21 014430 013746  002036          	mov	testno,-(sp)
      26                                .list
      27 014434 012746  014573          	mov	#2011$,-(sp)
       1                                .list
       2 014440                         	call	printf
       1 014440 004737  025102          	jsr	pc,printf
       3 014444 062706  000010          	add	#10,sp
      18                                .list
     368 014450 005237  002020          	inc	errors			; count
     369 014454 000412                  	br	590$			;
     370                                
     371 014456                         390$:	printf	#2012$,testno		; timeout!
       1 014456                         	calls	printf #2012$ testno              
       8                                .list
       9 014456 013746  002036          	mov	testno,-(sp)
      14                                .list
      15 014462 012746  014656          	mov	#2012$,-(sp)
       1                                .list
       2 014466                         	call	printf
       1 014466 004737  025102          	jsr	pc,printf
       3 014472 062706  000004          	add	#4,sp
      18                                .list
     372 014476 005237  002020          	inc	errors			; count
     373                                
     374 014502 012777  000000  165304  590$:	mov	#0,@csr_ip		; reset controller
     375 014510 000137  015110          	jmp	9999$			; next test
     376                                
     377                                	; - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     378                                
     379 014514    015     012     124  2010$:	.asciz	<cr><lf>"Test%d: controller illegal opcode response"<cr><lf>
         014517    145     163     164  
         014522    045     144     072  
         014525    040     143     157  
         014530    156     164     162  
         014533    157     154     154  
         014536    145     162     040  
         014541    151     154     154  
         014544    145     147     141  
         014547    154     040     157  
         014552    160     143     157  
         014555    144     145     040  
         014560    162     145     163  
         014563    160     157     156  
         014566    163     145     015  
         014571    012     000          
     380 014573    124     145     163  2011$:	.asciz	"Test%d: illegal opcode, status: exp=%#o, rcv=%#o"<cr><lf>
         014576    164     045     144  
         014601    072     040     151  
         014604    154     154     145  
         014607    147     141     154  
         014612    040     157     160  
         014615    143     157     144  
         014620    145     054     040  
         014623    163     164     141  
         014626    164     165     163  
         014631    072     040     145  
         014634    170     160     075  
         014637    045     043     157  
         014642    054     040     162  
         014645    143     166     075  
         014650    045     043     157  
         014653    015     012     000  
     381 014656    124     145     163  2012$:	.asciz	"Test%d: illegal opcode, response timeout"<cr><lf>
         014661    164     045     144  
         014664    072     040     151  
         014667    154     154     145  
         014672    147     141     154  
         014675    040     157     160  
         014700    143     157     144  
         014703    145     054     040  
         014706    162     145     163  
         014711    160     157     156  
         014714    163     145     040  
         014717    164     151     155  
         014722    145     157     165  
         014725    164     015     012  
         014730    000                  
     382 014731    124     145     163  2013$:	.asciz	"Test%d: illegal opcode, refnum error, exp=%.6o,%.6o, rcv=%.6o,%.6o"<cr><lf>
         014734    164     045     144  
         014737    072     040     151  
         014742    154     154     145  
         014745    147     141     154  
         014750    040     157     160  
         014753    143     157     144  
         014756    145     054     040  
         014761    162     145     146  
         014764    156     165     155  
         014767    040     145     162  
         014772    162     157     162  
         014775    054     040     145  
         015000    170     160     075  
         015003    045     056     066  
         015006    157     054     045  
         015011    056     066     157  
         015014    054     040     162  
         015017    143     166     075  
         015022    045     056     066  
         015025    157     054     045  
         015030    056     066     157  
         015033    015     012     000  
     383 015036    124     145     163  2014$:	.asciz	"Test%d: illegal opcode, fatal error %#o"<cr><lf>
         015041    164     045     144  
         015044    072     040     151  
         015047    154     154     145  
         015052    147     141     154  
         015055    040     157     160  
         015060    143     157     144  
         015063    145     054     040  
         015066    146     141     164  
         015071    141     154     040  
         015074    145     162     162  
         015077    157     162     040  
         015102    045     043     157  
         015105    015     012     000  
     384                                	.even
     385                                
     386 015110 005237  002036          9999$:	inc	testno			; to next test
     387                                
     388                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     389                                
     390 015114                         	test	<check online units>
       1                                .list
       2                                
       3                                	;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       4                                	.sbttl	Test4 - check online units
       5                                	;------------------------------------------------------------
       6                                
       7                                test4:	; start of test
       8                                
       9 015114 022737  000004  002036  	cmp	#4,testno		; check for sequence error
      10 015122 001401                  	beq	.+4			; OK, skip over halt
      11 015124 000000                  	halt				; FATAL - SEQUENCE ERROR
      18                                .list
     391                                
     392 015126                         	printf	#2010$,testno		; header message
       1 015126                         	calls	printf #2010$ testno              
       8                                .list
       9 015126 013746  002036          	mov	testno,-(sp)
      14                                .list
      15 015132 012746  015706          	mov	#2010$,-(sp)
       1                                .list
       2 015136                         	call	printf
       1 015136 004737  025102          	jsr	pc,printf
       3 015142 062706  000004          	add	#4,sp
      18                                .list
     393                                
     394 015146 005037  002040          	clr	unitno			; init unit number
     395 015152 112737  177777  002116  	movb	#-1,online		; all units 0..7 online to start
     396                                
     397 015160                         	call	init			; init controller
       1 015160 004737  023712          	jsr	pc,init
     398 015164 103402                  	bcs	100$			; br if OK
     399 015166 000137  015664          	jmp	590$			; else error
     400                                
     401 015172                         100$:	call	bufini			; init buffers
       1 015172 004737  024714          	jsr	pc,bufini
     402                                
     403 015176 112737  000011  012242  	movb	#op_onl,cpkt+p_opcd	; set opcode
     404 015204 013737  002040  012236  	mov	unitno,cpkt+p_unit	; set unit
     405                                	
     406 015212 012737  001130  002032  	mov	#10.*60.,dlycnt		; timeout interval
     407 015220                         	call	wt4dun			; wait for done
       1 015220 004737  022612          	jsr	pc,wt4dun
     408 015224 103402                  	bcs	110$			; br if ok
     409 015226 000137  015640          	jmp	390$			; else error
     410                                
     411 015232                         110$:	call	dmphdr			; dump headers
       1 015232 004737  022704          	jsr	pc,dmphdr
     412                                
     413 015236 017700  164554          	mov	@csr_sa,r0		; check error status
     414 015242 100015                  	bpl	200$			; br if no error flagged
     415 015244                         	printf	#2014$,testno,unitno,r0	; error message
       1 015244                         	calls	printf #2014$ testno unitno r0            
       8                                .list
       9 015244 010046                  	mov	r0,-(sp)
      14                                .list
      15 015246 013746  002040          	mov	unitno,-(sp)
      20                                .list
      21 015252 013746  002036          	mov	testno,-(sp)
      26                                .list
      27 015256 012746  016016          	mov	#2014$,-(sp)
       1                                .list
       2 015262                         	call	printf
       1 015262 004737  025102          	jsr	pc,printf
       3 015266 062706  000010          	add	#10,sp
      18                                .list
     416 015272 005237  002020          	inc	errors			; count
     417                                
     418 015276 023737  002042  012144  200$:	cmp	refnum+0,rpkt+p_crf+0	; check lower refnum
     419 015304 001004                  	bne	210$			; br if error
     420 015306 023737  002044  012146  	cmp	refnum+2,rpkt+p_crf+2	; check higher refnum
     421 015314 001424                  	beq	220$			; br if OK
     422 015316                         210$:	printf	#2017$,testno,unitno,refnum+2,refnum+0,rpkt+p_crf+2,rpkt+p_crf+0 ; wrong status
       1 015316                         	calls	printf #2017$ testno unitno refnum+2 refnum+0 rpkt+p_crf+2 rpkt+p_crf+0         
       8                                .list
       9 015316 013746  012144          	mov	rpkt+p_crf+0,-(sp)
      14                                .list
      15 015322 013746  012146          	mov	rpkt+p_crf+2,-(sp)
      20                                .list
      21 015326 013746  002042          	mov	refnum+0,-(sp)
      26                                .list
      27 015332 013746  002044          	mov	refnum+2,-(sp)
      32                                .list
      33 015336 013746  002040          	mov	unitno,-(sp)
      38                                .list
      39 015342 013746  002036          	mov	testno,-(sp)
      44                                .list
      45 015346 012746  016276          	mov	#2017$,-(sp)
       1                                .list
       2 015352                         	call	printf
       1 015352 004737  025102          	jsr	pc,printf
       3 015356 062706  000016          	add	#16,sp
      18                                .list
     423 015362 005237  002020          	inc	errors			; count
     424                                
     425 015366 122737  000000  012156  220$:	cmpb	#st_suc,rpkt+p_sts	; success status?
     426 015374 001423                  	beq	230$			; br if OK
     427 015376                         	printf	#2016$,testno,unitno,rpkt+p_sts ; no unit present
       1 015376                         	calls	printf #2016$ testno unitno rpkt+p_sts            
       8                                .list
       9 015376 013746  012156          	mov	rpkt+p_sts,-(sp)
      14                                .list
      15 015402 013746  002040          	mov	unitno,-(sp)
      20                                .list
      21 015406 013746  002036          	mov	testno,-(sp)
      26                                .list
      27 015412 012746  016205          	mov	#2016$,-(sp)
       1                                .list
       2 015416                         	call	printf
       1 015416 004737  025102          	jsr	pc,printf
       3 015422 062706  000010          	add	#10,sp
      18                                .list
     428 015426 005000                  	clr	r0			; constant 0
     429 015430 005200                  	inc	r0			; constant 1
     430 015432 072037  002040          	ash	unitno,r0		; shift 1 by bit number
     431 015436 140037  002116          	bicb	r0,online		; clear online status
     432 015442 000466                  	br	290$			; next unit
     433                                
     434 015444 013737  012200  015704  230$:	mov	rpkt+p_medi+0,1020$	; get LSB
     435 015452 042737  177600  015704  	bic	#^c177,1020$		; extract numerics
     436 015460 013700  012202          	mov	rpkt+p_medi+2,r0	; get MSB
     437 015464 013701  012200          	mov	rpkt+p_medi+0,r1	; get LSB
     438 015470 073027  177771          	ashc	#-7,r0			; (r0,r1)>>7
     439 015474 012702  015703          	mov	#1010$+5,r2		; ptr to string
     440 015500 010104                  240$:	mov	r1,r4			; get LSB
     441 015502 042704  177740          	bic	#^c37,r4		; get low 5 bits
     442 015506 001402                  	beq	250$			; zero is unused
     443 015510 062704  000100          	add	#<'A>-1,r4		; make ascii	
     444 015514 110442                  250$:	movb	r4,-(r2)		; store character
     445 015516 073027  177773          	ashc	#-5,r0			; (r0,r1)>>5
     446 015522 001366                  	bne	240$			; br if more
     447 015524                         	printf	#2015$,testno,unitno,rpkt+p_unsz+2,rpkt+p_unsz+0,#1010$+0,#1010$+2,1020$
       1 015524                         	calls	printf #2015$ testno unitno rpkt+p_unsz+2 rpkt+p_unsz+0 #1010$+0 #1010$+2 1020$        
       8                                .list
       9 015524 013746  015704          	mov	1020$,-(sp)
      14                                .list
      15 015530 012746  015700          	mov	#1010$+2,-(sp)
      20                                .list
      21 015534 012746  015676          	mov	#1010$+0,-(sp)
      26                                .list
      27 015540 013746  012210          	mov	rpkt+p_unsz+0,-(sp)
      32                                .list
      33 015544 013746  012212          	mov	rpkt+p_unsz+2,-(sp)
      38                                .list
      39 015550 013746  002040          	mov	unitno,-(sp)
      44                                .list
      45 015554 013746  002036          	mov	testno,-(sp)
      50                                .list
      51 015560 012746  016077          	mov	#2015$,-(sp)
       1                                .list
       2 015564                         	call	printf
       1 015564 004737  025102          	jsr	pc,printf
       3 015570 062706  000020          	add	#20,sp
      18                                .list
     448 015574 013702  002040          	mov	unitno,r2		; unit number
     449 015600 006302                  	asl	r2			; x2
     450 015602 006302                  	asl	r2			; x4
     451 015604 013762  012210  002056  	mov	rpkt+p_unsz+0,devsiz+0(r2) ; store device block count, lo
     452 015612 013762  012212  002060  	mov	rpkt+p_unsz+2,devsiz+2(r2) ; store device block count, hi
     453                                
     454 015620 005237  002040          290$:	inc	unitno			; bump unit number
     455 015624 023727  002040  000007  	cmp	unitno,#7		; check for maximum
     456 015632 003014                  	bgt	590$			; done
     457 015634 000137  015172          	jmp	100$			; br if unit num is OK
     458                                
     459 015640                         390$:	printf	#2012$,testno		; timeout!
       1 015640                         	calls	printf #2012$ testno              
       8                                .list
       9 015640 013746  002036          	mov	testno,-(sp)
      14                                .list
      15 015644 012746  015745          	mov	#2012$,-(sp)
       1                                .list
       2 015650                         	call	printf
       1 015650 004737  025102          	jsr	pc,printf
       3 015654 062706  000004          	add	#4,sp
      18                                .list
     460 015660 005237  002020          	inc	errors			; count
     461                                
     462 015664 012777  000000  164122  590$:	mov	#0,@csr_ip		; reset controller
     463 015672 000137  016412          	jmp	9999$			; next test
     464                                
     465                                	; - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     466                                
     467 015676    104     104     101  1010$:	.asciz	"DDAAA"
         015701    101     101     000  
     468        015704                  1020$:	.blkw	1.
     469                                	
     470 015706    015     012     124  2010$:	.asciz	<cr><lf>"Test%d: check online units"<cr><lf>
         015711    145     163     164  
         015714    045     144     072  
         015717    040     143     150  
         015722    145     143     153  
         015725    040     157     156  
         015730    154     151     156  
         015733    145     040     165  
         015736    156     151     164  
         015741    163     015     012  
         015744    000                  
     471 015745    124     145     163  2012$:	.asciz	"Test%d: online check, response timeout"<cr><lf>
         015750    164     045     144  
         015753    072     040     157  
         015756    156     154     151  
         015761    156     145     040  
         015764    143     150     145  
         015767    143     153     054  
         015772    040     162     145  
         015775    163     160     157  
         016000    156     163     145  
         016003    040     164     151  
         016006    155     145     157  
         016011    165     164     015  
         016014    012     000          
     472 016016    124     145     163  2014$:	.asciz	"Test%d: online check, unit=%d, fatal error %#o"<cr><lf>
         016021    164     045     144  
         016024    072     040     157  
         016027    156     154     151  
         016032    156     145     040  
         016035    143     150     145  
         016040    143     153     054  
         016043    040     165     156  
         016046    151     164     075  
         016051    045     144     054  
         016054    040     146     141  
         016057    164     141     154  
         016062    040     145     162  
         016065    162     157     162  
         016070    040     045     043  
         016073    157     015     012  
         016076    000                  
     473 016077    124     145     163  2015$:	.asciz	"Test%d: online check, unit=%d, blkcount=%lu., mediatype=%.2s:%.3s%d"<cr><lf>
         016102    164     045     144  
         016105    072     040     157  
         016110    156     154     151  
         016113    156     145     040  
         016116    143     150     145  
         016121    143     153     054  
         016124    040     165     156  
         016127    151     164     075  
         016132    045     144     054  
         016135    040     142     154  
         016140    153     143     157  
         016143    165     156     164  
         016146    075     045     154  
         016151    165     056     054  
         016154    040     155     145  
         016157    144     151     141  
         016162    164     171     160  
         016165    145     075     045  
         016170    056     062     163  
         016173    072     045     056  
         016176    063     163     045  
         016201    144     015     012  
         016204    000                  
     474 016205    124     145     163  2016$:	.asciz	"Test%d: online check, unit=%d, not present, status=%#o"<cr><lf>
         016210    164     045     144  
         016213    072     040     157  
         016216    156     154     151  
         016221    156     145     040  
         016224    143     150     145  
         016227    143     153     054  
         016232    040     165     156  
         016235    151     164     075  
         016240    045     144     054  
         016243    040     156     157  
         016246    164     040     160  
         016251    162     145     163  
         016254    145     156     164  
         016257    054     040     163  
         016262    164     141     164  
         016265    165     163     075  
         016270    045     043     157  
         016273    015     012     000  
     475 016276    124     145     163  2017$:	.asciz	"Test%d: online check, unit=%d, refnum error, exp=%.6o,%.6o, rcv=%.6o,%.6o"<cr><lf>
         016301    164     045     144  
         016304    072     040     157  
         016307    156     154     151  
         016312    156     145     040  
         016315    143     150     145  
         016320    143     153     054  
         016323    040     165     156  
         016326    151     164     075  
         016331    045     144     054  
         016334    040     162     145  
         016337    146     156     165  
         016342    155     040     145  
         016345    162     162     157  
         016350    162     054     040  
         016353    145     170     160  
         016356    075     045     056  
         016361    066     157     054  
         016364    045     056     066  
         016367    157     054     040  
         016372    162     143     166  
         016375    075     045     056  
         016400    066     157     054  
         016403    045     056     066  
         016406    157     015     012  
         016411    000                  
     476                                	.even
     477                                
     478 016412 005237  002036          9999$:	inc	testno			; to next test
     479                                
     480                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     481                                
     482 016416                         	test	<M9312 basic boot sequence>
       1                                .list
       2                                
       3                                	;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       4                                	.sbttl	Test5 - M9312 basic boot sequence
       5                                	;------------------------------------------------------------
       6                                
       7                                test5:	; start of test
       8                                
       9 016416 022737  000005  002036  	cmp	#5,testno		; check for sequence error
      10 016424 001401                  	beq	.+4			; OK, skip over halt
      11 016426 000000                  	halt				; FATAL - SEQUENCE ERROR
      18                                .list
     483                                
     484 016430                         	printf	#2010$,testno		; header message
       1 016430                         	calls	printf #2010$ testno              
       8                                .list
       9 016430 013746  002036          	mov	testno,-(sp)
      14                                .list
      15 016434 012746  017306          	mov	#2010$,-(sp)
       1                                .list
       2 016440                         	call	printf
       1 016440 004737  025102          	jsr	pc,printf
       3 016444 062706  000004          	add	#4,sp
      18                                .list
     485                                
     486 016450 005000                  	clr	r0			; unit number
     487                                
     488 016452 005001                  10$:	clr	r1			; constant 0
     489 016454 005201                  	inc	r1			; constant 1
     490 016456 072100                  	ash	r0,r1			; shift 1 by bit number
     491 016460 130137  002116          	bitb	r1,online		; check if online or not
     492 016464 001002                  	bne	20$			; br if yes
     493 016466 000137  017206          	jmp	400$			; not online
     494                                
     495 016472 013701  002014          20$:	mov	csr_ip,r1		; ptr to csr
     496 016476 010021                  	mov	r0,(r1)+		; init controller (write IP), bump ptr
     497 016500 012705  004000          	mov	#sa_st1,r5		; S1 state bitmask
     498 016504 012703  017272          	mov	#1010$,r3		; [MOD] point to data table
     499                                
     500 016510 005711                  100$:	tst	(r1)			; error bit set ?
     501 016512 100013                  	bpl	130$			; [MOD] br if OK
     502 016514                         	printf	#2011$,testno,r0		; [ADD] controller init error exit
       1 016514                         	calls	printf #2011$ testno r0             
       8                                .list
       9 016514 010046                  	mov	r0,-(sp)
      14                                .list
      15 016516 013746  002036          	mov	testno,-(sp)
      20                                .list
      21 016522 012746  017354          	mov	#2011$,-(sp)
       1                                .list
       2 016526                         	call	printf
       1 016526 004737  025102          	jsr	pc,printf
       3 016532 062706  000006          	add	#6,sp
      18                                .list
     503 016536 000137  017254          	jmp	580$			; [ADD] and die
     504 016542 031105                  130$:	bit	(r1),r5			; step bit set ?
     505 016544 001761                  	beq	100$			; not yet, wait loop
     506 016546 012311                  	mov	(r3)+,(r1)		; send next init data
     507 016550 006305                  	asl	r5			; next mask
     508 016552 100356                  	bpl	100$			; s4 done ? br if not yet
     509                                
     510 016554 012702  002120          110$:	mov	#buffer,r2		; [MOD] set buffer start
     511 016560 005022                  120$:	clr	(r2)+			; clear buffer
     512 016562 020227  012126          	cmp	r2,#comm		; check for end of buffer
     513 016566 001374                  	bne	120$			; loop if not done
     514                                
     515 016570 010237  012226          	mov	r2,cpkt-4		; set intr
     516 016574 112337  012242          	movb	(r3)+,cpkt+10		; set command
     517 016600 111337  012247          	movb	(r3),cpkt+15		; set bytecnt(hi)
     518 016604 010037  012236          	mov	r0,cpkt+4		; set unit
     519 016610 012737  002120  012252  	mov	#buffer,cpkt+p_buff	; [ADD] set buffer address
     520 016616 032737  000001  002022  	bit	#1,passes		; [ADD] check if odd pass
     521 016624 001003                  	bne	150$			; [ADD] br if odd pass
     522 016626 052737  040000  012244  	bis	#md_cmp,cpkt+p_mod	; [ADD] set compare after read option
     523 016634 012722  012144          150$:	mov	#rpkt,(r2)+		; rq desc addr
     524 016640 010522                  	mov	r5,(r2)+		; rq own bit15
     525 016642 012722  012232          	mov	#cpkt,(r2)+		; cp desc addr
     526 016646 010522                  	mov	r5,(r2)+		; cq own bit15
     527 016650 016102  177776          	mov	-2(r1),r2		; wake controller (read IP)
     528                                
     529 016654 005737  012130          200$:	tst	comm+2			; rq own controller ?
     530 016660 100775                  	bmi	200$			; loop if not done
     531 016662                         	call	dmphdr			; [ADD] print cmd/resp buffers
       1 016662 004737  022704          	jsr	pc,dmphdr
     532 016666 017702  163124          	mov	@csr_sa,r2		; [ADD] check error status
     533 016672 100014                  	bpl	160$			; [ADD] br if no error flagged
     534 016674                         	printf	#2017$,testno,r0,r2	; [ADD] error message
       1 016674                         	calls	printf #2017$ testno r0 r2            
       8                                .list
       9 016674 010246                  	mov	r2,-(sp)
      14                                .list
      15 016676 010046                  	mov	r0,-(sp)
      20                                .list
      21 016700 013746  002036          	mov	testno,-(sp)
      26                                .list
      27 016704 012746  020144          	mov	#2017$,-(sp)
       1                                .list
       2 016710                         	call	printf
       1 016710 004737  025102          	jsr	pc,printf
       3 016714 062706  000010          	add	#10,sp
      18                                .list
     535 016720 005237  002020          	inc	errors			; [ADD] count
     536 016724 005002                  160$:	clr	r2			; [ADD] zap
     537 016726 153702  012242          	bisb	cpkt+p_opcd,r2		; [ADD] get original command byte
     538 016732 152702  000200          	bisb	#op_end,r2		; [ADD] make an end-command version
     539 016736 120237  012154          	cmpb	r2,rpkt+p_opcd		; [ADD] should match response packet
     540 016742 001416                  	beq	210$			; [ADD] br if OK
     541 016744                         	printf	#2013$,testno,r0,r2,rpkt+p_opcd ; [ADD] warning, response cmd error
       1 016744                         	calls	printf #2013$ testno r0 r2 rpkt+p_opcd           
       8                                .list
       9 016744 013746  012154          	mov	rpkt+p_opcd,-(sp)
      14                                .list
      15 016750 010246                  	mov	r2,-(sp)
      20                                .list
      21 016752 010046                  	mov	r0,-(sp)
      26                                .list
      27 016754 013746  002036          	mov	testno,-(sp)
      32                                .list
      33 016760 012746  017551          	mov	#2013$,-(sp)
       1                                .list
       2 016764                         	call	printf
       1 016764 004737  025102          	jsr	pc,printf
       3 016770 062706  000012          	add	#12,sp
      18                                .list
     542 016774 005237  002020          	inc	errors			; [ADD] error
     543                                
     544 017000 122737  000011  012242  210$:	cmpb	#op_onl,cpkt+p_opcd	; [ADD] ONLINE command?
     545 017006 001024                  	bne	230$			; [ADD] br if not
     546 017010 122737  000043  012156  	cmpb	#40!st_ofl,rpkt+p_sts	; [ADD] UNIT OFFLINE result?
     547 017016 001404                  	beq	220$			; [ADD] br if yes
     548 017020 122737  000003  012156  	cmpb	#st_ofl,rpkt+p_sts	; [ADD] UNIT UNKNOWN result?
     549 017026 001043                  	bne	300$			; [ADD] br if yes
     550 017030                         220$:	printf	#2016$,testno,r0,rpkt+p_sts ; [ADD] no unit present
       1 017030                         	calls	printf #2016$ testno r0 rpkt+p_sts            
       8                                .list
       9 017030 013746  012156          	mov	rpkt+p_sts,-(sp)
      14                                .list
      15 017034 010046                  	mov	r0,-(sp)
      20                                .list
      21 017036 013746  002036          	mov	testno,-(sp)
      26                                .list
      27 017042 012746  020061          	mov	#2016$,-(sp)
       1                                .list
       2 017046                         	call	printf
       1 017046 004737  025102          	jsr	pc,printf
       3 017052 062706  000010          	add	#10,sp
      18                                .list
     551 017056 000453                  	br	400$			; [ADD] else OK
     552                                
     553 017060 122737  000041  012242  230$:	cmpb	#op_rd,cpkt+p_opcd	; [ADD] READ command?
     554 017066 001023                  	bne	300$			; [ADD] br if not
     555 017070 023737  012246  012160  	cmp	cpkt+p_bcnt,rpkt+p_bcnt	; [ADD] bytecount asked/rcved must match
     556 017076 001417                  	beq	300$			; [ADD] br if OK
     557 017100                         	printf	#2014$,testno,r0,cpkt+p_bcnt,rpkt+p_bcnt ; [ADD] warning, response cmd error
       1 017100                         	calls	printf #2014$ testno r0 cpkt+p_bcnt rpkt+p_bcnt           
       8                                .list
       9 017100 013746  012160          	mov	rpkt+p_bcnt,-(sp)
      14                                .list
      15 017104 013746  012246          	mov	cpkt+p_bcnt,-(sp)
      20                                .list
      21 017110 010046                  	mov	r0,-(sp)
      26                                .list
      27 017112 013746  002036          	mov	testno,-(sp)
      32                                .list
      33 017116 012746  017657          	mov	#2014$,-(sp)
       1                                .list
       2 017122                         	call	printf
       1 017122 004737  025102          	jsr	pc,printf
       3 017126 062706  000012          	add	#12,sp
      18                                .list
     558 017132 005237  002020          	inc	errors			; [ADD] error
     559                                
     560 017136 105737  012156          300$:	tstb	rpkt+p_sts		; check for error ?
     561 017142 001027                  	bne	510$			; yup, fail back to begin to retry
     562                                
     563 017144 105723                  	tstb	(r3)+			; check end of table ?
     564 017146 001602                  	beq	110$			; br if not yet
     565 017150                         	printf	#2015$,testno,r0,rpkt+p_bcnt+2,rpkt+p_bcnt+0 ; [ADD] indicate success
       1 017150                         	calls	printf #2015$ testno r0 rpkt+p_bcnt+2 rpkt+p_bcnt+0           
       8                                .list
       9 017150 013746  012160          	mov	rpkt+p_bcnt+0,-(sp)
      14                                .list
      15 017154 013746  012162          	mov	rpkt+p_bcnt+2,-(sp)
      20                                .list
      21 017160 010046                  	mov	r0,-(sp)
      26                                .list
      27 017162 013746  002036          	mov	testno,-(sp)
      32                                .list
      33 017166 012746  017767          	mov	#2015$,-(sp)
       1                                .list
       2 017172                         	call	printf
       1 017172 004737  025102          	jsr	pc,printf
       3 017176 062706  000012          	add	#12,sp
      18                                .list
     566 017202                         	call	dmpbuf			; [ADD] print boot data block
       1 017202 004737  023342          	jsr	pc,dmpbuf
     567                                
     568 017206 005200                  400$:	inc	r0			; [ADD] bump unit number
     569 017210 020027  000007          	cmp	r0,#7			; [ADD] check for maximum
     570 017214 003021                  	bgt	590$			; [ADD] all done
     571 017216 000137  016452          	jmp	10$			; [ADD] br if unit num is OK
     572                                
     573                                	; command error exit
     574 017222                         510$:	printf	#2012$,testno,r0,cpkt+p_opcd,rpkt+p_sts ; command error exit
       1 017222                         	calls	printf #2012$ testno r0 cpkt+p_opcd rpkt+p_sts           
       8                                .list
       9 017222 013746  012156          	mov	rpkt+p_sts,-(sp)
      14                                .list
      15 017226 013746  012242          	mov	cpkt+p_opcd,-(sp)
      20                                .list
      21 017232 010046                  	mov	r0,-(sp)
      26                                .list
      27 017234 013746  002036          	mov	testno,-(sp)
      32                                .list
      33 017240 012746  017443          	mov	#2012$,-(sp)
       1                                .list
       2 017244                         	call	printf
       1 017244 004737  025102          	jsr	pc,printf
       3 017250 062706  000012          	add	#12,sp
      18                                .list
     575                                
     576                                	; error exit
     577 017254 005237  002020          580$:	inc	errors			; error
     578                                	; normal exit
     579 017260 012777  000000  162526  590$:	mov	#0,@csr_ip		; reset controller
     580 017266 000137  020222          	jmp	9999$			; next test
     581                                
     582                                	; - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     583                                
     584                                	; MSCP init data
     585                                
     586 017272 100000                  1010$:	.word	sa_stp			; S1: no int, ring size 1, no vector
     587 017274 012126                  	.word	comm			; S2: ringbase lo addr
     588 017276 000000                  	.word	0			; S3: no purge/poll, ringbase hi addr
     589 017300 000001                  	.word	sa_go			; S4: go bit
     590                                
     591                                	; MSCP command data
     592                                
     593 017302    011     000          1020$:	.byte	op_onl,000		; cmd=online, bytecnt_hi=000(0)
     594 017304    041     002          	.byte	op_rd,002		; cmd=read, bytecnt_hi=002(512)
     595                                
     596                                	; - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     597                                
     598 017306    015     012     124  2010$:	.asciz	<cr><lf>"Test%d: M9312 basic boot sequence"<cr><lf>
         017311    145     163     164  
         017314    045     144     072  
         017317    040     115     071  
         017322    063     061     062  
         017325    040     142     141  
         017330    163     151     143  
         017333    040     142     157  
         017336    157     164     040  
         017341    163     145     161  
         017344    165     145     156  
         017347    143     145     015  
         017352    012     000          
     599 017354    124     145     163  2011$:	.asciz	"Test%d: ERROR bit set during initialization, unit=%d"<cr><lf>
         017357    164     045     144  
         017362    072     040     105  
         017365    122     122     117  
         017370    122     040     142  
         017373    151     164     040  
         017376    163     145     164  
         017401    040     144     165  
         017404    162     151     156  
         017407    147     040     151  
         017412    156     151     164  
         017415    151     141     154  
         017420    151     172     141  
         017423    164     151     157  
         017426    156     054     040  
         017431    165     156     151  
         017434    164     075     045  
         017437    144     015     012  
         017442    000                  
     600 017443    124     145     163  2012$:	.asciz	"Test%d: ERROR during command execution, unit=%d, cmd=%#o, error=%#o"<cr><lf>
         017446    164     045     144  
         017451    072     040     105  
         017454    122     122     117  
         017457    122     040     144  
         017462    165     162     151  
         017465    156     147     040  
         017470    143     157     155  
         017473    155     141     156  
         017476    144     040     145  
         017501    170     145     143  
         017504    165     164     151  
         017507    157     156     054  
         017512    040     165     156  
         017515    151     164     075  
         017520    045     144     054  
         017523    040     143     155  
         017526    144     075     045  
         017531    043     157     054  
         017534    040     145     162  
         017537    162     157     162  
         017542    075     045     043  
         017545    157     015     012  
         017550    000                  
     601 017551    124     145     163  2013$:	.asciz	"Test%d: ERROR incorrect response command, unit=%d, exp=%#o, rcv=%#o"<cr><lf>
         017554    164     045     144  
         017557    072     040     105  
         017562    122     122     117  
         017565    122     040     151  
         017570    156     143     157  
         017573    162     162     145  
         017576    143     164     040  
         017601    162     145     163  
         017604    160     157     156  
         017607    163     145     040  
         017612    143     157     155  
         017615    155     141     156  
         017620    144     054     040  
         017623    165     156     151  
         017626    164     075     045  
         017631    144     054     040  
         017634    145     170     160  
         017637    075     045     043  
         017642    157     054     040  
         017645    162     143     166  
         017650    075     045     043  
         017653    157     015     012  
         017656    000                  
     602 017657    124     145     163  2014$:	.asciz	"Test%d: ERROR incorrect response bytecount, unit=%d, exp=%#o, rcv=%#o"<cr><lf>
         017662    164     045     144  
         017665    072     040     105  
         017670    122     122     117  
         017673    122     040     151  
         017676    156     143     157  
         017701    162     162     145  
         017704    143     164     040  
         017707    162     145     163  
         017712    160     157     156  
         017715    163     145     040  
         017720    142     171     164  
         017723    145     143     157  
         017726    165     156     164  
         017731    054     040     165  
         017734    156     151     164  
         017737    075     045     144  
         017742    054     040     145  
         017745    170     160     075  
         017750    045     043     157  
         017753    054     040     162  
         017756    143     166     075  
         017761    045     043     157  
         017764    015     012     000  
     603 017767    124     145     163  2015$:	.asciz	"Test%d: bootblock read success, unit=%d, bytecount=%ld."<cr><lf>
         017772    164     045     144  
         017775    072     040     142  
         020000    157     157     164  
         020003    142     154     157  
         020006    143     153     040  
         020011    162     145     141  
         020014    144     040     163  
         020017    165     143     143  
         020022    145     163     163  
         020025    054     040     165  
         020030    156     151     164  
         020033    075     045     144  
         020036    054     040     142  
         020041    171     164     145  
         020044    143     157     165  
         020047    156     164     075  
         020052    045     154     144  
         020055    056     015     012  
         020060    000                  
     604 020061    124     145     163  2016$:	.asciz	"Test%d: no device present, unit=%d, status=%#03o"<cr><lf>
         020064    164     045     144  
         020067    072     040     156  
         020072    157     040     144  
         020075    145     166     151  
         020100    143     145     040  
         020103    160     162     145  
         020106    163     145     156  
         020111    164     054     040  
         020114    165     156     151  
         020117    164     075     045  
         020122    144     054     040  
         020125    163     164     141  
         020130    164     165     163  
         020133    075     045     043  
         020136    060     063     157  
         020141    015     012     000  
     605 020144    124     145     163  2017$:	.asciz	"Test%d: boot read, unit=%d, fatal error %#o"<cr><lf>
         020147    164     045     144  
         020152    072     040     142  
         020155    157     157     164  
         020160    040     162     145  
         020163    141     144     054  
         020166    040     165     156  
         020171    151     164     075  
         020174    045     144     054  
         020177    040     146     141  
         020202    164     141     154  
         020205    040     145     162  
         020210    162     157     162  
         020213    040     045     043  
         020216    157     015     012  
         020221    000                  
     606                                	.even
     607                                
     608 020222 005237  002036          9999$:	inc	testno			; to next test
     609                                
     610                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     611                                
     612 020226                         	test	<sequential block read>
       1                                .list
       2                                
       3                                	;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       4                                	.sbttl	Test6 - sequential block read
       5                                	;------------------------------------------------------------
       6                                
       7                                test6:	; start of test
       8                                
       9 020226 022737  000006  002036  	cmp	#6,testno		; check for sequence error
      10 020234 001401                  	beq	.+4			; OK, skip over halt
      11 020236 000000                  	halt				; FATAL - SEQUENCE ERROR
      18                                .list
     613                                
     614 020240                         	printf	#2010$,testno		; header message
       1 020240                         	calls	printf #2010$ testno              
       8                                .list
       9 020240 013746  002036          	mov	testno,-(sp)
      14                                .list
      15 020244 012746  021324          	mov	#2010$,-(sp)
       1                                .list
       2 020250                         	call	printf
       1 020250 004737  025102          	jsr	pc,printf
       3 020254 062706  000004          	add	#4,sp
      18                                .list
     615                                
     616 020260 005037  002040          	clr	unitno			; init unit number
     617                                
     618 020264                         	call	init			; init controller
       1 020264 004737  023712          	jsr	pc,init
     619 020270 103402                  	bcs	100$			; br if OK
     620 020272 000137  021312          	jmp	590$			; else error
     621                                
     622                                	; unit number loop
     623                                
     624 020276 005001                  100$:	clr	r1			; constant 0
     625 020300 005201                  	inc	r1			; constant 1
     626 020302 072137  002040          	ash	unitno,r1		; shift 1 by bit number
     627 020306 130137  002116          	bitb	r1,online		; check if online or not
     628 020312 001002                  	bne	110$			; br if yes
     629 020314 000137  021246          	jmp	390$			; not online
     630                                
     631 020320                         110$:	call	bufini			; init buffers
       1 020320 004737  024714          	jsr	pc,bufini
     632                                
     633 020324 112737  000011  012242  	movb	#op_onl,cpkt+p_opcd	; set opcode for online check
     634 020332 013737  002040  012236  	mov	unitno,cpkt+p_unit	; set unit
     635                                	
     636 020340 012737  001130  002032  	mov	#10.*60.,dlycnt		; timeout interval
     637 020346                         	call	wt4dun			; wait for done
       1 020346 004737  022612          	jsr	pc,wt4dun
     638 020352 103402                  	bcs	120$			; br if ok
     639 020354 000137  021266          	jmp	490$			; else error
     640                                	
     641 020360                         120$:	call	dmphdr			; dump headers
       1 020360 004737  022704          	jsr	pc,dmphdr
     642                                
     643 020364 017700  161426          	mov	@csr_sa,r0		; check error status
     644 020370 100017                  	bpl	130$			; br if no error flagged
     645 020372                         	printf	#2014$,testno,unitno,r0	; error message
       1 020372                         	calls	printf #2014$ testno unitno r0            
       8                                .list
       9 020372 010046                  	mov	r0,-(sp)
      14                                .list
      15 020374 013746  002040          	mov	unitno,-(sp)
      20                                .list
      21 020400 013746  002036          	mov	testno,-(sp)
      26                                .list
      27 020404 012746  021545          	mov	#2014$,-(sp)
       1                                .list
       2 020410                         	call	printf
       1 020410 004737  025102          	jsr	pc,printf
       3 020414 062706  000010          	add	#10,sp
      18                                .list
     646 020420 005237  002020          	inc	errors			; count
     647 020424 000137  021246          	jmp	390$			; skip read
     648                                
     649 020430 005037  002034          130$:	clr	runcnt			; zero tick counter
     650 020434 005037  002052          	clr	blkcnt+0		; zero block counter
     651 020440 005037  002054          	clr	blkcnt+2		; 
     652 020444 012737  177770  002046  	mov	#-bufsiz,blknum+0	; seed starting block number
     653 020452 012737  177777  002050  	mov	#-1,blknum+2		; 
     654                                	
     655                                	; block read loop
     656                                
     657 020460                         200$:	call	bufini			; init buffers
       1 020460 004737  024714          	jsr	pc,bufini
     658                                	
     659 020464 112737  000041  012242  	movb	#op_rd,cpkt+p_opcd	; set opcode for read
     660 020472 013737  002040  012236  	mov	unitno,cpkt+p_unit	; set unit
     661                                	
     662 020500 062737  000010  002046  	add	#bufsiz,blknum+0	; increment starting block
     663 020506 005537  002050          	adc	blknum+2		; 
     664                                	
     665 020512 013700  002040          	mov	unitno,r0		; get current unit
     666 020516 006300                  	asl	r0			; x2
     667 020520 006300                  	asl	r0			; x4
     668                                
     669 020522 016001  002056          	mov	devsiz+0(r0),r1		; device size, lo
     670 020526 016002  002060          	mov	devsiz+2(r0),r2		; and hi
     671 020532 163701  002046          	sub	blknum+0,r1		; minus starting block, lo
     672 020536 005602                  	sbc	r2			;
     673 020540 163702  002050          	sub	blknum+2,r2		; hi
     674 020544 162701  000010          	sub	#bufsiz,r1		; buffer size, lo
     675 020550 005602                  	sbc	r2			;
     676 020552 002004                  	bge	210$			; br if still in range
     677                                
     678 020554 005037  002050          	clr	blknum+2		; overflow; reset back to start
     679 020560 005037  002046          	clr	blknum+0		;
     680                                	
     681 020564 062737  000010  002052  210$:	add	#bufsiz,blkcnt+0	; increment block counter
     682 020572 005537  002054          	adc	blkcnt+2		; 
     683                                	
     684 020576 012737  010000  012246  	mov	#buflen,cpkt+p_bcnt+0	; read byte count
     685 020604 005037  012250          	clr	cpkt+p_bcnt+2		; 
     686 020610 012737  002120  012252  	mov	#buffer,cpkt+p_buff+0	; read buffer address
     687 020616 005037  012254          	clr	cpkt+p_buff+2		; 
     688 020622 013737  002046  012266  	mov	blknum+0,cpkt+p_lbn+0	; read starting block number
     689 020630 013737  002050  012270  	mov	blknum+2,cpkt+p_lbn+2	;
     690                                
     691        000000                  .if ne 0
     692                                	printf #2018$,testno,unitno,cpkt+p_bcnt+2,cpkt+p_bcnt+0,devsiz+2(r0),devsiz+0(r0),cpkt+p_lbn+2,cpkt+p_lbn+0 ; debug
     693                                .endc
     694                                
     695 020636 012737  007020  002032  	mov	#60.*60.,dlycnt		; timeout interval
     696 020644                         	call	wt4dun			; wait for done
       1 020644 004737  022612          	jsr	pc,wt4dun
     697 020650 103402                  	bcs	220$			; br if ok
     698 020652 000137  021266          	jmp	490$			; else error
     699                                	
     700 020656                         220$:	call	dmphdr			; dump headers
       1 020656 004737  022704          	jsr	pc,dmphdr
     701                                
     702 020662 017700  161130          	mov	@csr_sa,r0		; check error status
     703 020666 100015                  	bpl	230$			; br if no error flagged
     704 020670                         	printf	#2014$,testno,unitno,r0	; error message
       1 020670                         	calls	printf #2014$ testno unitno r0            
       8                                .list
       9 020670 010046                  	mov	r0,-(sp)
      14                                .list
      15 020672 013746  002040          	mov	unitno,-(sp)
      20                                .list
      21 020676 013746  002036          	mov	testno,-(sp)
      26                                .list
      27 020702 012746  021545          	mov	#2014$,-(sp)
       1                                .list
       2 020706                         	call	printf
       1 020706 004737  025102          	jsr	pc,printf
       3 020712 062706  000010          	add	#10,sp
      18                                .list
     705 020716 005237  002020          	inc	errors			; count
     706                                
     707 020722 023737  002042  012144  230$:	cmp	refnum+0,rpkt+p_crf+0	; check lower refnum
     708 020730 001004                  	bne	240$			; br if mismatch error
     709 020732 023737  002044  012146  	cmp	refnum+2,rpkt+p_crf+2	; check higher refnum
     710 020740 001424                  	beq	250$			; br if OK
     711 020742                         240$:	printf	#2017$,testno,unitno,refnum+2,refnum+0,rpkt+p_crf+2,rpkt+p_crf+0 ; wrong status
       1 020742                         	calls	printf #2017$ testno unitno refnum+2 refnum+0 rpkt+p_crf+2 rpkt+p_crf+0         
       8                                .list
       9 020742 013746  012144          	mov	rpkt+p_crf+0,-(sp)
      14                                .list
      15 020746 013746  012146          	mov	rpkt+p_crf+2,-(sp)
      20                                .list
      21 020752 013746  002042          	mov	refnum+0,-(sp)
      26                                .list
      27 020756 013746  002044          	mov	refnum+2,-(sp)
      32                                .list
      33 020762 013746  002040          	mov	unitno,-(sp)
      38                                .list
      39 020766 013746  002036          	mov	testno,-(sp)
      44                                .list
      45 020772 012746  022046          	mov	#2017$,-(sp)
       1                                .list
       2 020776                         	call	printf
       1 020776 004737  025102          	jsr	pc,printf
       3 021002 062706  000016          	add	#16,sp
      18                                .list
     712 021006 005237  002020          	inc	errors			; count
     713                                
     714 021012 023737  012246  012160  250$:	cmp	cpkt+p_bcnt+0,rpkt+p_bcnt+0 ; check byte count lo
     715 021020 001004                  	bne	260$			; br if error
     716 021022 023737  012250  012162  	cmp	cpkt+p_bcnt+2,rpkt+p_bcnt+2 ; check byte count hi
     717 021030 001424                   	beq	270$			; br if OK
     718 021032                         260$:	printf	#2013$,testno,unitno,cpkt+p_bcnt+2,cpkt+p_bcnt+0,rpkt+p_bcnt+2,rpkt+p_bcnt+0 ; wrong byte count
       1 021032                         	calls	printf #2013$ testno unitno cpkt+p_bcnt+2 cpkt+p_bcnt+0 rpkt+p_bcnt+2 rpkt+p_bcnt+0         
       8                                .list
       9 021032 013746  012160          	mov	rpkt+p_bcnt+0,-(sp)
      14                                .list
      15 021036 013746  012162          	mov	rpkt+p_bcnt+2,-(sp)
      20                                .list
      21 021042 013746  012246          	mov	cpkt+p_bcnt+0,-(sp)
      26                                .list
      27 021046 013746  012250          	mov	cpkt+p_bcnt+2,-(sp)
      32                                .list
      33 021052 013746  002040          	mov	unitno,-(sp)
      38                                .list
      39 021056 013746  002036          	mov	testno,-(sp)
      44                                .list
      45 021062 012746  021434          	mov	#2013$,-(sp)
       1                                .list
       2 021066                         	call	printf
       1 021066 004737  025102          	jsr	pc,printf
       3 021072 062706  000016          	add	#16,sp
      18                                .list
     719 021076 005237  002020           	inc	errors			; count
     720                                
     721 021102                         270$:	call	dmpbuf			; dump buffer
       1 021102 004737  023342          	jsr	pc,dmpbuf
     722                                	
     723 021106 005000                  	clr	r0			; zap
     724 021110 153700  012156          	bisb	rpkt+p_sts,r0		; get status
     725 021114 122700  000000          	cmpb	#st_suc,r0		; success status?
     726 021120 001414                  	beq	280$			; br if OK
     727 021122                         	printf	#2016$,testno,unitno,r0	; read not OK
       1 021122                         	calls	printf #2016$ testno unitno r0            
       8                                .list
       9 021122 010046                  	mov	r0,-(sp)
      14                                .list
      15 021124 013746  002040          	mov	unitno,-(sp)
      20                                .list
      21 021130 013746  002036          	mov	testno,-(sp)
      26                                .list
      27 021134 012746  021752          	mov	#2016$,-(sp)
       1                                .list
       2 021140                         	call	printf
       1 021140 004737  025102          	jsr	pc,printf
       3 021144 062706  000010          	add	#10,sp
      18                                .list
     728 021150 000436                  	br	390$			; br if error
     729                                	
     730 021152 023737  002034  002012  280$:	cmp	runcnt,runtil		; run for at least this many ticks
     731 021160 002002                  	bge	290$			; br if done
     732 021162 000137  020460          	jmp	200$			; loop for more
     733                                	
     734 021166 013700  002040          290$:	mov	unitno,r0
     735 021172 006300                  	asl	r0
     736 021174 006300                  	asl	r0
     737 021176                         	printf	#2015$,testno,unitno,blkcnt+2,blkcnt+0,runcnt,devsiz+2(r0),devsiz+0(r0) ; success
       1 021176                         	calls	printf #2015$ testno unitno blkcnt+2 blkcnt+0 runcnt devsiz+2(r0) devsiz+0(r0)        
       8                                .list
       9 021176 016046  002056          	mov	devsiz+0(r0),-(sp)
      14                                .list
      15 021202 016046  002060          	mov	devsiz+2(r0),-(sp)
      20                                .list
      21 021206 013746  002034          	mov	runcnt,-(sp)
      26                                .list
      27 021212 013746  002052          	mov	blkcnt+0,-(sp)
      32                                .list
      33 021216 013746  002054          	mov	blkcnt+2,-(sp)
      38                                .list
      39 021222 013746  002040          	mov	unitno,-(sp)
      44                                .list
      45 021226 013746  002036          	mov	testno,-(sp)
      50                                .list
      51 021232 012746  021631          	mov	#2015$,-(sp)
       1                                .list
       2 021236                         	call	printf
       1 021236 004737  025102          	jsr	pc,printf
       3 021242 062706  000020          	add	#20,sp
      18                                .list
     738                                
     739 021246 005237  002040          390$:	inc	unitno			; bump unit number
     740 021252 023727  002040  000007  	cmp	unitno,#7		; check for maximum
     741 021260 003014                  	bgt	590$			; done
     742 021262 000137  020276          	jmp	100$			; br if unit num is OK
     743                                
     744 021266                         490$:	printf	#2012$,testno		; timeout!
       1 021266                         	calls	printf #2012$ testno              
       8                                .list
       9 021266 013746  002036          	mov	testno,-(sp)
      14                                .list
      15 021272 012746  021360          	mov	#2012$,-(sp)
       1                                .list
       2 021276                         	call	printf
       1 021276 004737  025102          	jsr	pc,printf
       3 021302 062706  000004          	add	#4,sp
      18                                .list
     745 021306 005237  002020          	inc	errors			; count
     746                                
     747 021312 012777  000000  160474  590$:	mov	#0,@csr_ip		; reset controller
     748                                
     749 021320 000137  022302          	jmp	9999$			; next test
     750                                
     751                                	; - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     752                                
     753 021324    015     012     124  2010$:	.asciz	<cr><lf>"Test%d: sequential read"<cr><lf>
         021327    145     163     164  
         021332    045     144     072  
         021335    040     163     145  
         021340    161     165     145  
         021343    156     164     151  
         021346    141     154     040  
         021351    162     145     141  
         021354    144     015     012  
         021357    000                  
     754 021360    124     145     163  2012$:	.asciz	"Test%d: sequential read, response timeout"<cr><lf>
         021363    164     045     144  
         021366    072     040     163  
         021371    145     161     165  
         021374    145     156     164  
         021377    151     141     154  
         021402    040     162     145  
         021405    141     144     054  
         021410    040     162     145  
         021413    163     160     157  
         021416    156     163     145  
         021421    040     164     151  
         021424    155     145     157  
         021427    165     164     015  
         021432    012     000          
     755 021434    124     145     163  2013$:	.asciz	"Test%d: sequential read, unit=%d, byte count error, exp=%ld., rcv=%ld."<cr><lf>
         021437    164     045     144  
         021442    072     040     163  
         021445    145     161     165  
         021450    145     156     164  
         021453    151     141     154  
         021456    040     162     145  
         021461    141     144     054  
         021464    040     165     156  
         021467    151     164     075  
         021472    045     144     054  
         021475    040     142     171  
         021500    164     145     040  
         021503    143     157     165  
         021506    156     164     040  
         021511    145     162     162  
         021514    157     162     054  
         021517    040     145     170  
         021522    160     075     045  
         021525    154     144     056  
         021530    054     040     162  
         021533    143     166     075  
         021536    045     154     144  
         021541    056     015     012  
         021544    000                  
     756 021545    124     145     163  2014$:	.asciz	"Test%d: sequential read, unit=%d, fatal error %#o"<cr><lf>
         021550    164     045     144  
         021553    072     040     163  
         021556    145     161     165  
         021561    145     156     164  
         021564    151     141     154  
         021567    040     162     145  
         021572    141     144     054  
         021575    040     165     156  
         021600    151     164     075  
         021603    045     144     054  
         021606    040     146     141  
         021611    164     141     154  
         021614    040     145     162  
         021617    162     157     162  
         021622    040     045     043  
         021625    157     015     012  
         021630    000                  
     757 021631    124     145     163  2015$:	.asciz	"Test%d: sequential read, unit=%d, success, blkcnt=%ld., ticks=%d., devsiz=%ld."<cr><lf>
         021634    164     045     144  
         021637    072     040     163  
         021642    145     161     165  
         021645    145     156     164  
         021650    151     141     154  
         021653    040     162     145  
         021656    141     144     054  
         021661    040     165     156  
         021664    151     164     075  
         021667    045     144     054  
         021672    040     163     165  
         021675    143     143     145  
         021700    163     163     054  
         021703    040     142     154  
         021706    153     143     156  
         021711    164     075     045  
         021714    154     144     056  
         021717    054     040     164  
         021722    151     143     153  
         021725    163     075     045  
         021730    144     056     054  
         021733    040     144     145  
         021736    166     163     151  
         021741    172     075     045  
         021744    154     144     056  
         021747    015     012     000  
     758 021752    124     145     163  2016$:	.asciz	"Test%d: sequential read, unit=%d, not present, status=%#o"<cr><lf>
         021755    164     045     144  
         021760    072     040     163  
         021763    145     161     165  
         021766    145     156     164  
         021771    151     141     154  
         021774    040     162     145  
         021777    141     144     054  
         022002    040     165     156  
         022005    151     164     075  
         022010    045     144     054  
         022013    040     156     157  
         022016    164     040     160  
         022021    162     145     163  
         022024    145     156     164  
         022027    054     040     163  
         022032    164     141     164  
         022035    165     163     075  
         022040    045     043     157  
         022043    015     012     000  
     759 022046    124     145     163  2017$:	.asciz	"Test%d: sequential read, unit=%d, refnum error, exp=%.6o,%.6o, rcv=%.6o,%.6o"<cr><lf>
         022051    164     045     144  
         022054    072     040     163  
         022057    145     161     165  
         022062    145     156     164  
         022065    151     141     154  
         022070    040     162     145  
         022073    141     144     054  
         022076    040     165     156  
         022101    151     164     075  
         022104    045     144     054  
         022107    040     162     145  
         022112    146     156     165  
         022115    155     040     145  
         022120    162     162     157  
         022123    162     054     040  
         022126    145     170     160  
         022131    075     045     056  
         022134    066     157     054  
         022137    045     056     066  
         022142    157     054     040  
         022145    162     143     166  
         022150    075     045     056  
         022153    066     157     054  
         022156    045     056     066  
         022161    157     015     012  
         022164    000                  
     760 022165    124     145     163  2018$:	.asciz	"Test%d: sequential read, unit=%d, bytecount=%ld., devblk=%ld., blkcnt=%ld."<cr><lf>
         022170    164     045     144  
         022173    072     040     163  
         022176    145     161     165  
         022201    145     156     164  
         022204    151     141     154  
         022207    040     162     145  
         022212    141     144     054  
         022215    040     165     156  
         022220    151     164     075  
         022223    045     144     054  
         022226    040     142     171  
         022231    164     145     143  
         022234    157     165     156  
         022237    164     075     045  
         022242    154     144     056  
         022245    054     040     144  
         022250    145     166     142  
         022253    154     153     075  
         022256    045     154     144  
         022261    056     054     040  
         022264    142     154     153  
         022267    143     156     164  
         022272    075     045     154  
         022275    144     056     015  
         022300    012     000          
     761                                	.even
     762                                
     763 022302 005237  002036          9999$:	inc	testno			; to next test
     764                                
     765                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     766                                
     767                                ; all done
     768                                
     769 022306 005237  002022          done:	inc	passes			; count passes
     770 022312                         	printf	#msg3,passes,errors	; output some status
       1 022312                         	calls	printf #msg3 passes errors             
       8                                .list
       9 022312 013746  002020          	mov	errors,-(sp)
      14                                .list
      15 022316 013746  002022          	mov	passes,-(sp)
      20                                .list
      21 022322 012746  022516          	mov	#msg3,-(sp)
       1                                .list
       2 022326                         	call	printf
       1 022326 004737  025102          	jsr	pc,printf
       3 022332 062706  000006          	add	#6,sp
      18                                .list
     771 022336 023737  002004  002022  	cmp	numpas,passes		; check if done
     772 022344 001402                  	beq	exit			; yes
     773 022346 000137  012562          	jmp	loop			; not yet
     774                                
     775 022352 013700  002024          exit:	mov	$sav42,r0		; check if loaded by XXDP
     776 022356 001407                  	beq	noxxdp			; br if not
     777 022360 000005                  	reset				; yes, reset the world
     778 022362 004710                  $endad:	jsr	pc,(r0)			; return back to XXDP
     779 022364 000240                  	nop				; standard sequence
     780 022366 000240                  	nop				;
     781 022370 000240                  	nop				;
     782 022372 000137  012562          	jmp	loop			; back for more
     783                                
     784 022376                         noxxdp:	printf	#msg2			; say goodbye
       1 022376                         	calls	printf #msg2               
       8                                .list
       9 022376 012746  022502          	mov	#msg2,-(sp)
       1                                .list
       2 022402                         	call	printf
       1 022402 004737  025102          	jsr	pc,printf
       3 022406 062706  000002          	add	#2,sp
      18                                .list
     785 022412 005000                  	clr	r0			;
     786 022414 005300                  10$:	dec	r0			; 
     787 022416 001376                  	bne	10$			; some delay
     788 022420 000005                  	reset				; zap the world
     789 022422 012746  000340          	mov	#<7>*bit5,-(sp)		; prio7 in psw
     790 022426 012746  165144          	mov	#console,-(sp)		; go there
     791 022432 000002                  	rti				; reload psw
     792                                
     793 022434    015     012     015  msg1:	.asciz	<cr><lf><cr><lf>"MSCP Controller Exerciser v1.15"<cr><lf>
         022437    012     115     123  
         022442    103     120     040  
         022445    103     157     156  
         022450    164     162     157  
         022453    154     154     145  
         022456    162     040     105  
         022461    170     145     162  
         022464    143     151     163  
         022467    145     162     040  
         022472    166     061     056  
         022475    061     065     015  
         022500    012     000          
     794 022502    015     012     107  msg2:	.asciz	<cr><lf>"Goodbye"<cr><lf>
         022505    157     157     144  
         022510    142     171     145  
         022513    015     012     000  
     795 022516    015     012     105  msg3:	.asciz	<cr><lf>"End pass %u. errors %u."<cr><lf>
         022521    156     144     040  
         022524    160     141     163  
         022527    163     040     045  
         022532    165     056     040  
         022535    145     162     162  
         022540    157     162     163  
         022543    040     045     165  
         022546    056     015     012  
         022551    000                  
     796                                	.even
     797                                
     798                                ; --------------------------------------------------------------------------------
     799                                ;
     800                                ; line clock interrupt routine
     801                                ;
     802 022552 062737  000001  002026  lkintr:	add	#1,ticker+0		;*6* incre tickcount lo
     803 022560 005537  002030          	adc	ticker+2		;*6* and propagate
     804 022564 005237  002034          	inc	runcnt			;*6* bump run counter
     805 022570 005737  002032          	tst	dlycnt			;*6* check delay counter
     806 022574 003402                  	ble	100$			;*6* don't decre past zero
     807 022576 005337  002032          	dec	dlycnt			;*6* decre delay counter
     808 022602 042737  000200  177546  100$:	bic	#lk_mon,lk$csr		;*6* clear monitor bit
     809 022610 000002                  	rti				;*6* and done
     810                                
     811                                ; --------------------------------------------------------------------------------
     812                                ;
     813                                ; wait for done routine, C is 0 for error, 1 for OK
     814                                ;
     815                                ;	call:	call	wt4dun
     816                                ;
     817 022612 052737  100000  012130  wt4dun:	bis	#ds_own,comm+2		; resp desc owned by port
     818 022620 052737  100000  012134  	bis	#ds_own,comm+6		; cmd desc owned by port
     819 022626 005777  157162          	tst	@csr_ip			; wake controller
     820                                
     821                                	; note: 'tst' clears C bit
     822                                	
     823 022632 005737  002032          110$:	tst	dlycnt			; delay expired?
     824 022636 003412                  	ble	190$			; br if yes
     825 022640 005737  012130          	tst	comm+2			; check response desc
     826 022644 100772                  	bmi	110$			; br if port owned
     827                                
     828 022646 005737  002032          120$:	tst	dlycnt			; delay expired?
     829 022652 003404                  	ble	190$			; br if yes
     830 022654 005737  012134          	tst	comm+6			; check command desc
     831 022660 100772                  	bmi	120$			; br if port owned
     832                                
     833 022662 000261                  	sec				; ok return
     834 022664                         190$:	return				; done
       1 022664 000207                  	rts	pc
     835                                
     836                                ; --------------------------------------------------------------------------------
     837                                ;
     838                                ; delay routine
     839                                ;
     840                                ;	call:	mov	#ticks,r0	; number of ticks to delay [1..32767]
     841                                ;		call	delay
     842                                ;
     843 022666 010037  002032          delay:	mov	r0,dlycnt		; wait this many ticks
     844 022672 003403                  	ble	110$			; br if no delay
     845 022674 005737  002032          100$:	tst	dlycnt			; are we there yet?
     846 022700 003375                  	bgt	100$			; br if not yet
     847 022702                         110$:	return				; done
       1 022702 000207                  	rts	pc
     848                                
     849                                ; --------------------------------------------------------------------------------
     850                                ;
     851                                ; command packet dumper
     852                                ;
     853                                ;	call:	call	dmphdr
     854                                ;
     855 022704 032737  000001  002002  dmphdr:	bit	#bit0,optswi		; check if extra printout enabled
     856 022712 001515                  	beq	900$			; br if not
     857 022714                         	savreg	r4,r5			; save registers
       2                                .list
       3 022714 010446                  	mov	r4,-(sp)
       7                                .list
       8 022716 010546                  	mov	r5,-(sp)
       9                                .list
     858                                
     859 022720 012705  012126          	mov	#comm,r5		; block address
     860 022724                         	printf	#2010$,r5,#-4,-4(r5),-2(r5),#0,0(r5),2(r5),4(r5),6(r5) ; print header
       1 022724                         	calls	printf #2010$ r5 #-4 -4(r5) -2(r5) #0 0(r5) 2(r5) 4(r5) 6(r5)      
       8                                .list
       9 022724 016546  000006          	mov	6(r5),-(sp)
      14                                .list
      15 022730 016546  000004          	mov	4(r5),-(sp)
      20                                .list
      21 022734 016546  000002          	mov	2(r5),-(sp)
      26                                .list
      27 022740 016546  000000          	mov	0(r5),-(sp)
      32                                .list
      33 022744 012746  000000          	mov	#0,-(sp)
      38                                .list
      39 022750 016546  177776          	mov	-2(r5),-(sp)
      44                                .list
      45 022754 016546  177774          	mov	-4(r5),-(sp)
      50                                .list
      51 022760 012746  177774          	mov	#-4,-(sp)
      56                                .list
      57 022764 010546                  	mov	r5,-(sp)
      62                                .list
      63 022766 012746  023150          	mov	#2010$,-(sp)
       1                                .list
       2 022772                         	call	printf
       1 022772 004737  025102          	jsr	pc,printf
       3 022776 062706  000024          	add	#24,sp
      18                                .list
     861                                
     862 023002 012704  000030          	mov	#<clen/2>,r4		; block size in words
     863 023006 012705  012232          	mov	#cpkt,r5		; block address
     864 023012                         	printf	#2020$,#'c,r5,#-4,-4(r5),-2(r5) ; print header
       1 023012                         	calls	printf #2020$ #'c r5 #-4 -4(r5) -2(r5)          
       8                                .list
       9 023012 016546  177776          	mov	-2(r5),-(sp)
      14                                .list
      15 023016 016546  177774          	mov	-4(r5),-(sp)
      20                                .list
      21 023022 012746  177774          	mov	#-4,-(sp)
      26                                .list
      27 023026 010546                  	mov	r5,-(sp)
      32                                .list
      33 023030 012746  000143          	mov	#'c,-(sp)
      38                                .list
      39 023034 012746  023260          	mov	#2020$,-(sp)
       1                                .list
       2 023040                         	call	printf
       1 023040 004737  025102          	jsr	pc,printf
       3 023044 062706  000014          	add	#14,sp
      18                                .list
     865 023050                         	call	dumper			; print block
       1 023050 004737  023444          	jsr	pc,dumper
     866                                
     867 023054 012704  000030          	mov	#<rlen/2>,r4		; block size in words
     868 023060 012705  012144          	mov	#rpkt,r5		; block address
     869 023064                         	printf	#2020$,#'r,r5,#-4,-4(r5),-2(r5) ; print header
       1 023064                         	calls	printf #2020$ #'r r5 #-4 -4(r5) -2(r5)          
       8                                .list
       9 023064 016546  177776          	mov	-2(r5),-(sp)
      14                                .list
      15 023070 016546  177774          	mov	-4(r5),-(sp)
      20                                .list
      21 023074 012746  177774          	mov	#-4,-(sp)
      26                                .list
      27 023100 010546                  	mov	r5,-(sp)
      32                                .list
      33 023102 012746  000162          	mov	#'r,-(sp)
      38                                .list
      39 023106 012746  023260          	mov	#2020$,-(sp)
       1                                .list
       2 023112                         	call	printf
       1 023112 004737  025102          	jsr	pc,printf
       3 023116 062706  000014          	add	#14,sp
      18                                .list
     870 023122                         	call	dumper			; print block
       1 023122 004737  023444          	jsr	pc,dumper
     871                                	
     872 023126                         	printf	#2030$			; eol
       1 023126                         	calls	printf #2030$               
       8                                .list
       9 023126 012746  023330          	mov	#2030$,-(sp)
       1                                .list
       2 023132                         	call	printf
       1 023132 004737  025102          	jsr	pc,printf
       3 023136 062706  000002          	add	#2,sp
      18                                .list
     873 023142                         	resreg	r4,r5			; restore registers
       7                                .list
       8 023142 012605                  	mov	(sp)+,r5
      12                                .list
      13 023144 012604                  	mov	(sp)+,r4
       9                                .list
     874 023146                         900$:	return				; and done
       1 023146 000207                  	rts	pc
     875                                
     876 023150    134     162     134  2010$:	.asciz	"\r\n\r\ncomm @ %.6o\r\n%+6d  %.6o %.6o\r\n%+6o  %.6o %.6o %.6o %.6o\r\n"
         023153    156     134     162  
         023156    134     156     143  
         023161    157     155     155  
         023164    040     100     040  
         023167    045     056     066  
         023172    157     134     162  
         023175    134     156     045  
         023200    053     066     144  
         023203    040     040     045  
         023206    056     066     157  
         023211    040     045     056  
         023214    066     157     134  
         023217    162     134     156  
         023222    045     053     066  
         023225    157     040     040  
         023230    045     056     066  
         023233    157     040     045  
         023236    056     066     157  
         023241    040     045     056  
         023244    066     157     040  
         023247    045     056     066  
         023252    157     134     162  
         023255    134     156     000  
     877 023260    134     162     134  2020$:	.asciz	"\r\n%cpkt @ %.6o\r\n%+6d  %.6o %.6o\r\n"
         023263    156     045     143  
         023266    160     153     164  
         023271    040     100     040  
         023274    045     056     066  
         023277    157     134     162  
         023302    134     156     045  
         023305    053     066     144  
         023310    040     040     045  
         023313    056     066     157  
         023316    040     045     056  
         023321    066     157     134  
         023324    162     134     156  
         023327    000                  
     878 023330    134     162     134  2030$:	.asciz	"\r\n\r\n"
         023333    156     134     162  
         023336    134     156     000  
     879 023341    000                  	.even
     880                                
     881                                ; --------------------------------------------------------------------------------
     882                                ;
     883                                ; data packet dumper
     884                                ;
     885                                ;	call:	call	dmpbuf
     886                                ;
     887 023342 032737  000002  002002  dmpbuf:	bit	#bit1,optswi		; check if extra printout enabled
     888 023350 001421                  	beq	900$			; br if not
     889 023352                         	savreg	r4,r5			; save registers
       2                                .list
       3 023352 010446                  	mov	r4,-(sp)
       7                                .list
       8 023354 010546                  	mov	r5,-(sp)
       9                                .list
     890                                
     891 023356 012704  000400          	mov	#256.,r4		; block size
     892 023362 012705  002120          	mov	#buffer,r5		; block address
     893 023366                         	printf	#2010$,r5		; print header
       1 023366                         	calls	printf #2010$ r5              
       8                                .list
       9 023366 010546                  	mov	r5,-(sp)
      14                                .list
      15 023370 012746  023416          	mov	#2010$,-(sp)
       1                                .list
       2 023374                         	call	printf
       1 023374 004737  025102          	jsr	pc,printf
       3 023400 062706  000004          	add	#4,sp
      18                                .list
     894 023404                         	call	dumper			; print block
       1 023404 004737  023444          	jsr	pc,dumper
     895                                
     896 023410                         	resreg	r4,r5			; restore registers
       7                                .list
       8 023410 012605                  	mov	(sp)+,r5
      12                                .list
      13 023412 012604                  	mov	(sp)+,r4
       9                                .list
     897 023414                         900$:	return				; and done
       1 023414 000207                  	rts	pc
     898                                
     899 023416    134     162     134  2010$:	.asciz	"\r\nbuffer @ %.6o\r\n"
         023421    156     142     165  
         023424    146     146     145  
         023427    162     040     100  
         023432    040     045     056  
         023435    066     157     134  
         023440    162     134     156  
         023443    000                  
     900                                	.even
     901                                
     902                                ; --------------------------------------------------------------------------------
     903                                ;
     904                                ; ascii memory dump routine
     905                                ;
     906                                ;	call:	mov	#size,r4	; block size, words
     907                                ;		mov	#buffer,r5	; block address, byte
     908                                ;		call	dumper
     909                                ;
     910 023444                         dumper:	savreg	r0,r1,r2,r3,r4,r5	; save registers
       2                                .list
       3 023444 010046                  	mov	r0,-(sp)
       7                                .list
       8 023446 010146                  	mov	r1,-(sp)
      12                                .list
      13 023450 010246                  	mov	r2,-(sp)
      17                                .list
      18 023452 010346                  	mov	r3,-(sp)
      22                                .list
      23 023454 010446                  	mov	r4,-(sp)
      27                                .list
      28 023456 010546                  	mov	r5,-(sp)
       9                                .list
     911 023460 005001                  	clr	r1			; word counter
     912 023462 010503                  	mov	r5,r3			; ptr to start of line
     913 023464 032701  000007          110$:	bit	#^b111,r1		; at start of line
     914 023470 001011                  	bne	120$			; br if not
     915 023472 006301                  	asl	r1			; make byte offset
     916 023474                         	printf	#2050$,r1		; print line offset
       1 023474                         	calls	printf #2050$ r1              
       8                                .list
       9 023474 010146                  	mov	r1,-(sp)
      14                                .list
      15 023476 012746  023703          	mov	#2050$,-(sp)
       1                                .list
       2 023502                         	call	printf
       1 023502 004737  025102          	jsr	pc,printf
       3 023506 062706  000004          	add	#4,sp
      18                                .list
     917 023512 006201                  	asr	r1			; back to word offset
     918 023514                         120$:	printf	#2010$,(r5)+		; print a word
       1 023514                         	calls	printf #2010$ (r5)+              
       8                                .list
       9 023514 012546                  	mov	(r5)+,-(sp)
      14                                .list
      15 023516 012746  023662          	mov	#2010$,-(sp)
       1                                .list
       2 023522                         	call	printf
       1 023522 004737  025102          	jsr	pc,printf
       3 023526 062706  000004          	add	#4,sp
      18                                .list
     919 023532 005201                  	inc	r1			; count words
     920 023534 032701  000007          	bit	#^b111,r1		; multiple of 8 per line
     921 023540 001037                  	bne	160$			; br if not
     922 023542                         	printf	#2040$			; some space
       1 023542                         	calls	printf #2040$               
       8                                .list
       9 023542 012746  023700          	mov	#2040$,-(sp)
       1                                .list
       2 023546                         	call	printf
       1 023546 004737  025102          	jsr	pc,printf
       3 023552 062706  000002          	add	#2,sp
      18                                .list
     923 023556 005002                  130$:	clr	r2			; zap
     924 023560 152302                  	bisb	(r3)+,r2		; get next character
     925 023562 120227  000040          	cmpb	r2,#<' >		; check for low end
     926 023566 002403                  	blt	140$			; br if illegal
     927 023570 120227  000176          	cmpb	r2,#<'~>		; check for high end
     928 023574 003402                  	ble	150$			; br if OK
     929 023576 012702  000056          140$:	mov	#<'.>,r2		; CTRL prints as '.'
     930 023602                         150$:	printf	#2030$,r2		; print a character
       1 023602                         	calls	printf #2030$ r2              
       8                                .list
       9 023602 010246                  	mov	r2,-(sp)
      14                                .list
      15 023604 012746  023675          	mov	#2030$,-(sp)
       1                                .list
       2 023610                         	call	printf
       1 023610 004737  025102          	jsr	pc,printf
       3 023614 062706  000004          	add	#4,sp
      18                                .list
     931 023620 020305                  	cmp	r3,r5			; at next line?
     932 023622 103755                  	blo	130$			; br if not yet
     933 023624                         	printf	#2020$			; yes, end the line
       1 023624                         	calls	printf #2020$               
       8                                .list
       9 023624 012746  023670          	mov	#2020$,-(sp)
       1                                .list
       2 023630                         	call	printf
       1 023630 004737  025102          	jsr	pc,printf
       3 023634 062706  000002          	add	#2,sp
      18                                .list
     934 023640 020104                  160$:	cmp	r1,r4			; hit end of block
     935 023642 001310                  	bne	110$			; br if not yet
     936 023644                         	resreg	r0,r1,r2,r3,r4,r5	; restore registers
       7                                .list
       8 023644 012605                  	mov	(sp)+,r5
      12                                .list
      13 023646 012604                  	mov	(sp)+,r4
      17                                .list
      18 023650 012603                  	mov	(sp)+,r3
      22                                .list
      23 023652 012602                  	mov	(sp)+,r2
      27                                .list
      28 023654 012601                  	mov	(sp)+,r1
      32                                .list
      33 023656 012600                  	mov	(sp)+,r0
       9                                .list
     937 023660                         	return				; and done
       1 023660 000207                  	rts	pc
     938                                
     939 023662    040     045     056  2010$:	.asciz	" %.6o"
         023665    066     157     000  
     940 023670    134     162     134  2020$:	.asciz	"\r\n"
         023673    156     000          
     941 023675    045     143     000  2030$:	.asciz	"%c"
     942 023700    040     040     000  2040$:	.asciz	"  "
     943 023703    045     053     066  2050$:	.asciz	"%+6o "
         023706    157     040     000  
     944 023711    000                  	.even
     945                                
     946                                ; --------------------------------------------------------------------------------
     947                                ;
     948                                ; MSCP controller init routine
     949                                ;
     950                                ;	call:	call	init
     951                                ;
     952 023712                         init:	savreg	r3,r4,r5		; save registers
       2                                .list
       3 023712 010346                  	mov	r3,-(sp)
       7                                .list
       8 023714 010446                  	mov	r4,-(sp)
      12                                .list
      13 023716 010546                  	mov	r5,-(sp)
       9                                .list
     953                                
     954 023720 012705  024202          	mov	#1010$,r5		; data structure
     955 023724 013704  002014          	mov	csr_ip,r4		; base csr address (IP)
     956 023730 005024                  	clr	(r4)+			; start init sequence, bump to (SA)
     957                                
     958                                	; wait for SA step N
     959                                
     960 023732 011403                  100$:	mov	(r4),r3			; check SA contents
     961 023734 100011                  	bpl	110$			; ER error bit clear
     962                                
     963 023736                         	printf	#2010$,(r5),r3		; format, expected, received
       1 023736                         	calls	printf #2010$ (r5) r3             
       8                                .list
       9 023736 010346                  	mov	r3,-(sp)
      14                                .list
      15 023740 011546                  	mov	(r5),-(sp)
      20                                .list
      21 023742 012746  024254          	mov	#2010$,-(sp)
       1                                .list
       2 023746                         	call	printf
       1 023746 004737  025102          	jsr	pc,printf
       3 023752 062706  000006          	add	#6,sp
      18                                .list
     964 023756 000502                  	br	390$			; exit
     965                                
     966 023760 036503  000002          110$:	bit	2(r5),r3		; check other state bits clear
     967 023764 001411                  	beq	120$			; br if OK
     968                                
     969 023766                         	printf	#2020$,(r5),r3		; format, expected, received
       1 023766                         	calls	printf #2020$ (r5) r3             
       8                                .list
       9 023766 010346                  	mov	r3,-(sp)
      14                                .list
      15 023770 011546                  	mov	(r5),-(sp)
      20                                .list
      21 023772 012746  024363          	mov	#2020$,-(sp)
       1                                .list
       2 023776                         	call	printf
       1 023776 004737  025102          	jsr	pc,printf
       3 024002 062706  000006          	add	#6,sp
      18                                .list
     970 024006 000466                  	br	390$			; exit
     971                                
     972 024010 031503                  120$:	bit	(r5),r3			; check current state bit set
     973 024012 001747                  	beq	100$			; br if not yet
     974                                
     975                                	; SA step N - response at 0->1 transition
     976                                
     977 024014 020365  000004          	cmp	r3,4(r5)		; check rcv:exp
     978 024020 001414                  	beq	130$			; br if OK
     979                                
     980 024022                         	printf	#2030$,(r5),4(r5),r3	; format, state, expected, received
       1 024022                         	calls	printf #2030$ (r5) 4(r5) r3            
       8                                .list
       9 024022 010346                  	mov	r3,-(sp)
      14                                .list
      15 024024 016546  000004          	mov	4(r5),-(sp)
      20                                .list
      21 024030 011546                  	mov	(r5),-(sp)
      26                                .list
      27 024032 012746  024477          	mov	#2030$,-(sp)
       1                                .list
       2 024036                         	call	printf
       1 024036 004737  025102          	jsr	pc,printf
       3 024042 062706  000010          	add	#10,sp
      18                                .list
     981 024046 005237  002020          	inc	errors			; incre error count
     982                                
     983                                	; SA step N - send
     984                                
     985 024052 016514  000006          130$:	mov	6(r5),(r4)		; set step N send data
     986                                
     987                                	; SA step N - step complete at 1->0 transition
     988                                
     989 024056 016537  000010  002032  	mov	10(r5),dlycnt		; state must complete in this time
     990                                
     991 024064 005737  002032          140$:	tst	dlycnt			; has delay count expired?
     992 024070 003010                  	bgt	150$			; not yet
     993                                
     994 024072                         	printf	#2040$,(r5)		; format, state
       1 024072                         	calls	printf #2040$ (r5)              
       8                                .list
       9 024072 011546                  	mov	(r5),-(sp)
      14                                .list
      15 024074 012746  024626          	mov	#2040$,-(sp)
       1                                .list
       2 024100                         	call	printf
       1 024100 004737  025102          	jsr	pc,printf
       3 024104 062706  000004          	add	#4,sp
      18                                .list
     995 024110 000425                  	br	390$			; exit
     996                                
     997 024112 031514                  150$:	bit	(r5),(r4)		; check current state bit cleared
     998 024114 001363                  	bne	140$			; loop if still set	
     999                                
    1000 024116 062705  000012          	add	#1020$-1010$,r5		; next state
    1001 024122 005715                  	tst	(r5)			; more states?
    1002 024124 001302                  	bne	100$			; br if yes
    1003                                
    1004 024126 012705  012122          	mov	#comm-4,r5		; ptr to comm structure
    1005                                
    1006 024132 005025                  	clr	(r5)+			; cmd intr
    1007 024134 005025                  	clr	(r5)+			; resp intr
    1008 024136 012725  012144          	mov	#rpkt,(r5)+		; resp pkt addr
    1009 024142 005025                  	clr	(r5)+			; resp host own
    1010 024144 012725  012232          	mov	#cpkt,(r5)+		; cmd pkt addr
    1011 024150 005025                  	clr	(r5)+			; cmd host own
    1012                                	
    1013                                	; success, restore registers and exit
    1014                                	
    1015 024152 000261                  	sec				; indicate OK
    1016 024154                         290$:	resreg	r3,r4,r5		; restore registers
       7                                .list
       8 024154 012605                  	mov	(sp)+,r5
      12                                .list
      13 024156 012604                  	mov	(sp)+,r4
      17                                .list
      18 024160 012603                  	mov	(sp)+,r3
       9                                .list
    1017 024162                         	return				; done
       1 024162 000207                  	rts	pc
    1018                                
    1019                                	; error, reset controller and exit
    1020                                
    1021 024164 005237  002020          390$:	inc	errors			; incr error count
    1022 024170 012777  000000  155616  	mov	#0,@csr_ip		; reset controller
    1023 024176 000241                  	clc				; indicate ERROR
    1024 024200 000765                  	br	290$			; and return
    1025                                
    1026                                	; - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    1027                                
    1028                                	; step 1
    1029                                
    1030 024202 004000  070000          1010$:	.word	sa_st1, sa_st2+sa_st3+sa_st4
    1031 024206 004400                  	.word	sa_st1+<0*sa_nsv>+<0*sa_a22>+<1*sa_edp>+<sa_opt*sa_rs0>
    1032 024210 100000                  	.word	sa_stp+<0*sa_cl0>+<0*sa_rl0>+<0*sa_int>+<0*sa_vec>
    1033 024212 001130                  	.word	10.*60.
    1034                                
    1035                                	; step 2
    1036                                
    1037 024214 010000  064000          1020$:	.word	sa_st2, sa_st1+sa_st3+sa_st4
    1038 024220 010200                  	.word	sa_st2+<0*sa_cty>+<1*sa_ste>+<0*sa_cle>+<0*sa_rle>
    1039 024222 012126                  	.word	comm+<0*sa_prg>
    1040 024224 001130                  	.word	10.*60.
    1041                                	
    1042                                	; step 3
    1043                                
    1044 024226 020000  054000          1030$:	.word	sa_st3, sa_st1+sa_st2+sa_st4
    1045 024232 020000                  	.word	sa_st3+<0*sa_vpe>+<0*sa_ine>+<0*sa_vee>
    1046 024234 000000                  	.word	<0*sa_ppt>+<0*sa_rgh>
    1047 024236 001130                  	.word	10.*60.
    1048                                
    1049                                	; step 4
    1050                                
    1051 024240 040000  034000          1040$:	.word	sa_st4, sa_st1+sa_st2+sa_st3
    1052 024244 040146                  	.word	sa_st4+<sa_ctyp*sa_cn0>+<sa_ucv*sa_mc0>
    1053 024246 000001                  	.word	<1*sa_go>
    1054 024250 001130                  	.word	10.*60.
    1055                                
    1056 024252 000000                  1050$:	.word	0
    1057                                
    1058                                	; - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    1059                                
    1060 024254    111     116     111  2010$:	.ascii	"INIT: init ER bit set in SA register"<cr><lf>
         024257    124     072     040  
         024262    151     156     151  
         024265    164     040     105  
         024270    122     040     142  
         024273    151     164     040  
         024276    163     145     164  
         024301    040     151     156  
         024304    040     123     101  
         024307    040     162     145  
         024312    147     151     163  
         024315    164     145     162  
         024320    015     012          
    1061 024322    040     040     105  	.ascii	"  Exp'ed  Rcv'ed"<cr><lf>
         024325    170     160     047  
         024330    145     144     040  
         024333    040     122     143  
         024336    166     047     145  
         024341    144     015     012  
    1062 024344    040     040     045  	.asciz	"  %.6o  %.6o"<cr><lf>
         024347    056     066     157  
         024352    040     040     045  
         024355    056     066     157  
         024360    015     012     000  
    1063 024363    111     116     111  2020$:	.ascii	"INIT: S1-S4 sequence error in SA register"<cr><lf>
         024366    124     072     040  
         024371    123     061     055  
         024374    123     064     040  
         024377    163     145     161  
         024402    165     145     156  
         024405    143     145     040  
         024410    145     162     162  
         024413    157     162     040  
         024416    151     156     040  
         024421    123     101     040  
         024424    162     145     147  
         024427    151     163     164  
         024432    145     162     015  
         024435    012                  
    1064 024436    040     040     105  	.ascii	"  Exp'ed  Rcv'ed"<cr><lf>
         024441    170     160     047  
         024444    145     144     040  
         024447    040     122     143  
         024452    166     047     145  
         024455    144     015     012  
    1065 024460    040     040     045  	.asciz	"  %.6o  %.6o"<cr><lf>
         024463    056     066     157  
         024466    040     040     045  
         024471    056     066     157  
         024474    015     012     000  
    1066 024477    111     116     111  2030$:	.ascii	"INIT: step response data compare error"<cr><lf>
         024502    124     072     040  
         024505    163     164     145  
         024510    160     040     162  
         024513    145     163     160  
         024516    157     156     163  
         024521    145     040     144  
         024524    141     164     141  
         024527    040     143     157  
         024532    155     160     141  
         024535    162     145     040  
         024540    145     162     162  
         024543    157     162     015  
         024546    012                  
    1067 024547    040     040     123  	.ascii	"  StpBit  Exp'ed  Rcv'ed"<cr><lf>
         024552    164     160     102  
         024555    151     164     040  
         024560    040     105     170  
         024563    160     047     145  
         024566    144     040     040  
         024571    122     143     166  
         024574    047     145     144  
         024577    015     012          
    1068 024601    040     040     045  	.asciz	"  %.6o  %.6o  %.6o"<cr><lf>
         024604    056     066     157  
         024607    040     040     045  
         024612    056     066     157  
         024615    040     040     045  
         024620    056     066     157  
         024623    015     012     000  
    1069 024626    111     116     111  2040$:	.ascii	"INIT: step response timeout error"<cr><lf>
         024631    124     072     040  
         024634    163     164     145  
         024637    160     040     162  
         024642    145     163     160  
         024645    157     156     163  
         024650    145     040     164  
         024653    151     155     145  
         024656    157     165     164  
         024661    040     145     162  
         024664    162     157     162  
         024667    015     012          
    1070 024671    040     040     123  	.ascii	"  StpBit"<cr><lf>
         024674    164     160     102  
         024677    151     164     015  
         024702    012                  
    1071 024703    040     040     045  	.asciz	"  %.6o"<cr><lf>
         024706    056     066     157  
         024711    015     012     000  
    1072                                	.even
    1073                                
    1074                                ; --------------------------------------------------------------------------------
    1075                                ;
    1076                                ; MSCP controller buffer init, set cmnd/resp to all zeroes
    1077                                ;
    1078                                ;	call:	call	bufini
    1079                                ;
    1080 024714                         bufini:	savreg	r5			; save registers
       2                                .list
       3 024714 010546                  	mov	r5,-(sp)
       9                                .list
    1081                                
    1082 024716 012705  012140          	mov	#rpkt+p_len,r5		; address
    1083 024722 005025                  100$:	clr	(r5)+			; zap a word
    1084 024724 020527  012224          	cmp	r5,#rend		; at end?
    1085 024730 103774                  	blo	100$			; br if not yet
    1086 024732 012737  000060  012140  	mov	#rlen,rpkt+p_len	; set buffer size
    1087                                
    1088 024740 012705  012226          	mov	#cpkt+p_len,r5		; address
    1089 024744 005025                  110$:	clr	(r5)+			; zap a word
    1090 024746 020527  012312          	cmp	r5,#cend		; at end?
    1091 024752 103774                  	blo	110$			; br if not yet
    1092 024754 012737  000060  012226  	mov	#clen,cpkt+p_len	; set buffer size
    1093                                
    1094 024762 112737  000000  012231  	movb	#tstcid,cpkt+p_cid	; set connection id
    1095 024770 112737  000000  012230  	movb	#0,cpkt+p_type		; set msg type, credits
    1096                                
    1097 024776 062737  000001  002042  	add	#1,refnum+0		; bump refnum
    1098 025004 005537  002044          	adc	refnum+2		; 
    1099                                
    1100 025010 013737  002042  012232  	mov	refnum+0,cpkt+p_crf+0	; store unique refnum
    1101 025016 013737  002044  012234  	mov	refnum+2,cpkt+p_crf+2	;
    1102                                	
    1103 025024                         	resreg	r5			; restore
       7                                .list
       8 025024 012605                  	mov	(sp)+,r5
       9                                .list
    1104 025026                         	return				; done
       1 025026 000207                  	rts	pc
    1105                                
    1106                                ; --------------------------------------------------------------------------------
    1107                                
    1108                                .include "mac/adrchk.mac"
       1                                ;================================================================================
       2                                ; adrchk.mac - routine to check if a physical address exists
       3                                ; (C) 2009 Donald North. All rights reserved.
       4                                ;================================================================================
       5                                ;
       6                                ; address check routine
       7                                ;
       8                                ;	call:	mov	#addr,r0
       9                                ;		call	adrchk
      10                                ;		bcc	we_trapped
      11                                ;		bcs	no_trap
      12                                ;
      13 025030 010546                  adrchk::mov	r5,-(sp)		; save registers
      14                                
      15 025032 013746  000004          	mov	@#4,-(sp)		; save old vector
      16 025036 013746  000006          	mov	@#6,-(sp)		;
      17 025042 010605                  	mov	sp,r5			; save sp here
      18                                
      19 025044 012737  025064  000004  	mov	#1$,@#4  		; if we timeout go here
      20 025052 005037  000006          	clr	@#6			; next psw if we trap
      21                                
      22 025056 000241                  	clc				; C=0 means we trapped
      23 025060 005710                  	tst	(r0)			; test the address, may trap
      24 025062 000261                  	sec				; C=1 means no trap
      25                                
      26 025064 010506                  1$:	mov	r5,sp			; restore stack
      27 025066 012637  000006          	mov	(sp)+,@#6		; restore old vector
      28 025072 012637  000004          	mov	(sp)+,@#4		;
      29                                
      30 025076 012605                  	mov	(sp)+,r5		; restore registers
      31 025100                         	return				; done
       1 025100 000207                  	rts	pc
      32                                
      33                                ;================================================================================
      34                                ; end of adrchk.mac
      35                                ;================================================================================
      35                                
    1109                                .include "mac/printf.mac"
       1                                ;================================================================================
       2                                ; printf.mac - printf routines for macro11 diagnostics
       3                                ; (C) 2009-2016 Donald North. All rights reserved.
       4                                ;================================================================================
       5                                
       6                                .if ndf ttxcsr
       7                                	
       8                                	; separate psect (if console registers not defined)
       9                                	.psect	printf
      10                                
      11                                	; external tty references
      12                                	.globl	ttxcsr, ttxbuf
      13                                
      14                                	; standard macro definitions
      15                                 	.include "mac/stddef.mac"
      16                                
      17                                pf.sep	=1 ; flag separate compilation
      18                                
      19                                .iff
      20                                
      21        000000                  pf.sep	=0 ; flag unified compilation (via include)
      22                                	
      23                                .endc
      24                                ; 
      25                                ; global registers:
      26                                ;
      27                                ;  R5 - frame pointer
      28                                ;  R4 - argument pointer
      29                                ;  R3 - format string pointer
      30                                ;  R2 - current format character
      31                                ;  R1 - temp
      32                                ;  R0 - temp
      33                                ;
      34                                ; note:	for 11/04-05-10 compatibility, do NOT use SXT/XOR/SOB and MUL/DIV/ASH/ASHC
      35                                ; 
      36                                ; offsets from frame pointer (r5):
      37                                ; 
      38        000012                  p.sr0	=+10.	; saved r0
      39        000010                  p.sr1	=+8.	; saved r1
      40        000006                  p.sr2	=+6.	; saved r2
      41        000004                  p.sr3	=+4.	; saved r3
      42        000002                  p.sr4	=+2.	; saved r4
      43        000000                  p.sr5	=+0.	; saved r5
      44        177777                  p.flg	=-1.	; format flags (byte)
      45        177776                  p.fil	=-2.	; fill character (byte)
      46        177774                  p.wid	=-4.	; format numeric width (word)
      47        177772                  p.pre	=-6.	; format numeric precision (word)
      48        177770                  p.len	=-8.	; number of digits generated (word)
      49        177766                  p.out	=-10.	; addr(char print routine)
      50        177764                  p.ptr	=-12.	; sprintf output buffer pointer
      51                                ; 
      52        000014                  n.last	=+12.	; number of bytes allocated on stack
      53        000016                  n.args	=+14.	; offset to first argument on stack
      54                                ; 
      55                                ; bits in p.flg byte:
      56                                ; 
      57        000001                  pf.ljus	=1	; set for left justified ('-' seen)
      58        000002                  pf.sign	=2	; set for sign requested ('+' seen)
      59        000004                  pf.altf	=4	; set for alt flag ('#' seen)
      60        000010                  pf.long	=10	; set for long value (%...l. seen)
      61        000020                  pf.nega	=20	; set for negative value (msb set)
      62                                
      63                                ; --------------------------------------------------------------------------------
      64                                ;
      65                                ; printf routine .. 'C' printf(format,arg1,arg2,..,argn) ..  called in 'C' style
      66                                ;
      67                                ;	call:	mov	argN,-(sp)
      68                                ;		...
      69                                ;		mov	arg2,-(sp)
      70                                ;		mov	arg1,-(sp)
      71                                ;		mov	format,-(sp)
      72                                ;		call	printf
      73                                ;		add	#2*N,sp
      74                                ;
      75 025102 010046                  printf::mov	r0,-(sp)		; save reg
      76 025104 010146                  	mov	r1,-(sp)		;
      77 025106 010246                  	mov	r2,-(sp)		;
      78 025110 010346                  	mov	r3,-(sp)		;
      79 025112 010446                  	mov	r4,-(sp)		;
      80 025114 010546                  	mov	r5,-(sp)		;
      81                                	
      82 025116 010605                  	mov	sp,r5			; frame pointer
      83 025120 162706  000014          	sub	#n.last,sp		; reserve space on stack
      84                                	
      85 025124 010504                  	mov	r5,r4			; get frame ptr
      86 025126 062704  000016          	add	#n.args,r4		; offset to first argument
      87                                	
      88 025132 012765  025146  177766  	mov	#1$,p.out(r5)		; character output routine
      89 025140 005065  177764          	clr	p.ptr(r5)		; bufptr not used here
      90                                	
      91 025144 000442                  	br	xprintf			; continue
      92                                
      93                                	; ---------------------------------------------------------
      94                                	
      95                                	; character output to console
      96                                	
      97 025146 105737  177564          1$:	tstb	@#ttxcsr		; check if ready
      98 025152 100375                  	bpl	1$			; not yet
      99 025154 110037  177566          	movb	r0,@#ttxbuf		; send character
     100 025160                         	return				; return
       1 025160 000207                  	rts	pc
     101                                	
     102                                ; --------------------------------------------------------------------------------
     103                                ;
     104                                ; sprintf routine .. 'C' sprintf(buffer,format,arg1,arg2,..,argn) ..  called in 'C' style
     105                                ;
     106                                ;	call:	mov	argN,-(sp)
     107                                ;		...
     108                                ;		mov	arg2,-(sp)
     109                                ;		mov	arg1,-(sp)
     110                                ;		mov	format,-(sp)
     111                                ;		mov	buffer,-(sp)
     112                                ;		call	sprintf
     113                                ;		add	#2*N,sp
     114                                ;
     115 025162 010046                  sprintf::mov	r0,-(sp)		; save reg
     116 025164 010146                  	mov	r1,-(sp)		;
     117 025166 010246                  	mov	r2,-(sp)		;
     118 025170 010346                  	mov	r3,-(sp)		;
     119 025172 010446                  	mov	r4,-(sp)		;
     120 025174 010546                  	mov	r5,-(sp)		;
     121                                	
     122 025176 010605                  	mov	sp,r5			; frame pointer
     123 025200 162706  000014          	sub	#n.last,sp		; reserve space on stack
     124                                	
     125 025204 010504                  	mov	r5,r4			; get frame ptr
     126 025206 062704  000016          	add	#n.args,r4		; offset to first argument
     127                                	
     128 025212 012765  025226  177766  	mov	#1$,p.out(r5)		; character output routine
     129 025220 012465  177764          	mov	(r4)+,p.ptr(r5)		; init bufptr from argument
     130                                	
     131 025224 000412                  	br	xprintf			; continue
     132                                
     133                                	; ---------------------------------------------------------
     134                                	
     135                                	; character output to buffer
     136                                	
     137 025226 110075  177764          1$:	movb	r0,@p.ptr(r5)		; store character
     138 025232 005265  177764          	inc	p.ptr(r5)		; bump pointer
     139 025236 105075  177764          	clrb	@p.ptr(r5)		; null terminate
     140 025242 016565  177764  000012  	mov	p.ptr(r5),p.sr0(r5)	; return updated ptr in saved r0
     141 025250                         	return				; return
       1 025250 000207                  	rts	pc
     142                                	
     143                                ; --------------------------------------------------------------------------------
     144                                
     145                                	; process main format
     146                                
     147 025252 012403                  xprintf:mov	(r4)+,r3		; prime format string pointer
     148                                
     149 025254                         1$:	call	900$			; get next format character
       1 025254 004737  026164          	jsr	pc,900$
     150 025260 120227  000045          	cmpb	r2,#<'%>		; hit a format flag?
     151 025264 001430                  	beq	10$			; yes, go process
     152 025266 120227  000134          	cmpb	r2,#<'\>		; hit an escape flag?
     153 025272 001404                  	beq	3$			; yes, go process
     154 025274 010200                  2$:	mov	r2,r0			; char to print
     155 025276                         	call	@p.out(r5)		; no, just print it
       1 025276 004775  177766          	jsr	pc,@p.out(r5)
     156 025302 000764                  	br	1$			; loop
     157                                
     158                                	; process escaped character \a .. \z
     159                                
     160 025304                         3$:	call	900$			; get the escaped character
       1 025304 004737  026164          	jsr	pc,900$
     161 025310 002771                  	blt	2$			; quick exit for [NUL-@] range
     162 025312 120227  000172          	cmpb	r2,#<'z>		;
     163 025316 003366                  	bgt	2$			; exit if [{-DEL]
     164 025320 120227  000141          	cmpb	r2,#<'a>		;
     165 025324 002005                  	bge	4$			; br if [a-z]	
     166 025326 120227  000132          	cmpb	r2,#<'Z>		;
     167 025332 003360                  	bgt	2$			; br if [[-`]
     168 025334 152702  000040          	bisb	#40,r2			; force to [a-z] range
     169 025340 116202  026061          4$:	movb	1000$-<'a>(r2),r2	; translate a..z to escaped
     170 025344 000753                  	br	2$			; go print
     171                                
     172                                	; process format flag %[-+]?(0?\d+([.]\d+)?)?[lh]?[iduscpxo]
     173                                
     174 025346 112765  000040  177776  10$:	movb	#<' >,p.fil(r5)		; blank fill
     175 025354 105065  177777          	clrb	p.flg(r5)		; clear flags
     176 025360 005065  177774          	clr	p.wid(r5)		; init width spec
     177 025364 005065  177772          	clr	p.pre(r5)		; init precision spec
     178 025370 005065  177770          	clr	p.len(r5)		; no digits yet
     179                                
     180 025374                         11$:	call	900$			; get next format character
       1 025374 004737  026164          	jsr	pc,900$
     181 025400 002045                  	bge	40$			; br if [A-DEL]
     182 025402 120227  000045          	cmpb	r2,#<'%>		; check for '%'
     183 025406 001732                  	beq	2$			; br if yes
     184                                
     185                                	; some character in range [NUL-@]
     186                                
     187 025410 120227  000055          	cmpb	r2,#<'->		; check for '-'
     188 025414 001004                  	bne	12$			; br if not
     189 025416 152765  000001  177777  	bisb	#pf.ljus,p.flg(r5)	; yes, set a flag
     190 025424 000763                  	br	11$			; loop
     191 025426 120227  000053          12$:	cmpb	r2,#<'+>		; check for '+'
     192 025432 001004                  	bne	13$			; br if not
     193 025434 152765  000002  177777  	bisb	#pf.sign,p.flg(r5)	; yes, set a flag
     194 025442 000754                  	br	11$			; loop
     195 025444 120227  000043          13$:	cmpb	r2,#<'#>		; check for '#'
     196 025450 001004                  	bne	20$			; br if not
     197 025452 152765  000004  177777  	bisb	#pf.altr,p.flg(r5)	; yes, set a flag
     198 025460 000745                  	br	11$			; loop
     199                                
     200 025462                         20$:	call	800$			; get a number if present
       1 025462 004737  026070          	jsr	pc,800$
     201 025466 010165  177774          	mov	r1,p.wid(r5)		; save number as width
     202                                
     203 025472 120227  000056          	cmpb	r2,#<'.>		; check for .
     204 025476 001006                  	bne	40$			; br if not, should be alpha
     205 025500                         	call	900$			; get next character
       1 025500 004737  026164          	jsr	pc,900$
     206                                
     207 025504                         	call	800$			; get a number if present
       1 025504 004737  026070          	jsr	pc,800$
     208 025510 010165  177772          	mov	r1,p.pre(r5)		; save number as precision
     209                                
     210                                	; flag is in range [A-Za-z]
     211                                
     212 025514 005000                  40$:	clr	r0			; zap numerics
     213 025516 005001                  	clr	r1			;
     214 025520 120227  000101          41$:	cmpb	r2,#<'A>		; check for [:-@]
     215 025524 002663                  	blt	2$			; br if yes
     216 025526 120227  000172          	cmpb	r2,#<'z>		; check for [{-DEL]
     217 025532 003260                  	bgt	2$			; br if yes
     218 025534 120227  000141          	cmpb	r2,#<'a>		; check for [a-z]
     219 025540 002003                  	bge	42$			; br if yes
     220 025542 120227  000132          	cmpb	r2,#<'Z>		; check for [A-Z]
     221 025546 003252                  	bgt	2$			; br if no
     222 025550 042702  000040          42$:	bic	#40,r2			; force to [a-z] to [A-Z] range
     223 025554 012401                  	mov	(r4)+,r1		; get the next value as lsb
     224 025556 006302                  	asl	r2			; char*2 for word offset
     225 025560 000172  025362          	jmp	@400$-<2*'A>(r2)	; dispatch
     226                                
     227                                400$:	;----	aaaa,bbbb,cccc,dddd,eeee,ffff,gggg,hhhh,iiii,jjjj,kkkk,llll,mmmm
     228 025564 025650  026054  025714  	.word	401$,470$,420$,430$,401$,401$,401$,401$,430$,401$,401$,405$,401$
         025572 025734  025650  025650  
         025600 025650  025650  025734  
         025606 025650  025650  025664  
         025614 025650                  
     229                                	;----	nnnn,oooo,pppp,qqqq,rrrr,ssss,tttt,uuuu,vvvv,wwww,xxxx,yyyy,zzzz
     230 025616 025650  026024  026024  	.word	401$,450$,450$,401$,401$,410$,401$,440$,401$,401$,460$,401$,401$
         025624 025650  025650  025702  
         025632 025650  026010  025650  
         025640 025650  026040  025650  
         025646 025650                  
     231                                
     232 025650 005744                  401$:	tst	-(r4)			; %<illegal>: backup argument pointer
     233 025652 005002                  	clr	r2			; zap
     234 025654 156302  177777          	bisb	-1(r3),r2		; retrieve last character
     235 025660 000137  025274          	jmp	2$			; just go print
     236                                
     237 025664                         405$:	call	900$			; %l: get next character
       1 025664 004737  026164          	jsr	pc,900$
     238 025670 152765  000010  177777  	bisb	#pf.long,p.flg(r5)	; indicate longword value
     239 025676 010100                  	mov	r1,r0			; copy 1st arg to msb
     240 025700 000707                  	br	41$			; and go parse next flag
     241                                
     242 025702 010102                  410$:	mov	r1,r2			; %s: get next arg as string address
     243 025704                         	call	prtstr			; print as a string
       1 025704 004737  026624          	jsr	pc,prtstr
     244 025710 000137  025254          	jmp	1$			; continue at the top
     245                                
     246 025714 005046                  420$:	clr	-(sp)			; %c: zap upper byte
     247 025716 110116                  	movb	r1,(sp)			; insert the character
     248 025720 010602                  	mov	sp,r2			; point at string
     249 025722                         	call	prtstr			; print as a string
       1 025722 004737  026624          	jsr	pc,prtstr
     250 025726 005726                  	tst	(sp)+			; flush temp string
     251 025730 000137  025254          	jmp	1$			; continue at the top
     252                                
     253 025734 012702  000012          430$:	mov	#10.,r2			; %d,%i: decimal radix
     254 025740 132765  000010  177777  	bitb	#pf.long,p.flg(r5)	; longword value?
     255 025746 001004                  	bne	431$			; br if yes
     256 025750 005000                  	clr	r0			; zap
     257 025752 005701                  	tst	r1			; no; test lsb sign
     258 025754 100001                  	bpl	431$			; br if plus/zero
     259 025756 005100                  	com	r0			; extend -1 to msb
     260 025760 005700                  431$:	tst	r0			; test msb sign
     261 025762 002006                  	bge	439$			; br if zero or positive
     262 025764 005400                  	neg	r0			; negative; make positive
     263 025766 005401                  	neg	r1			;
     264 025770 005600                  	sbc	r0			;
     265 025772 152765  000020  177777  	bisb	#pf.nega,p.flg(r5)	; set flag indicating negative
     266 026000                         439$:	call	prt32u			; print as unsigned decimal w/sign
       1 026000 004737  026254          	jsr	pc,prt32u
     267 026004 000137  025254          	jmp	1$			; continue at the top
     268                                
     269 026010 012702  000012          440$:	mov	#10.,r2			; %u: decimal radix
     270 026014                         	call	prt32u			; print as an unsigned decimal
       1 026014 004737  026254          	jsr	pc,prt32u
     271 026020 000137  025254          	jmp	1$			; continue at the top
     272                                
     273 026024 012702  000010          450$:	mov	#8.,r2			; %o,%p: octal radix
     274 026030                         	call	prt32u			; print as an unsigned hex
       1 026030 004737  026254          	jsr	pc,prt32u
     275 026034 000137  025254          	jmp	1$			; continue at the top
     276                                
     277 026040 012702  000020          460$:	mov	#16.,r2			; %x: hexadecimal radix
     278 026044                         	call	prt32u			; print as an unsigned hex
       1 026044 004737  026254          	jsr	pc,prt32u
     279 026050 000137  025254          	jmp	1$			; continue at the top
     280                                
     281 026054 012702  000002          470$:	mov	#2.,r2			; %b: binary radix
     282 026060                         	call	prt32u			; print as an unsigned binary
       1 026060 004737  026254          	jsr	pc,prt32u
     283 026064 000137  025254          	jmp	1$			; continue at the top
     284                                
     285                                	; ---------------------------------------------------------
     286                                	; get a number as '[0-9]+' or '*'
     287                                
     288 026070 120227  000052          800$:	cmpb	r2,#<'*>		; check for '*' indirection
     289 026074 001427                  	beq	880$			; br if yes
     290 026076 120227  000060          	cmpb	r2,#<'0>		; check for leading '0' character
     291 026102 001002                  	bne	810$			; br if not
     292 026104 110265  177776          	movb	r2,p.fil(r5)		; yes, set a flag
     293 026110 005001                  810$:	clr	r1			; number accumulated here
     294 026112 120227  000060          820$:	cmpb	r2,#<'0>		; check for '0'
     295 026116 002421                  	blt	890$			; br if less that a '0'
     296 026120 120227  000071          	cmpb	r2,#<'9>		; check for '9'
     297 026124 003016                  	bgt	890$			; br if greater than '9'
     298 026126 162702  000060          	sub	#<'0>,r2		; offset to range 0..9
     299 026132 006301                  	asl	r1			; number *= 2.
     300 026134 010100                  	mov	r1,r0			; (number*2.)
     301 026136 006300                  	asl	r0			; (number*4.)
     302 026140 006300                  	asl	r0			; (number*8.)
     303 026142 060001                  	add	r0,r1			; number = number*8. + number*2.
     304 026144 060201                  	add	r2,r1			; add in this digit
     305 026146                         	call	900$			; get next format character
       1 026146 004737  026164          	jsr	pc,900$
     306 026152 000757                  	br	820$			; and loop
     307 026154 012401                  880$:	mov	(r4)+,r1		; get next arg as number
     308 026156                         	call	900$			; get next character
       1 026156 004737  026164          	jsr	pc,900$
     309 026162                         890$:	return				; return
       1 026162 000207                  	rts	pc
     310                                
     311                                	; ---------------------------------------------------------
     312                                	; get next character (or exit) routine; result in r2
     313                                
     314 026164 112302                  900$:	movb	(r3)+,r2		; get next format character
     315 026166 042702  177600          	bic	#^c177,r2		; 7bit ascii only
     316 026172 001403                  	beq	990$			; end of string seen
     317 026174 120227  000101          	cmpb	r2,#<'A>		; check for [A-DEL]
     318 026200                         	return				; leave CC set with result
       1 026200 000207                  	rts	pc
     319                                
     320 026202 010506                  990$:	mov	r5,sp			; flush frame
     321 026204 012605                  	mov	(sp)+,r5		; restore reg
     322 026206 012604                  	mov	(sp)+,r4		;
     323 026210 012603                  	mov	(sp)+,r3		;
     324 026212 012602                  	mov	(sp)+,r2		;
     325 026214 012601                  	mov	(sp)+,r1		;
     326 026216 012600                  	mov	(sp)+,r0		;
     327 026220                         	return				; return
       1 026220 000207                  	rts	pc
     328                                
     329                                	; ---------------------------------------------------------
     330                                	; escaped character table
     331                                1000$:	;	aaa bbb ccc ddd eee fff ggg hhh iii jjj kkk lll mmm
     332                                	;	BEL  BS         ESC  FF
     333 026222    007     010     143  	.byte	007,010,143,144,033,014,147,150,151,152,153,154,155
         026225    144     033     014  
         026230    147     150     151  
         026233    152     153     154  
         026236    155                  
     334                                	;	nnn ooo ppp qqq rrr sss ttt uuu vvv www xxx yyy zzz
     335                                	;	 LF              CR      HT      VT
     336 026237    012     157     160  	.byte	012,157,160,161,015,163,011,165,013,167,170,172,172
         026242    161     015     163  
         026245    011     165     013  
         026250    167     170     172  
         026253    172                  
     337                                	; ---------------------------------------------------------
     338                                
     339                                ; --------------------------------------------------------------------------------
     340                                ;
     341                                ; digit print routine .. print a 32b value as unsigned digits
     342                                ;
     343                                ;	call:	mov	datahi,r0
     344                                ;		mov	datalo,r1
     345                                ;		mov	#radix,r2 ; 2. or 8. or 10. or 16.
     346                                ;		call	prt32u
     347                                ;
     348                                ;		r0 - data msb      (not saved)
     349                                ;		r1 - data lsb      (not saved)
     350                                ;		r2 - radix         (not saved)
     351                                ;		r3 - ptr to format     (saved)
     352                                ;		r4 - ptr to arglist    (saved) [input not used]
     353                                ;		r5 - ptr to flags      (saved)
     354                                ;
     355 026254 010346                  prt32u:	mov	r3,-(sp)		; save regs we use
     356 026256 010446                  	mov	r4,-(sp)		;
     357                                
     358                                	; render all the digits onto the stack (lsd first, msd last)
     359                                
     360 026260 005046                  	clr	-(sp)			; zero flag
     361 026262 010246                  1$:	mov	r2,-(sp)		; radix lsb
     362 026264 005046                  	clr	-(sp)			;   and msb
     363 026266 010146                  	mov	r1,-(sp)		; number lsb
     364 026270 010046                  	mov	r0,-(sp)		;    and msb
     365 026272                         	call	uldiv			; get quo and rem
       1 026272 004737  027072          	jsr	pc,uldiv
     366 026276 016602  000006          	mov	6.(sp),r2		; restore radix from stack
     367 026302 062706  000010          	add	#8.,sp			; flush args
     368 026306 062703  000060          	add	#<'0>,r3		; make rem lsb a digit
     369 026312 020327  000071          	cmp	r3,#<'9>		; still a valid digit?
     370 026316 003402                  	ble	2$			; br if yes
     371 026320 062703  000007          	add	#<'A>-<':>,r3		; offset to 'A...'Z range
     372 026324 010346                  2$:	mov	r3,-(sp)		; save
     373 026326 005265  177770          	inc	p.len(r5)		; count digits
     374 026332 005701                  	tst	r1			; any lsb left?
     375 026334 001352                  	bne	1$			; br if yes
     376 026336 005700                  	tst	r0			; any msb left?
     377 026340 001350                  	bne	1$			; br if yes
     378                                
     379                                	; check if we generated the minimum number of digits requested
     380                                
     381 026342 026565  177770  177772  10$:	cmp	p.len(r5),p.pre(r5)	; compare length to precision
     382 026350 103005                  	bhis	20$			; br we're OK
     383 026352 012746  000060          	mov	#<'0>,-(sp)		; nope, add another digit
     384 026356 005265  177770          	inc	p.len(r5)		; count digits
     385 026362 000767                  	br	10$			; and loop	
     386                                
     387                                	; check for options (#) flag
     388                                
     389 026364 132765  000004  177777  20$:	bitb	#pf.altf,p.flg(r5)	; check for options flag
     390 026372 001422                  	beq	30$			; br if not set
     391 026374 020227  000020          	cmp	r2,#16.			; radix 16?
     392 026400 001407                  	beq	21$			; br if yes
     393 026402 020227  000010          	cmp	r2,#8.			; radix 8?
     394 026406 001014                  	bne	30$			; br if not
     395 026410 022716  000060          	cmp	#<'0>,(sp)		; first digit already zero?
     396 026414 001411                  	beq	30$			; yes, no need to add
     397 026416 000404                  	br	22$			; no, add a leading zero
     398 026420 012746  000170          21$:	mov	#<'x>,-(sp)		; add a '0x' prefix
     399 026424 005265  177770          	inc	p.len(r5)		; count it
     400 026430 012746  000060          22$:	mov	#<'0>,-(sp)		;
     401 026434 005265  177770          	inc	p.len(r5)		; count it
     402                                
     403                                	; check if we need a sign (+/-/none)
     404                                
     405 026440 132765  000020  177777  30$:	bitb	#pf.nega,p.flg(r5)	; was original value negative?
     406 026446 001403                  	beq	31$			; br if not
     407 026450 012746  000055          	mov	#<'->,-(sp)		; minus sign
     408 026454 000406                  	br	32$			;
     409 026456 132765  000002  177777  31$:	bitb	#pf.sign,p.flg(r5)	; sign always requested?
     410 026464 001404                  	beq	50$			; br if not
     411 026466 012746  000053          	mov	#<'+>,-(sp)		; plus sign
     412 026472 005265  177770          32$:	inc	p.len(r5)		; count all chars generated
     413                                
     414                                	; processing for right justification
     415                                
     416 026476 132765  000001  177777  50$:	bitb	#pf.ljus,p.flg(r5)	; check left-justify flag
     417 026504 001020                  	bne	70$			; br if left justified
     418 026506 116501  177776          	movb	p.fil(r5),r1		; get fill character
     419 026512 026565  177770  177774  51$:	cmp	p.len(r5),p.wid(r5)	; compare length to width
     420 026520 103012                  	bhis	70$			; br if we're OK
     421 026522 011600                  	mov	(sp),r0			; copy last character
     422 026524 010146                  	mov	r1,-(sp)		; add a fill character
     423 026526 020100                  	cmp	r1,r0			; check fill/last char order
     424 026530 101403                  	blos	52$			; br if order OK
     425 026532 010016                  	mov	r0,(sp)			; copy sign/last char
     426 026534 010166  000002          	mov	r1,2(sp)		; insert fill after sign
     427 026540 005265  177770          52$:	inc	p.len(r5)		; count it
     428 026544 000762                  	br	51$			; loop
     429                                
     430                                	; print all digits in order (sign..msd..lsd)
     431                                
     432 026546 005001                  70$:	clr	r1			; count characters output
     433 026550 012600                  71$:	mov	(sp)+,r0		; get a digit
     434 026552 001404                  	beq	80$			; br if no more
     435 026554                         	call	@p.out(r5)		; print it
       1 026554 004775  177766          	jsr	pc,@p.out(r5)
     436 026560 005201                  	inc	r1			; count it
     437 026562 000772                  	br	71$			; loop
     438                                
     439                                	; processing for left justification
     440                                
     441 026564 132765  000001  177777  80$:	bitb	#pf.ljus,p.flg(r5)	; check left-justify flag
     442 026572 001411                  	beq	90$			; br if is right justified
     443 026574 012700  000040          	mov	#<' >,r0		; space fill on right
     444 026600 020165  177774          81$:	cmp	r1,p.wid(r5)		; compare length to width
     445 026604 103004                  	bhis	90$			; br we're OK
     446 026606                         	call	@p.out(r5)		; print it
       1 026606 004775  177766          	jsr	pc,@p.out(r5)
     447 026612 005201                  	inc	r1			; count characters
     448 026614 000771                  	br	81$			; and loop	
     449                                
     450                                	; and done
     451                                
     452 026616 012604                  90$:	mov	(sp)+,r4		; restore regs
     453 026620 012603                  	mov	(sp)+,r3		;
     454 026622                         	return				; return
       1 026622 000207                  	rts	pc
     455                                
     456                                ; --------------------------------------------------------------------------------
     457                                ;
     458                                ; asciz string print routine
     459                                ;
     460                                ;	call:	mov	#strptr,r2
     461                                ;		call	prtstr
     462                                ;
     463                                ;		r0 - temp          (not saved)
     464                                ;		r1 - temp          (not saved)
     465                                ;		r2 - ptr to string (not saved)
     466                                ;		r3 - ptr to format     (saved) [input not used]
     467                                ;		r4 - ptr to arglist    (saved) [input not used]
     468                                ;		r5 - ptr to flags      (saved)
     469                                ;
     470 026624 010346                  prtstr:	mov	r3,-(sp)		; save regs
     471 026626 010446                  	mov	r4,-(sp)		;
     472                                
     473                                	; compute length of string
     474                                
     475 026630 010203                  	mov	r2,r3			; copy ptr to string
     476 026632 105723                  1$:	tstb	(r3)+			; check a byte
     477 026634 001376                  	bne	1$			; br if more string
     478 026636 160203                  	sub	r2,r3			; compute length
     479 026640 005303                  	dec	r3			; minus the trailing null	
     480                                
     481                                	; set precision to length if precision is zero
     482                                
     483 026642 005765  177772          	tst	p.pre(r5)		; check requested precision
     484 026646 001002                  	bne	20$			; br if nonzero
     485 026650 010365  177772          	mov	r3,p.pre(r5)		; else set to string length
     486 026654 020365  177772          20$:	cmp	r3,p.pre(r5)		; compare actual length to precision
     487 026660 101402                  	blos	50$			; br if actual <= precision
     488 026662 016503  177772          	mov	p.pre(r5),r3		; else set actual to precision
     489                                
     490                                	; processing for right justification
     491                                
     492 026666 132765  000001  177777  50$:	bitb	#pf.ljus,p.flg(r5)	; check left-justify flag
     493 026674 001002                  	bne	70$			; br if left justified
     494 026676                         	call	100$			; do fill
       1 026676 004737  026744          	jsr	pc,100$
     495                                
     496                                	; print string 
     497                                
     498 026702 010301                  70$:	mov	r3,r1			; copy length
     499 026704 001406                  	beq	80$			; br if no characters
     500 026706 112200                  71$:	movb	(r2)+,r0		; get a character
     501 026710 001404                  	beq	80$			; br if no characters
     502 026712                         	call	@p.out(r5)		; print it
       1 026712 004775  177766          	jsr	pc,@p.out(r5)
     503 026716 005301                  	dec	r1			; count
     504 026720 001372                  	bne	71$			; loop
     505                                
     506                                	; processing for left justification
     507                                
     508 026722 132765  000001  177777  80$:	bitb	#pf.ljus,p.flg(r5)	; check left-justify flag
     509 026730 001402                  	beq	90$			; br if is right justified
     510 026732                         	call	100$			; do fill
       1 026732 004737  026744          	jsr	pc,100$
     511                                
     512                                	; and done
     513                                
     514 026736 012604                  90$:	mov	(sp)+,r4		; restore
     515 026740 012603                  	mov	(sp)+,r3		;
     516 026742                         	return				; return
       1 026742 000207                  	rts	pc
     517                                
     518                                	; ----------------------------------------------------
     519                                	; generate fill characters
     520                                
     521 026744 016501  177774          100$:	mov	p.wid(r5),r1		; requested width
     522 026750 160301                  	sub	r3,r1			; subtract string width
     523 026752 101406                  	blos	102$			; br if no fill needed
     524 026754 116500  177776          	movb	p.fil(r5),r0		; get fill character
     525 026760                         101$:	call	@p.out(r5)		; print a fill character
       1 026760 004775  177766          	jsr	pc,@p.out(r5)
     526 026764 005301                  	dec	r1			; count
     527 026766 001374                  	bne	101$			; loop
     528 026770                         102$:	return				; done
       1 026770 000207                  	rts	pc
     529                                
     530                                ; --------------------------------------------------------------------------------
     531                                
     532                                .include "mac/muldiv.mac"
       1                                ;=================================================================================
       2                                ; muldiv.mac - 32b mul/div routines for macro11 diagnostics
       3                                ; (C) 2009-2016 Donald North. All rights reserved.
       4                                ;=================================================================================
       5                                
       6                                ; --------------------------------------------------------------------------------
       7                                ;
       8                                ; unsigned 32b * 32b => 32b multiplication
       9                                ; 
      10                                ; from the 2.9BSD stdio C lib, using simple shift/add algorithm
      11                                ; 
      12                                ;	call:	mov	#b.lo,-(sp)
      13                                ;		mov	#b.hi,-(sp)
      14                                ;		mov	#a.lo,-(sp)
      15                                ;		mov	#a.hi,-(sp)
      16                                ;		call	ulmul
      17                                ;		add	#8.,sp
      18                                ;		mov	r1,q.lo
      19                                ;		mov	r0,q.hi
      20                                ;
      21 026772 010246                  ulmul::	mov	r2,-(sp)		; save
      22 026774 010346                  	mov	r3,-(sp)		;
      23 026776 010446                  	mov	r4,-(sp)		;
      24 027000 010546                  	mov	r5,-(sp)		;
      25                                
      26 027002 016605  000020          	mov	8.+8.(sp),r5		; b.lo
      27 027006 016604  000016          	mov	6.+8.(sp),r4		; b.hi
      28 027012 016603  000014          	mov	4.+8.(sp),r3		; a.lo
      29 027016 016602  000012          	mov	2.+8.(sp),r2		; a.hi
      30 027022 005001                  	clr	r1			; q.lo
      31 027024 005000                  	clr	r0			; q.hi
      32                                
      33 027026 000241                  1$:	clc				; shiftin zeroes
      34 027030 006004                  	ror	r4			; shift multiplier right one
      35 027032 006005                  	ror	r5			;
      36 027034 103003                  	bcc	2$			; br if shifted out a zero
      37 027036 060301                  	add	r3,r1			; else add multiplicand to product
      38 027040 005500                  	adc	r0			; propagate C
      39 027042 060200                  	add	r2,r0			;
      40 027044 006303                  2$:	asl	r3			; shift multiplicant left one
      41 027046 006102                  	rol	r2			;
      42 027050 005704                  	tst	r4			; any high multiplier bits left?
      43 027052 001365                  	bne	1$			; br if yes
      44 027054 005705                  	tst	r5			; any low multiplier bits left?
      45 027056 001363                  	bne	1$			; br if yes
      46                                
      47 027060 012605                  	mov	(sp)+,r5		; restore
      48 027062 012604                  	mov	(sp)+,r4		;
      49 027064 012603                  	mov	(sp)+,r3		;
      50 027066 012602                  	mov	(sp)+,r2		;
      51 027070                         	return				; done
       1 027070 000207                  	rts	pc
      52                                
      53                                ; --------------------------------------------------------------------------------
      54                                ;
      55                                ; unsigned 32b / 32b => 32b, 32b division with remainder
      56                                ; 
      57                                ; from Hennessey & Patterson Appendix A
      58                                ;
      59                                ;	call:	mov	#den.lo,-(sp)	; 8.(sp)
      60                                ;		mov	#den.hi,-(sp)	; 6.(sp)
      61                                ;		mov	#num.lo,-(sp)	; 4.(sp)
      62                                ;		mov	#num.hi,-(sp)	; 2.(sp)
      63                                ;		call	uldiv
      64                                ;		add	#8.,sp
      65                                ;		mov	r3,rem.lo
      66                                ;		mov	r2,rem.hi
      67                                ;		mov	r1,quo.lo
      68                                ;		mov	r0,quo.hi
      69                                ;
      70 027072 010446                  uldiv::	mov	r4,-(sp)		; save
      71 027074 010546                  	mov	r5,-(sp)		;
      72                                
      73 027076 016601  000010          	mov	4.+4.(sp),r1		; num.lo
      74 027102 016600  000006          	mov	2.+4.(sp),r0		; num.hi
      75                                
      76 027106 005005                  	clr	r5			; tmp.lo
      77 027110 005004                  	clr	r4			; tmp.hi
      78                                
      79 027112 012746  000037          	mov	#31.,-(sp)		; bit count
      80                                
      81 027116 006301                  1$:	asl	r1			; (tmp,num) <<= 1
      82 027120 006100                  	rol	r0			;
      83 027122 006105                  	rol	r5			;
      84 027124 006104                  	rol	r4			;
      85                                
      86 027126 010503                  	mov	r5,r3			; rem = tmp - den
      87 027130 010402                  	mov	r4,r2			;
      88 027132 166603  000016          	sub	8.+6.(sp),r3		;
      89 027136 005602                  	sbc	r2			;
      90 027140 166602  000014          	sub	6.+6.(sp),r2		;
      91                                
      92 027144 100403                  	bmi	2$			; br if rem < 0
      93                                
      94 027146 005201                  	inc	r1			; quo |= 1
      95 027150 010305                  	mov	r3,r5			; tmp = rem
      96 027152 010204                  	mov	r2,r4			;
      97                                
      98 027154 005316                  2$:	dec	(sp)			; count bits
      99 027156 002357                  	bge	1$			; loop if more
     100 027160 005726                  	tst	(sp)+			; flush counter
     101                                
     102 027162 005702                  	tst	r2			; test for rem < 0
     103 027164 002005                  	bge	3$			; br if not
     104                                
     105 027166 066603  000014          	add	8.+4.(sp),r3		; rem += den correction
     106 027172 005502                  	adc	r2			;
     107 027174 066602  000012          	add	6.+4.(sp),r2		;
     108                                
     109 027200 012605                  3$:	mov	(sp)+,r5		; restore
     110 027202 012604                  	mov	(sp)+,r4		;
     111 027204                         	return				; done
       1 027204 000207                  	rts	pc
     112                                
     113                                ; --------------------------------------------------------------------------------
     114                                ;
     115                                ; signed 32b / 32b => 32b, 32b division with remainder
     116                                ; 
     117                                ;	call:	mov	#den.lo,-(sp)	; 8.(sp)
     118                                ;		mov	#den.hi,-(sp)	; 6.(sp)
     119                                ;		mov	#num.lo,-(sp)	; 4.(sp)
     120                                ;		mov	#num.hi,-(sp)	; 2.(sp)
     121                                ;		call	sldiv
     122                                ;		add	#8.,sp
     123                                ;		mov	r3,rem.lo
     124                                ;		mov	r2,rem.hi
     125                                ;		mov	r1,quo.lo
     126                                ;		mov	r0,quo.hi
     127                                ;
     128 027206 010446                  sldiv::	mov	r4,-(sp)		; save
     129                                
     130 027210 016603  000012          	mov	8.+2.(sp),r3		; den.lo
     131 027214 016602  000010          	mov	6.+2.(sp),r2		; den.hi
     132 027220 016601  000006          	mov	4.+2.(sp),r1		; num.lo
     133 027224 016600  000004          	mov	2.+2.(sp),r0		; num.hi
     134                                
     135 027230 005004                  	clr	r4			; pos
     136                                
     137 027232 005700                  	tst	r0			; num sign
     138 027234 002006                  	bge	10$			; br if pos
     139                                
     140 027236 005104                  	com	r4			; neg
     141                                
     142 027240 005101                  	com	r1			; negate num
     143 027242 005100                  	com	r0			;
     144 027244 062701  000001          	add	#1,r1			;
     145 027250 005500                  	adc	r0			; 
     146                                
     147 027252 005702                  10$:	tst	r2			; den sign
     148 027254 002006                  	bge	20$			; br if pos
     149                                
     150 027256 105104                  	comb	r4			; neg
     151                                
     152 027260 005103                  	com	r3			; negate den
     153 027262 005102                  	com	r2			;
     154 027264 062703  000001          	add	#1,r3			;
     155 027270 005502                  	adc	r2			; 
     156                                	
     157 027272 010346                  20$:	mov	r3,-(sp)		; den.lo
     158 027274 010246                  	mov	r2,-(sp)		; den.hi
     159 027276 010146                  	mov	r1,-(sp)		; num.lo
     160 027300 010046                  	mov	r0,-(sp)		; num.hi
     161 027302                         	call	uldiv			;
       1 027302 004737  027072          	jsr	pc,uldiv
     162 027306 062706  000010          	add	#8.,sp			; 
     163                                
     164 027312 005704                  	tst	r4			; invert result
     165 027314 002005                  	bge	30$			;
     166                                
     167 027316 005103                   	com	r3			; negate rem
     168 027320 005102                  	com	r2			;
     169 027322 062703  000001          	add	#1,r3			;
     170 027326 005502                  	adc	r2			; 
     171                                
     172 027330 105704                  30$:	tstb	r4			; invert result
     173 027332 002005                  	bge	40$			;
     174                                
     175 027334 005101                  	com	r1			; negate quo
     176 027336 005100                  	com	r0			;
     177 027340 062701  000001          	add	#1,r1			;
     178 027344 005500                  	adc	r0			; 
     179                                
     180 027346 012604                  40$:	mov	(sp)+,r4		; restore
     181 027350                         	return				; done
       1 027350 000207                  	rts	pc
     182                                
     183                                ;================================================================================
     184                                ; end of muldiv.mac
     185                                ;================================================================================
     185                                
     533                                
     534                                ; --------------------------------------------------------------------------------
     535                                
     536        000000                  .iif ne,pf.sep,	.end
     537                                
     538                                ;=================================================================================
     539                                ; end of printf.mac
     540                                ;=================================================================================
     540                                
    1110                                
    1111                                .end
    1111                                


Symbol table

$$NUM  = 000004           2014$3 = 015036   L       BIT00  = 000001           MD_ERW = 000010           RPKT   = 012144           
$$POS  = 000200           2014$4 = 016016   L       BIT01  = 000002           MD_EXA = 000040           RUNCNT = 002034           
$ENDAD = 022362           2014$5 = 017657   L       BIT02  = 000004           MD_EXP = 100000           RUNTIL = 002012           
$SAV42 = 002024           2014$6 = 021545   L       BIT03  = 000010           MD_IMF = 000002           SA_A22 = 001000           
.      = 027352           2015$4 = 016077   L       BIT04  = 000020           MD_IMM = 000100           SA_BST = 000374           
1$16   = 025064   L       2015$5 = 017767   L       BIT05  = 000040           MD_NXU = 000001           SA_CL0 = 004000           
1$17   = 025146   L       2015$6 = 021631   L       BIT06  = 000100           MD_OBC = 000004           SA_CLE = 000070           
1$18   = 025226   L       2016$4 = 016205   L       BIT07  = 000200           MD_REV = 000010           SA_CLL = 034000           
1$19   = 025254   L       2016$5 = 020061   L       BIT08  = 000400           MD_RIP = 000001           SA_CN0 = 000020           
1$20   = 026262   L       2016$6 = 021752   L       BIT09  = 001000           MD_RWD = 000002           SA_CNT = 000360           
1$21   = 026632   L       2017$4 = 016276   L       BIT1   = 000002           MD_SCH = 004000           SA_CTY = 000006           
1$22   = 027026   L       2017$5 = 020144   L       BIT10  = 002000           MD_SCL = 002000           SA_EDP = 000400           
1$23   = 027116   L       2017$6 = 022046   L       BIT11  = 004000           MD_SEC = 001000           SA_ERC = 003777           
10$19  = 025346   L       2018$6 = 022165   L       BIT12  = 010000           MD_SER = 000400           SA_ERR = 100000           
10$20  = 026342   L       2020$11= 023260   L       BIT13  = 020000           MD_SHD = 000020           SA_GO  = 000001           
10$24  = 027252   L       2020$13= 023670   L       BIT14  = 040000           MD_SPN = 000001           SA_INE = 000200           
10$5   = 016452   L       2020$14= 024363   L       BIT15  = 100000           MD_SWP = 000004           SA_INT = 000200           
10$7   = 022414   L       2030$11= 023330   L       BIT2   = 000004           MD_UNL = 000020           SA_LFC = 000002           
100$1  = 012644   L       2030$13= 023675   L       BIT3   = 000010           MSG1   = 022434           SA_MC0 = 000001           
100$10 = 022674   L       2030$14= 024477   L       BIT4   = 000020           MSG2   = 022502           SA_MCV = 000017           
100$14 = 023732   L       2040$13= 023700   L       BIT5   = 000040           MSG3   = 022516           SA_NSV = 002000           
100$15 = 024722   L       2040$14= 024626   L       BIT6   = 000100           N.ARGS = 000016           SA_OPT = 000000           
100$2  = 013114   L       2050$13= 023703   L       BIT7   = 000200           N.LAST = 000014           SA_PPT = 100000           
100$21 = 026744   L       21$20  = 026420   L       BIT8   = 000400           NOXXDP = 022376           SA_PRG = 000001           
100$3  = 014232   L       210$3  = 014344   L       BIT9   = 001000           NUMPAS = 002004           SA_RGH = 077777           
100$4  = 015172   L       210$4  = 015316   L       BLKCNT = 002052           ONLINE = 002116           SA_RGL = 177776           
100$5  = 016510   L       210$5  = 017000   L       BLKLEN = 001000           OPTSWI = 002002           SA_RL0 = 000400           
100$6  = 020276   L       210$6  = 020564   L       BLKNUM = 002046           OP_ABO = 000001           SA_RLE = 000007           
100$8  = 022602   L       22$20  = 026430   L       BUFEND = 012120           OP_ACC = 000020           SA_RLL = 003400           
1000$19= 026222   L       220$3  = 014410   L       BUFFER = 002120           OP_ACP = 000102           SA_RS0 = 000001           
101$21 = 026760   L       220$4  = 015366   L       BUFINI = 024714           OP_AVA = 000100           SA_RSV = 000377           
1010$1 = 012726   L       220$5  = 017030   L       BUFLEN = 010000           OP_AVL = 000010           SA_ST1 = 004000           
1010$14= 024202   L       220$6  = 020656   L       BUFSIZ = 000010           OP_CCD = 000021           SA_ST2 = 010000           
1010$2 = 013350   L       230$4  = 015444   L       CEND   = 012312           OP_CMP = 000040           SA_ST3 = 020000           
1010$4 = 015676   L       230$5  = 017060   L       CF_ATN = 000200           OP_DAP = 000013           SA_ST4 = 040000           
1010$5 = 017272   L       230$6  = 020722   L       CF_MSC = 000100           OP_DUP = 000101           SA_STE = 000200           
1011$2 = 013362   L       240$4  = 015500   L       CF_OTH = 000040           OP_END = 000200           SA_STP = 100000           
1012$2 = 013374   L       240$6  = 020742   L       CF_RPL = 100000           OP_ERG = 000026           SA_UCV = 000006           
1013$2 = 013406   L       250$4  = 015514   L       CF_THS = 000020           OP_ERS = 000022           SA_VEC = 000177           
1014$2 = 013420   L       250$6  = 021012   L       CLEN   = 000060           OP_FLU = 000023           SA_VEE = 000177           
102$21 = 026770   L       260$6  = 021032   L       COMM   = 012126           OP_FMT = 000057           SA_VPE = 000400           
1020$1 = 012777   L       270$6  = 021102   L       CONSOL = 165144 G         OP_GCS = 000002           SA_WRP = 040000           
1020$14= 024214   L       280$6  = 021152   L       CPKT   = 012232           OP_GUS = 000003           SLDIV  = 027206 G         
1020$2 = 013426   L       290$14 = 024154   L       CR     = 000015           OP_ILL = 000077           SPRINT = 025162 G         
1020$4 = 015704   L       290$4  = 015620   L       CSR_IP = 002014           OP_NIL = 000000           STACK  = 002000           
1020$5 = 017302   L       290$6  = 021166   L       CSR_SA = 002016           OP_ONL = 000011           START  = 012400           
1030$14= 024226   L       3$19   = 025304   L       DELAY  = 022666           OP_POS = 000045           ST_ABO = 000002           
1040$14= 024240   L       3$23   = 027200   L       DEVSIZ = 002056           OP_RD  = 000041           ST_AVL = 000004           
1050$14= 024252   L       30$20  = 026440   L       DLYCNT = 002032           OP_RPL = 000024           ST_BBR = 000024           
11$19  = 025374   L       30$24  = 027330   L       DMPBUF = 023342           OP_RWA = 000103           ST_BOT = 000015           
110$1  = 012672   L       300$1  = 012676   L       DMPHDR = 022704           OP_SCC = 000004           ST_CMD = 000001           
110$10 = 022702   L       300$5  = 017136   L       DONE   = 022306           OP_SUC = 000012           ST_CMP = 000007           
110$13 = 023464   L       31$20  = 026456   L       DPYREG = 177570 G         OP_WR  = 000042           ST_CNT = 000012           
110$14 = 023760   L       32$20  = 026472   L       DS_INT = 040000           OP_WTM = 000044           ST_DAT = 000010           
110$15 = 024744   L       32768$0= 012420   L       DS_OWN = 100000           P.FIL  = 177776           ST_DIA = 000037           
110$2  = 013146   L       32769$0= 012426   L       DUMPER = 023444           P.FLG  = 177777           ST_DRV = 000013           
110$3  = 014264   L       32770$0= 012444   L       EF_BBR = 000200           P.LEN  = 177770           ST_FMT = 000014           
110$4  = 015232   L       32771$0= 012456   L       EF_BBU = 000100           P.OUT  = 177766           ST_HST = 000011           
110$5  = 016554   L       390$14 = 024164   L       EF_DLS = 000002           P.PRE  = 177772           ST_INF = 000026           
110$6  = 020320   L       390$2  = 013332   L       EF_EOT = 000010           P.PTR  = 177764           ST_INV = 000025           
110$9  = 022632   L       390$3  = 014456   L       EF_LOG = 000040           P.SR0  = 000012           ST_LDR = 000027           
12$19  = 025426   L       390$4  = 015640   L       EF_PLS = 000004           P.SR1  = 000010           ST_LED = 000023           
120$13 = 023514   L       390$6  = 021246   L       EF_SXC = 000020           P.SR2  = 000006           ST_MFE = 000005           
120$14 = 024010   L       4$19   = 025340   L       ERRORS = 002020           P.SR3  = 000004           ST_MSK = 000037           
120$2  = 013202   L       40$19  = 025514   L       EXIT   = 022352           P.SR4  = 000002           ST_OFL = 000003           
120$5  = 016560   L       40$24  = 027346   L       FM_BAD = 000001           P.SR5  = 000000           ST_POL = 000021           
120$6  = 020360   L       400$19 = 025564   L       FM_CNT = 000000           P.WID  = 177774           ST_RDT = 000020           
120$9  = 022646   L       400$5  = 017206   L       FM_DSK = 000002           PASSES = 002022           ST_SUB = 000040           
13$19  = 025444   L       401$19 = 025650   L       FM_IBM = 000013           PF.ALT = 000004           ST_SUC = 000000           
130$13 = 023556   L       405$19 = 025664   L       FM_LDR = 000012           PF.LJU = 000001           ST_SXC = 000022           
130$14 = 024052   L       41$19  = 025520   L       FM_RPL = 000011           PF.LON = 000010           ST_TMK = 000016           
130$2  = 013250   L       410$19 = 025702   L       FM_SDE = 000004           PF.NEG = 000020           ST_WPR = 000006           
130$5  = 016542   L       42$19  = 025550   L       FM_SDI = 000003           PF.SEP = 000000           SWIREG = 177570 G         
130$6  = 020430   L       420$19 = 025714   L       FM_STD = 000007           PF.SIG = 000002           TEST1  = 012570           
140$13 = 023576   L       430$19 = 025734   L       FM_STF = 000010           PRINTF = 025102 G         TEST2  = 013050           
140$14 = 024064   L       431$19 = 025760   L       FM_STI = 000006           PRT32U = 026254           TEST3  = 014166           
140$2  = 013262   L       439$19 = 026000   L       FM_TAP = 000005           PRTSTR = 026624           TEST4  = 015114           
150$13 = 023602   L       440$19 = 026010   L       INIT   = 023712           PSW    = 177776 G         TEST5  = 016416           
150$14 = 024112   L       450$19 = 026024   L       LF     = 000012           P_BCNT = 000014           TEST6  = 020226           
150$2  = 013314   L       460$19 = 026040   L       LF_BBR = 000040           P_BUFF = 000020           TESTNO = 002036           
150$5  = 016634   L       470$19 = 026054   L       LF_CON = 000100           P_CID  = 177777           TICKER = 002026           
160$13 = 023640   L       490$2  = 013336   L       LF_INF = 000002           P_CMST = 000020           TST$NO = 000007           
160$5  = 016724   L       490$6  = 021266   L       LF_RCT = 000020           P_CNTF = 000016           TSTCID = 000000           
190$9  = 022664   L       50$20  = 026476   L       LF_SNR = 000001           P_CNTI = 000024           TTRBUF = 177562 G         
2$19   = 025274   L       50$21  = 026666   L       LF_SUC = 000200           P_CRF  = 000000           TTRCSR = 177560 G         
2$20   = 026324   L       51$20  = 026512   L       LK$CSR = 177546           P_CSIZ = 000060           TTXBUF = 177566 G         
2$22   = 027044   L       510$5  = 017222   L       LK$VEC = 000100           P_CTMO = 000020           TTXCSR = 177564 G         
2$23   = 027154   L       52$20  = 026540   L       LKINTR = 022552           P_CYL  = 000050           T_RQD3 = 000023           
20$19  = 025462   L       580$5  = 017254   L       LK_IEN = 000100           P_DVPM = 000034           T_TK50 = 000011           
20$20  = 026364   L       590$3  = 014502   L       LK_MON = 000200           P_FBBK = 000034           T_TK70 = 000016           
20$21  = 026654   L       590$4  = 015664   L       LK_PRI = 000006           P_FLGS = 000011           T_TU81 = 000005           
20$24  = 027272   L       590$5  = 017260   L       LOOP   = 012562           P_GRP  = 000046           T_UD50 = 000002           
20$5   = 016472   L       590$6  = 021312   L       L_BADR = 000004           P_HTMO = 000020           T_UD5A = 000006           
200$3  = 014324   L       70$20  = 026546   L       L_CHVR = 000025           P_LBN  = 000034           UC17   = 000001           
200$4  = 015276   L       70$21  = 026702   L       L_CNTI = 000014           P_LEN  = 177774           UF_CAC = 100000           
200$5  = 016654   L       71$20  = 026550   L       L_CRF  = 000000           P_MEDI = 000034           UF_CFL = 000004           
200$6  = 020460   L       71$21  = 026706   L       L_CSVR = 000024           P_MLUN = 000014           UF_CMR = 000001           
2010$11= 023150   L       80$20  = 026564   L       L_EVNT = 000012           P_MOD  = 000012           UF_CMW = 000002           
2010$12= 023416   L       80$21  = 026722   L       L_FLGS = 000011           P_MSIZ = 000060           UF_EWR = 000010           
2010$13= 023662   L       800$19 = 026070   L       L_FMT  = 000010           P_OPCD = 000010           UF_EXA = 002000           
2010$14= 024254   L       81$20  = 026600   L       L_HDCD = 000050           P_OTRF = 000014           UF_LOD = 001000           
2010$2 = 013436   L       810$19 = 026110   L       L_LVL  = 000042           P_RBN  = 000014           UF_RMV = 000200           
2010$3 = 014514   L       820$19 = 026112   L       L_MLUN = 000026           P_RBNS = 000056           UF_RPL = 100000           
2010$4 = 015706   L       880$19 = 026154   L       L_RTRY = 000043           P_RCTC = 000057           UF_SCH = 004000           
2010$5 = 017306   L       890$19 = 026162   L       L_SDI  = 000054           P_RCTS = 000054           UF_VSS = 000040           
2010$6 = 021324   L       90$20  = 026616   L       L_SEQ  = 000006           P_SHUN = 000040           UF_VSU = 000020           
2011$2 = 013512   L       90$21  = 026736   L       L_UHVR = 000041           P_STS  = 000012           UF_WBN = 000100           
2011$3 = 014573   L       900$11 = 023146   L       L_UNIT = 000004           P_TIME = 000024           UF_WPD = 000400           
2011$5 = 017354   L       900$12 = 023414   L       L_UNTI = 000030           P_TRCK = 000044           UF_WPH = 020000           
2012$2 = 013623   L       900$19 = 026164   L       L_USVR = 000040           P_TYPE = 177776           UF_WPS = 010000           
2012$3 = 014656   L       990$19 = 026202   L       L_VSER = 000044           P_UNFL = 000016           ULDIV  = 027072 G         
2012$4 = 015745   L       9999$1 = 013044   L       M$BASE = 002006           P_UNIT = 000004           ULMUL  = 026772 G         
2012$5 = 017443   L       9999$2 = 014162   L       M$VECT = 002010           P_UNSZ = 000044           UNITNO = 002040           
2012$6 = 021360   L       9999$3 = 015110   L       MD_ACL = 000002           P_UNTI = 000024           WT4DUN = 022612           
2013$2 = 013741   L       9999$4 = 016412   L       MD_CDL = 010000           P_VRSN = 000014           XPRINT = 025252           
2013$3 = 014731   L       9999$5 = 020222   L       MD_CMP = 040000           P_VSER = 000050           
2013$5 = 017551   L       9999$6 = 022302   L       MD_CSE = 020000           REFNUM = 002042           
2013$6 = 021434   L       ADRCHK = 025030 G         MD_DLE = 000200           REND   = 012224           
2014$2 = 014072   L       BIT0   = 000001           MD_ERR = 010000           RLEN   = 000060           


Program sections:

. ABS.  027352    000   (RW,I,GBL,ABS,OVR,NOSAV)
        000000    001   (RW,I,LCL,REL,CON,NOSAV)
