       1                                .title	DIVIDE Instruction Test
       2                                
       3                                ; (C) 2016 Donald North. All rights reserved.
       4                                
       5                                .include "mac/stddef.mac"
       1                                ;================================================================================
       2                                ; stddef.mac - standard definitions
       3                                ; (C) 2009 Donald North. All rights reserved.
       4                                ;================================================================================
       5                                .macro	align	arg1
      16                                ;================================================================================
      17                                .macro	savreg	arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8
      28                                ;================================================================================
      29                                .macro	resreg	arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8
      40                                ;================================================================================
      41                                .macro	call	proc
      44                                .macro	return
      47                                .macro	calls	proc arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8 arg9 arg10 arg11 arg12 arg13 arg14 arg15 arg16
      67                                ;================================================================================
      68                                .macro	jeq	label ?a1
      73                                .macro	jne	label ?a1
      78                                .macro	jpl	label ?a1
      83                                .macro	jmi	label ?a1
      88                                .macro	jlo	label ?a1
      93                                .macro	jhis	label ?a1
      98                                .macro	jlos	label ?a1
     103                                .macro	jhi	label ?a1
     108                                .macro	jlt	label ?a1
     113                                .macro	jge	label ?a1
     118                                .macro	jle	label ?a1
     123                                .macro	jgt	label ?a1
     128                                .macro	jcc	label ?a1
     133                                .macro	jcs	label ?a1
     138                                .macro	jvc	label ?a1
     143                                .macro	jvs	label ?a1
     148                                ;================================================================================
     149                                .macro	printf	arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8 arg9 arg10 arg11 arg12 arg13 arg14 arg15 arg16
     152                                .macro	sprintf	arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8 arg9 arg10 arg11 arg12 arg13 arg14 arg15 arg16
     155                                ;================================================================================
     156                                .macro	ipl	lvl
     161                                ;================================================================================
     162                                .macro	trapcatcher	list ?a1 ?a2 ?a3 ?a4
     176                                ;================================================================================
     177        000001                  tst$no	= 1
     178                                .macro	test	title
     198                                ;================================================================================
     199                                ; end of stddef.mac
     200                                ;================================================================================
     200                                
       6                                
       7                                ; --------------------------------------------------------------------------------
       8                                
       9                                .sbttl	general definitions
      10                                
      11                                .include "mac/bits.mac"
       1                                ;================================================================================
       2                                ; bits.mac - standard bit definitions
       3                                ;================================================================================
       4                                
       5                                ;  system global fixed addresses
       6                                
       7        177776                  psw	==177776		; processor status word
       8                                
       9        165144                  console	==165144		; console routine start
      10                                
      11        177570                  swireg	==177570		; console switch register
      12        177570                  dpyreg	==swireg		; console display register
      13                                
      14        177560                  ttrcsr	==177560		; console serial device
      15        177562                  ttrbuf	==ttrcsr+2		;
      16        177564                  ttxcsr	==ttrcsr+4		;
      17        177566                  ttxbuf	==ttrcsr+6		;
      18                                
      19                                ; common values
      20                                
      21        000015                  cr	=015			; ascii CR
      22        000012                  lf	=012			; ascii LF
      23                                
      24        000001                  bit00	=000001			; bit positions
      25        000002                  bit01	=000002			;
      26        000004                  bit02	=000004			;
      27        000010                  bit03	=000010			;
      28        000020                  bit04	=000020			;
      29        000040                  bit05	=000040			;
      30        000100                  bit06	=000100			;
      31        000200                  bit07	=000200			;
      32        000400                  bit08	=000400			;
      33        001000                  bit09	=001000			;
      34        002000                  bit10	=002000			;
      35        004000                  bit11	=004000			;
      36        010000                  bit12	=010000			;
      37        020000                  bit13	=020000			;
      38        040000                  bit14	=040000			;
      39        100000                  bit15	=100000			;
      40                                	
      41        000001                  bit0	=bit00			; also
      42        000002                  bit1	=bit01			;
      43        000004                  bit2	=bit02			;
      44        000010                  bit3	=bit03			;
      45        000020                  bit4	=bit04			;
      46        000040                  bit5	=bit05			;
      47        000100                  bit6	=bit06			;
      48        000200                  bit7	=bit07			;
      49        000400                  bit8	=bit08			;
      50        001000                  bit9	=bit09			;
      51                                
      52                                ;================================================================================
      53                                ; end of bits.mac
      54                                ;================================================================================
      54                                
      12                                
      13                                ; --------------------------------------------------------------------------------
      14                                
      15                                .sbttl	low memory
      16                                
      17                                   	.enabl	ama			; change all mode 67 references to 37
      18                                
      19 000000                           	.asect				; absolute load image;	
      20                                
      21        000046                  	.=46
      22 000046 004526                  	.word	$endad			; address of JSR PC,(R0)
      23        000052                  	.=52
      24 000052 000000                  	.word	0			; run options
      25                                
      26        000200                  	.=200
      27 000200 000137  002200          	jmp	@#start			; standard diagnostic entry
      28                                
      29                                ; --------------------------------------------------------------------------------
      30                                
      31                                .sbttl	global variables
      32                                
      33        002000                  	.=2000
      34 002000 177777                  stack:	.word	-1			; top of stack
      35 002002 000000                  $sav42:	.word	0			; XXDP restart address
      36 002004 000000                  passes:	.word	0			; count passes
      37 002006 000000                  msgptr:	.word	0			; message pointer
      38 002010 000000                  errflg:	.word	0			; error flag
      39 002012 000000                  srcr0:	.word	0			; source registers
      40 002014 000000                  srcr1:	.word	0			;
      41 002016 000000                  srcr2:	.word	0			;
      42 002020 000000                  expr0:	.word	0			; expected registers
      43 002022 000000                  expr1:	.word	0			; 
      44 002024 000000                  expr2:	.word	0			; 
      45 002026 000000                  expcc:	.word	0			; 
      46 002030 000000                  rcvr0:	.word	0			; expected registers
      47 002032 000000                  rcvr1:	.word	0			; 
      48 002034 000000                  rcvr2:	.word	0			; 
      49 002036 000000                  rcvcc:	.word	0			; 
      50 002040    015     012     015  msg1:	.asciz	<cr><lf><cr><lf>"Test of DIVIDE Instruction"<cr><lf><cr><lf>
         002043    012     124     145  
         002046    163     164     040  
         002051    157     146     040  
         002054    104     111     126  
         002057    111     104     105  
         002062    040     111     156  
         002065    163     164     162  
         002070    165     143     164  
         002073    151     157     156  
         002076    015     012     015  
         002101    012     000          
      51 002103    015     012     107  msg2:	.asciz	<cr><lf>"Goodbye"<cr><lf>
         002106    157     157     144  
         002111    142     171     145  
         002114    015     012     000  
      52 002117    000                  	.even
      53                                
      54        000001                  prtall	=1				; 1 always print, 0 only on error
      55                                
      56                                ; --------------------------------------------------------------------------------
      57                                
      58                                .sbttl	program start
      59                                
      60 002120                         	align	7			; pc alignment
       9                                .list
      61                                
      62 002200 012706  002000          start:	mov	#stack,sp		; setup a stack
      63 002204 000005                  	reset				; reset the world
      64 002206 013737  000042  002002  	mov	@#42,$sav42		; save XXDP restart
      65                                
      66 002214                         	trapcatcher <2,200,206,400>	; setup a trapcatcher in low vector space
       1 002214 012700  002244          	mov	#32770$,r0    		; ptr to table
       2 002220 012001                  32768$:	mov	(r0)+,r1		; start addr
       3 002222 100415                  	bmi	32771$			; done?
       4 002224 012002                  	mov	(r0)+,r2		; end addr
       5 002226 010161  177776          32769$:	mov	r1,-2(r1)		; point vector at next word
       6 002232 005011                  	clr	(r1)			; <0> which is a halt
       7 002234 022121                  	cmp	(r1)+,(r1)+		; add four to ptr
       8 002236 020102                  	cmp	r1,r2			; reached end?
       9 002240 003772                  	ble	32769$			; not yet
      10 002242 000766                  	br	32768$			; more
      11 002244 000002  000200  000206  32770$:	.word	2,200,206,400, -1
         002252 000400  177777          
      12 002256 000240                  32771$:	nop				; placeholder
      67                                
      68 002260                         	printf	#msg1			; say hello
       1 002260                         	calls	printf #msg1               
       8                                .list
       9 002260 012746  002040          	mov	#msg1,-(sp)
       1                                .list
       2 002264                         	call	printf
       1 002264 004737  004766          	jsr	pc,printf
       3 002270 062706  000002          	add	#2,sp
      18                                .list
      69                                
      70 002274 005037  002004          	clr	passes			;
      71                                
      72 002300                         loop:	printf	#710$			; header
       1 002300                         	calls	printf #710$               
       8                                .list
       9 002300 012746  003526          	mov	#710$,-(sp)
       1                                .list
       2 002304                         	call	printf
       1 002304 004737  004766          	jsr	pc,printf
       3 002310 062706  000002          	add	#2,sp
      18                                .list
      73 002314 012705  003116          	mov	#500$,r5		; data table
      74                                
      75 002320 012537  002012          100$:	mov	(r5)+,srcr0		; source data
      76 002324 012537  002014          	mov	(r5)+,srcr1		;
      77 002330 012537  002016          	mov	(r5)+,srcr2		;
      78                                
      79 002334 013700  002012          	mov	srcr0,r0		; setup
      80 002340 013701  002014          	mov	srcr1,r1		; 
      81 002344 013702  002016          	mov	srcr2,r2		; 
      82 002350 000257                  	ccc				; ps[nzvc]=0000
      83                                
      84 002352 071002                  	div	r2,r0			; *** do it ***
      85                                
      86 002354 013737  177776  002036  	mov	@#psw,rcvcc		; processor status
      87 002362 042737  177760  002036  	bic	#^c<^b1111>,rcvcc	; mask all except NZVC
      88                                
      89 002370 010037  002030          	mov	r0,rcvr0		; save results
      90 002374 010137  002032          	mov	r1,rcvr1		;
      91 002400 010237  002034          	mov	r2,rcvr2
      92                                
      93 002404 013700  002012          	mov	srcr0,r0		; setup
      94 002410 013701  002014          	mov	srcr1,r1		;
      95 002414 013702  002016          	mov	srcr2,r2		;
      96 002420 000257                  	ccc				; ps[nzvc]=0000
      97                                
      98 002422                         	call	divide			; *** do it ***
       1 002422 004737  004564          	jsr	pc,divide
      99                                
     100 002426 013737  177776  002026  	mov	@#psw,expcc		; processor status
     101 002434 042737  177760  002026  	bic	#^c<^b1111>,expcc	; mask all except NZVC
     102                                
     103 002442 010037  002020          	mov	r0,expr0		; save results
     104 002446 010137  002022          	mov	r1,expr1		;
     105 002452 010237  002024          	mov	r2,expr2		; 
     106                                
     107 002456 005037  002010          	clr	errflg			; no error
     108 002462 012737  004442  002006  	mov	#740$,msgptr		; assume pass
     109 002470 023737  002020  002030  	cmp	expr0,rcvr0		; check results
     110 002476 001033                  	bne	150$			;
     111 002500 023737  002022  002032  	cmp	expr1,rcvr1		;
     112 002506 001027                  	bne	150$			;
     113 002510 023737  002024  002034  	cmp	expr2,rcvr2		;
     114 002516 001023                  	bne	150$			;
     115 002520 032737  000002  002026  	bit	#^b0010,expcc		; overflow result?
     116 002526 001413                  	beq	140$			; br if not
     117 002530 013700  002026          	mov	expcc,r0		; exp cc
     118 002534 042700  177774          	bic	#^c<^b0011>,r0		; ovf; clear ps[nz--]
     119 002540 013701  002036          	mov	rcvcc,r1		; rcv cc
     120 002544 042701  177774          	bic	#^c<^b0011>,r1		; ovf; clear ps[nz--]
     121 002550 020001                  	cmp	r0,r1			; cmp ps[--vc] only
     122 002552 001412                  	beq	155$			; ok
     123 002554 000404                  	br	150$			; error
     124 002556 023737  002026  002036  140$:	cmp	expcc,rcvcc		;
     125 002564 001405                  	beq	155$			;
     126 002566 012737  004447  002006  150$:	mov	#741$,msgptr		; nope, fail
     127 002574 005237  002010          	inc	errflg			; signal error
     128 002600 000240                  155$:	nop				;
     129                                
     130        000001                  .if eq prtall
     131                                	tst	errflg			; error?
     132                                	beq	200$			; br if not
     133                                .endc
     134 002602                         	printf	#711$,srcr0,srcr1,srcr2,srcr0,srcr1,srcr2 ; print source
       1 002602                         	calls	printf #711$ srcr0 srcr1 srcr2 srcr0 srcr1 srcr2         
       8                                .list
       9 002602 013746  002016          	mov	srcr2,-(sp)
      14                                .list
      15 002606 013746  002014          	mov	srcr1,-(sp)
      20                                .list
      21 002612 013746  002012          	mov	srcr0,-(sp)
      26                                .list
      27 002616 013746  002016          	mov	srcr2,-(sp)
      32                                .list
      33 002622 013746  002014          	mov	srcr1,-(sp)
      38                                .list
      39 002626 013746  002012          	mov	srcr0,-(sp)
      44                                .list
      45 002632 012746  004200          	mov	#711$,-(sp)
       1                                .list
       2 002636                         	call	printf
       1 002636 004737  004766          	jsr	pc,printf
       3 002642 062706  000016          	add	#16,sp
      18                                .list
     135 002646                         	printf	#712$,rcvr0,rcvr1,rcvr2,rcvcc,rcvr0,rcvr1 ; print instruction result
       1 002646                         	calls	printf #712$ rcvr0 rcvr1 rcvr2 rcvcc rcvr0 rcvr1         
       8                                .list
       9 002646 013746  002032          	mov	rcvr1,-(sp)
      14                                .list
      15 002652 013746  002030          	mov	rcvr0,-(sp)
      20                                .list
      21 002656 013746  002036          	mov	rcvcc,-(sp)
      26                                .list
      27 002662 013746  002034          	mov	rcvr2,-(sp)
      32                                .list
      33 002666 013746  002032          	mov	rcvr1,-(sp)
      38                                .list
      39 002672 013746  002030          	mov	rcvr0,-(sp)
      44                                .list
      45 002676 012746  004240          	mov	#712$,-(sp)
       1                                .list
       2 002702                         	call	printf
       1 002702 004737  004766          	jsr	pc,printf
       3 002706 062706  000016          	add	#16,sp
      18                                .list
     136 002712 032737  000002  002026  	bit	#^b0010,expcc		; ps[--v-] expected?
     137 002720 001023                  	bne	180$			; br if yes
     138 002722                         	printf	#712$,expr0,expr1,expr2,expcc,expr0,expr1 ; print emulation result
       1 002722                         	calls	printf #712$ expr0 expr1 expr2 expcc expr0 expr1         
       8                                .list
       9 002722 013746  002022          	mov	expr1,-(sp)
      14                                .list
      15 002726 013746  002020          	mov	expr0,-(sp)
      20                                .list
      21 002732 013746  002026          	mov	expcc,-(sp)
      26                                .list
      27 002736 013746  002024          	mov	expr2,-(sp)
      32                                .list
      33 002742 013746  002022          	mov	expr1,-(sp)
      38                                .list
      39 002746 013746  002020          	mov	expr0,-(sp)
      44                                .list
      45 002752 012746  004240          	mov	#712$,-(sp)
       1                                .list
       2 002756                         	call	printf
       1 002756 004737  004766          	jsr	pc,printf
       3 002762 062706  000016          	add	#16,sp
      18                                .list
     139 002766 000425                  	br	190$			; 
     140 002770 042737  177774  002026  180$:	bic	#^c<^b0011>,expcc	; zap unknown ps[nz--]
     141 002776                         	printf	#713$,expr0,expr1,expr2,expcc,expr0,expr1 ; print emulation result
       1 002776                         	calls	printf #713$ expr0 expr1 expr2 expcc expr0 expr1         
       8                                .list
       9 002776 013746  002022          	mov	expr1,-(sp)
      14                                .list
      15 003002 013746  002020          	mov	expr0,-(sp)
      20                                .list
      21 003006 013746  002026          	mov	expcc,-(sp)
      26                                .list
      27 003012 013746  002024          	mov	expr2,-(sp)
      32                                .list
      33 003016 013746  002022          	mov	expr1,-(sp)
      38                                .list
      39 003022 013746  002020          	mov	expr0,-(sp)
      44                                .list
      45 003026 012746  004277          	mov	#713$,-(sp)
       1                                .list
       2 003032                         	call	printf
       1 003032 004737  004766          	jsr	pc,printf
       3 003036 062706  000016          	add	#16,sp
      18                                .list
     142 003042 013700  002036          190$:	mov	rcvcc,r0		; rcv nzvc
     143 003046 116000  004454          	movb	750$(r0),r0		; get message index
     144 003052                         	printf	#714$,msgptr,751$(r0)	; print messages
       1 003052                         	calls	printf #714$ msgptr 751$(r0)             
       8                                .list
       9 003052 016046  004474          	mov	751$(r0),-(sp)
      14                                .list
      15 003056 013746  002006          	mov	msgptr,-(sp)
      20                                .list
      21 003062 012746  004340          	mov	#714$,-(sp)
       1                                .list
       2 003066                         	call	printf
       1 003066 004737  004766          	jsr	pc,printf
       3 003072 062706  000006          	add	#6,sp
      18                                .list
     145 003076 000240                  200$:	nop				;
     146                                
     147 003100 020527  003526          	cmp	r5,#501$		; end of table
     148 003104                         	jne	100$
       1 003104 001402                  	beq	32768$
       2 003106 000137  002320          	jmp	100$
       3                                32768$:
     149 003112 000137  004502          	jmp	done			; all done
     150                                
     151                                500$:	;        NUMhi   NUMlo   DENlo
     152                                	;           R0      R1      R2
     153 003116 000001  000001  000000  	.word	     1,      1,      0
     154 003124 177777  000001  000000  	.word	    -1,      1,      0
     155 003132 000001  177777  000000  	.word	     1,     -1,      0
     156 003140 177777  177777  000000  	.word	    -1,     -1,      0
     157                                	; 
     158 003146 000000  000000  000001  	.word	     0,      0,	     1
     159 003154 000000  000000  000000  	.word	     0,      0,      0
     160 003162 000000  000000  177777  	.word	     0,      0,	    -1
     161                                	; 
     162 003170 000003  000004  000003  	.word	     3,      4,      3
     163 003176 177775  000004  000003  	.word	    -3,      4,      3
     164 003204 000003  177774  000003  	.word	     3,     -4,      3
     165 003212 177775  177774  000003  	.word	    -3,     -4,      3
     166 003220 000003  000004  177775  	.word	     3,      4,     -3
     167 003226 177775  000004  177775  	.word	    -3,      4,     -3
     168 003234 000003  177774  177775  	.word	     3,     -4,     -3
     169 003242 177775  177774  177775  	.word	    -3,     -4,     -3
     170                                	; 
     171 003250 100000  000000  000001  	.word	100000,	000000,      1
     172 003256 100000  000000  177777  	.word	100000,	000000,     -1
     173 003264 077777  177777  000001  	.word	077777, 177777,      1
     174 003272 077777  177777  177777  	.word	077777, 177777,     -1
     175                                	; 
     176 003300 000002  123456  000003  	.word	     2, 123456,      3
     177 003306 012345  012345  000005  	.word	 12345,  12345,      5
     178                                	; 
     179 003314 000000  001000  000010  	.word	     0,   1000,     10
     180 003322 000000  001000  177770  	.word	     0,   1000,    -10
     181 003330 177777  177000  000010  	.word	    -1,  -1000,     10
     182 003336 177777  177000  177770  	.word	    -1,  -1000,    -10
     183                                	; 
     184 003344 000000  001234  000021  	.word	     0,   1234,     21
     185 003352 000000  001234  177757  	.word	     0,   1234,    -21
     186 003360 177777  176544  000021  	.word	    -1,  -1234,     21
     187 003366 177777  176544  177757  	.word	    -1,  -1234,    -21
     188                                	; 
     189 003374 000010  001234  005432  	.word	    10,   1234,   5432
     190 003402 012345  012345  054321  	.word	 12345,  12345,  54321
     191                                	; 
     192 003410 000000  020000  000002  	.word	     0,  20000,      2  ;      8192. / 2.
     193 003416 000000  040000  000002  	.word	     0,  40000,      2  ;     16384. / 2.
     194 003424 000000  100000  000002  	.word	     0, 100000,      2  ;     32768. / 2.
     195 003432 000001  000000  000002  	.word	     1,      0,      2  ;     65536. / 2.
     196 003440 000002  000000  000002  	.word	     2,      0,      2  ;    131072. / 2.
     197                                	; 
     198 003446 000230  113200  000012  	.word	   230, 113200,    10.  ;  10000000. / 10.
     199 003454 000230  113200  000144  	.word	   230, 113200,   100.  ;  10000000. / 100.
     200 003462 000230  113200  001750  	.word	   230, 113200,  1000.  ;  10000000. / 1000.
     201 003470 000230  113200  023420  	.word	   230, 113200, 10000.  ;  10000000. / 10000.
     202                                	; 
     203 003476 000230  113200  177766  	.word	   230, 113200,    -10. ;  10000000. / -10.
     204 003504 000230  113200  177634  	.word	   230, 113200,   -100. ;  10000000. / -100.
     205 003512 000230  113200  176030  	.word	   230, 113200,  -1000. ;  10000000. / -1000.
     206 003520 000230  113200  154360  	.word	   230, 113200, -10000. ;  10000000. / -10000.
     207                                501$:
     208                                
     209 003526    040     040     055  710$:	.ascii	"  ---------------INPUT---------------------   "
         003531    055     055     055  
         003534    055     055     055  
         003537    055     055     055  
         003542    055     055     055  
         003545    055     055     111  
         003550    116     120     125  
         003553    124     055     055  
         003556    055     055     055  
         003561    055     055     055  
         003564    055     055     055  
         003567    055     055     055  
         003572    055     055     055  
         003575    055     055     055  
         003600    055     040     040  
         003603    040                  
     210 003604    040     055     055  	.ascii	" ----------RECEIVED OUTPUT----------------"
         003607    055     055     055  
         003612    055     055     055  
         003615    055     055     122  
         003620    105     103     105  
         003623    111     126     105  
         003626    104     040     117  
         003631    125     124     120  
         003634    125     124     055  
         003637    055     055     055  
         003642    055     055     055  
         003645    055     055     055  
         003650    055     055     055  
         003653    055     055     055  
     211 003656    040     055     055  	.ascii	" ----------EXPECTED OUTPUT----------------"
         003661    055     055     055  
         003664    055     055     055  
         003667    055     055     105  
         003672    130     120     105  
         003675    103     124     105  
         003700    104     040     117  
         003703    125     124     120  
         003706    125     124     055  
         003711    055     055     055  
         003714    055     055     055  
         003717    055     055     055  
         003722    055     055     055  
         003725    055     055     055  
     212 003730    040     055     055  	.ascii	" ----------INFO----------"<cr><lf>
         003733    055     055     055  
         003736    055     055     055  
         003741    055     055     111  
         003744    116     106     117  
         003747    055     055     055  
         003752    055     055     055  
         003755    055     055     055  
         003760    055     015     012  
     213 003763    040     040     056  	.ascii	"  ..R0.. ..R1.. ..R2.. .....NUM.... ..DEN.. =>"
         003766    056     122     060  
         003771    056     056     040  
         003774    056     056     122  
         003777    061     056     056  
         004002    040     056     056  
         004005    122     062     056  
         004010    056     040     056  
         004013    056     056     056  
         004016    056     116     125  
         004021    115     056     056  
         004024    056     056     040  
         004027    056     056     104  
         004032    105     116     056  
         004035    056     040     075  
         004040    076                  
     214 004041    040     056     056  	.ascii	" ..R0.. ..R1.. ..R2.. NZVC ..QUO.. ..REM.."
         004044    122     060     056  
         004047    056     040     056  
         004052    056     122     061  
         004055    056     056     040  
         004060    056     056     122  
         004063    062     056     056  
         004066    040     116     132  
         004071    126     103     040  
         004074    056     056     121  
         004077    125     117     056  
         004102    056     040     056  
         004105    056     122     105  
         004110    115     056     056  
     215 004113    040     056     056  	.asciz	" ..R0.. ..R1.. ..R2.. NZVC ..QUO.. ..REM.. Notes"<cr><lf><cr><lf>
         004116    122     060     056  
         004121    056     040     056  
         004124    056     122     061  
         004127    056     056     040  
         004132    056     056     122  
         004135    062     056     056  
         004140    040     116     132  
         004143    126     103     040  
         004146    056     056     121  
         004151    125     117     056  
         004154    056     040     056  
         004157    056     122     105  
         004162    115     056     056  
         004165    040     116     157  
         004170    164     145     163  
         004173    015     012     015  
         004176    012     000          
     216 004200    040     040     045  711$:	.asciz	"  %.6o %.6o %.6o %11ld. %6d. =>"
         004203    056     066     157  
         004206    040     045     056  
         004211    066     157     040  
         004214    045     056     066  
         004217    157     040     045  
         004222    061     061     154  
         004225    144     056     040  
         004230    045     066     144  
         004233    056     040     075  
         004236    076     000          
     217 004240    040     045     056  712$:	.asciz	" %.6o %.6o %.6o %.4b %6d. %6d."
         004243    066     157     040  
         004246    045     056     066  
         004251    157     040     045  
         004254    056     066     157  
         004257    040     045     056  
         004262    064     142     040  
         004265    045     066     144  
         004270    056     040     045  
         004273    066     144     056  
         004276    000                  
     218 004277    040     045     056  713$:	.asciz	" %.6o %.6o %.6o xx%.2b %6d. %6d."
         004302    066     157     040  
         004305    045     056     066  
         004310    157     040     045  
         004313    056     066     157  
         004316    040     170     170  
         004321    045     056     062  
         004324    142     040     045  
         004327    066     144     056  
         004332    040     045     066  
         004335    144     056     000  
     219 004340    040     045     163  714$:	.asciz	" %s %s"<cr><lf>
         004343    040     045     163  
         004346    015     012     000  
     220 004351    000                  730$:	.asciz	""
     221 004352    055     040     101  731$:	.asciz	"- ABORTED: divide by zero"
         004355    102     117     122  
         004360    124     105     104  
         004363    072     040     144  
         004366    151     166     151  
         004371    144     145     040  
         004374    142     171     040  
         004377    172     145     162  
         004402    157     000          
     222 004404    055     040     101  732$:	.asciz	"- ABORTED: quotient too large"
         004407    102     117     122  
         004412    124     105     104  
         004415    072     040     161  
         004420    165     157     164  
         004423    151     145     156  
         004426    164     040     164  
         004431    157     157     040  
         004434    154     141     162  
         004437    147     145     000  
     223 004442    160     141     163  740$:	.asciz	"pass"
         004445    163     000          
     224 004447    106     101     111  741$:	.asciz	"FAIL"
         004452    114     000          
     225                                	.even
     226 004454    000     002     004  750$:	.byte	0,2,4,2, 0,2,4,2, 0,2,4,2, 0,2,4,2
         004457    002     000     002  
         004462    004     002     000  
         004465    002     004     002  
         004470    000     002     004  
         004473    002                  
     227 004474 004351  004352  004404  751$:	.word	730$,731$,732$
     228                                
     229                                ; --------------------------------------------------------------------------------
     230                                
     231 004502                         done:	printf	#msg2			; say goodbye
       1 004502                         	calls	printf #msg2               
       8                                .list
       9 004502 012746  002103          	mov	#msg2,-(sp)
       1                                .list
       2 004506                         	call	printf
       1 004506 004737  004766          	jsr	pc,printf
       3 004512 062706  000002          	add	#2,sp
      18                                .list
     232                                
     233 004516 013700  002002          	mov	$sav42,r0		; check if loaded by XXDP
     234 004522 001407                  	beq	noxxdp			; br if not
     235 004524 000005                  	reset				; yes, reset the world
     236 004526 004710                  $endad:	jsr	pc,(r0)			; return back to XXDP
     237 004530 000240                  	nop				; standard sequence
     238 004532 000240                  	nop				;
     239 004534 000240                  	nop				;
     240 004536 000137  002300          	jmp	loop			; back for more
     241                                
     242 004542 005000                  noxxdp:	clr	r0			;
     243 004544 005300                  10$:	dec	r0			; 
     244 004546 001376                  	bne	10$			; some delay
     245 004550 000005                  	reset				; zap the world
     246 004552 012746  000340          	mov	#<7>*bit5,-(sp)		; prio7 in psw
     247 004556 012746  165144          	mov	#console,-(sp)		; go there
     248 004562 000002                  	rti				; reload psw
     249                                
     250                                ; --------------------------------------------------------------------------------
     251                                ;
     252                                ; DIVIDE instruction emulator
     253                                ;
     254                                ;	mov	numhi,r0
     255                                ;	mov	numlo,r1
     256                                ;	mov	denlo,r2
     257                                ;	call	divide
     258                                ;	mov	r0,quolo
     259                                ;	mov	r1,remlo
     260                                ; 
     261 004564 005046                  divide:	clr	-(sp)			; ps[nzvc] slot
     262 004566 010346                  	mov	r3,-(sp)		; save r3..r0
     263 004570 010246                  	mov	r2,-(sp)		; 
     264 004572 010146                  	mov	r1,-(sp)		;
     265 004574 010046                  	mov	r0,-(sp)		; 
     266                                
     267 004576 005702                  	tst	r2			; check den
     268 004600 001004                  	bne	40$			; br if nonzero
     269                                
     270 004602 012766  000007  000010  	mov	#^b0111,8.(sp)		; set ps[nzvc] for div-by-0
     271 004610 000423                  	br	70$			; 
     272                                
     273 004612 010246                  40$:	mov	r2,-(sp)		; den lo
     274 004614 006746                  	sxt	-(sp)			; den hi
     275 004616 010146                  	mov	r1,-(sp)		; num lo
     276 004620 010046                  	mov	r0,-(sp)		; num hi
     277 004622                         	call	sldiv			; do 32b/32b divide
       1 004622 004737  007072          	jsr	pc,sldiv
     278 004626 062706  000010          	add	#8.,sp			; 
     279                                
     280        000000                  .if ne 0
     281                                	printf	#500$,r0,r1,r2,r3	; debug results
     282                                .endc
     283                                
     284 004632 005700                  	tst	r0			; quo hi zero?
     285 004634 001002                  	bne	50$			; br if not
     286 004636 005701                  	tst	r1			; quo lo minus?
     287 004640 100012                  	bpl	80$			; br if not
     288                                
     289 004642 005100                  50$:	com	r0			; quo hi ones?
     290 004644 001002                  	bne	60$			; br if not
     291 004646 005701                  	tst	r1			; quo lo plus?
     292 004650 100406                  	bmi	80$			; br if not
     293                                
     294 004652 052766  000002  000010  60$:	bis	#^b0010,8.(sp)		; set ps[--v-] for overflow
     295                                
     296 004660 012600                  70$:	mov	(sp)+,r0		; restore
     297 004662 012601                  	mov	(sp)+,r1		; 
     298 004664 000411                  	br	90$			; 
     299                                
     300 004666 010100                  80$:	mov	r1,r0			; quo lo
     301 004670 013766  177776  000010  	mov	@#psw,8.(sp)		; save ps[nzvc]
     302 004676 042766  177763  000010  	bic	#^c<^b1100>,8.(sp)	; mask ps[vc]
     303 004704 010301                  	mov	r3,r1			; rem lo
     304 004706 022626                  	cmp	(sp)+,(sp)+		; flush saved r0,r1
     305                                
     306 004710 012602                  90$:	mov	(sp)+,r2		; restore
     307 004712 012603                  	mov	(sp)+,r3		;
     308 004714 012637  177776          	mov	(sp)+,@#psw		; set ps[nzvc]
     309 004720                         	return				; done
       1 004720 000207                  	rts	pc
     310                                
     311 004722    040     050     122  500$:	.asciz	" (R0/%.6o R1/%.6o R2/%.6o R3/%.6o) "
         004725    060     057     045  
         004730    056     066     157  
         004733    040     122     061  
         004736    057     045     056  
         004741    066     157     040  
         004744    122     062     057  
         004747    045     056     066  
         004752    157     040     122  
         004755    063     057     045  
         004760    056     066     157  
         004763    051     040     000  
     312                                
     313                                ; --------------------------------------------------------------------------------
     314                                
     315                                .include "mac/printf.mac"
       1                                ;================================================================================
       2                                ; printf.mac - printf routines for macro11 diagnostics
       3                                ; (C) 2009-2016 Donald North. All rights reserved.
       4                                ;================================================================================
       5                                
       6                                .if ndf ttxcsr
       7                                	
       8                                	; separate psect (if console registers not defined)
       9                                	.psect	printf
      10                                
      11                                	; external tty references
      12                                	.globl	ttxcsr, ttxbuf
      13                                
      14                                	; standard macro definitions
      15                                 	.include "mac/stddef.mac"
      16                                
      17                                pf.sep	=1 ; flag separate compilation
      18                                
      19                                .iff
      20                                
      21        000000                  pf.sep	=0 ; flag unified compilation (via include)
      22                                	
      23                                .endc
      24                                ; 
      25                                ; global registers:
      26                                ;
      27                                ;  R5 - frame pointer
      28                                ;  R4 - argument pointer
      29                                ;  R3 - format string pointer
      30                                ;  R2 - current format character
      31                                ;  R1 - temp
      32                                ;  R0 - temp
      33                                ;
      34                                ; note:	for 11/04-05-10 compatibility, do NOT use SXT/XOR/SOB and MUL/DIV/ASH/ASHC
      35                                ; 
      36                                ; offsets from frame pointer (r5):
      37                                ; 
      38        000012                  p.sr0	=+10.	; saved r0
      39        000010                  p.sr1	=+8.	; saved r1
      40        000006                  p.sr2	=+6.	; saved r2
      41        000004                  p.sr3	=+4.	; saved r3
      42        000002                  p.sr4	=+2.	; saved r4
      43        000000                  p.sr5	=+0.	; saved r5
      44        177777                  p.flg	=-1.	; format flags (byte)
      45        177776                  p.fil	=-2.	; fill character (byte)
      46        177774                  p.wid	=-4.	; format numeric width (word)
      47        177772                  p.pre	=-6.	; format numeric precision (word)
      48        177770                  p.len	=-8.	; number of digits generated (word)
      49        177766                  p.out	=-10.	; addr(char print routine)
      50        177764                  p.ptr	=-12.	; sprintf output buffer pointer
      51                                ; 
      52        000014                  n.last	=+12.	; number of bytes allocated on stack
      53        000016                  n.args	=+14.	; offset to first argument on stack
      54                                ; 
      55                                ; bits in p.flg byte:
      56                                ; 
      57        000001                  pf.ljus	=1	; set for left justified ('-' seen)
      58        000002                  pf.sign	=2	; set for sign requested ('+' seen)
      59        000004                  pf.altf	=4	; set for alt flag ('#' seen)
      60        000010                  pf.long	=10	; set for long value (%...l. seen)
      61        000020                  pf.nega	=20	; set for negative value (msb set)
      62                                
      63                                ; --------------------------------------------------------------------------------
      64                                ;
      65                                ; printf routine .. 'C' printf(format,arg1,arg2,..,argn) ..  called in 'C' style
      66                                ;
      67                                ;	call:	mov	argN,-(sp)
      68                                ;		...
      69                                ;		mov	arg2,-(sp)
      70                                ;		mov	arg1,-(sp)
      71                                ;		mov	format,-(sp)
      72                                ;		call	printf
      73                                ;		add	#2*N,sp
      74                                ;
      75 004766 010046                  printf::mov	r0,-(sp)		; save reg
      76 004770 010146                  	mov	r1,-(sp)		;
      77 004772 010246                  	mov	r2,-(sp)		;
      78 004774 010346                  	mov	r3,-(sp)		;
      79 004776 010446                  	mov	r4,-(sp)		;
      80 005000 010546                  	mov	r5,-(sp)		;
      81                                	
      82 005002 010605                  	mov	sp,r5			; frame pointer
      83 005004 162706  000014          	sub	#n.last,sp		; reserve space on stack
      84                                	
      85 005010 010504                  	mov	r5,r4			; get frame ptr
      86 005012 062704  000016          	add	#n.args,r4		; offset to first argument
      87                                	
      88 005016 012765  005032  177766  	mov	#1$,p.out(r5)		; character output routine
      89 005024 005065  177764          	clr	p.ptr(r5)		; bufptr not used here
      90                                	
      91 005030 000442                  	br	xprintf			; continue
      92                                
      93                                	; ---------------------------------------------------------
      94                                	
      95                                	; character output to console
      96                                	
      97 005032 105737  177564          1$:	tstb	@#ttxcsr		; check if ready
      98 005036 100375                  	bpl	1$			; not yet
      99 005040 110037  177566          	movb	r0,@#ttxbuf		; send character
     100 005044                         	return				; return
       1 005044 000207                  	rts	pc
     101                                	
     102                                ; --------------------------------------------------------------------------------
     103                                ;
     104                                ; sprintf routine .. 'C' sprintf(buffer,format,arg1,arg2,..,argn) ..  called in 'C' style
     105                                ;
     106                                ;	call:	mov	argN,-(sp)
     107                                ;		...
     108                                ;		mov	arg2,-(sp)
     109                                ;		mov	arg1,-(sp)
     110                                ;		mov	format,-(sp)
     111                                ;		mov	buffer,-(sp)
     112                                ;		call	sprintf
     113                                ;		add	#2*N,sp
     114                                ;
     115 005046 010046                  sprintf::mov	r0,-(sp)		; save reg
     116 005050 010146                  	mov	r1,-(sp)		;
     117 005052 010246                  	mov	r2,-(sp)		;
     118 005054 010346                  	mov	r3,-(sp)		;
     119 005056 010446                  	mov	r4,-(sp)		;
     120 005060 010546                  	mov	r5,-(sp)		;
     121                                	
     122 005062 010605                  	mov	sp,r5			; frame pointer
     123 005064 162706  000014          	sub	#n.last,sp		; reserve space on stack
     124                                	
     125 005070 010504                  	mov	r5,r4			; get frame ptr
     126 005072 062704  000016          	add	#n.args,r4		; offset to first argument
     127                                	
     128 005076 012765  005112  177766  	mov	#1$,p.out(r5)		; character output routine
     129 005104 012465  177764          	mov	(r4)+,p.ptr(r5)		; init bufptr from argument
     130                                	
     131 005110 000412                  	br	xprintf			; continue
     132                                
     133                                	; ---------------------------------------------------------
     134                                	
     135                                	; character output to buffer
     136                                	
     137 005112 110075  177764          1$:	movb	r0,@p.ptr(r5)		; store character
     138 005116 005265  177764          	inc	p.ptr(r5)		; bump pointer
     139 005122 105075  177764          	clrb	@p.ptr(r5)		; null terminate
     140 005126 016565  177764  000012  	mov	p.ptr(r5),p.sr0(r5)	; return updated ptr in saved r0
     141 005134                         	return				; return
       1 005134 000207                  	rts	pc
     142                                	
     143                                ; --------------------------------------------------------------------------------
     144                                
     145                                	; process main format
     146                                
     147 005136 012403                  xprintf:mov	(r4)+,r3		; prime format string pointer
     148                                
     149 005140                         1$:	call	900$			; get next format character
       1 005140 004737  006050          	jsr	pc,900$
     150 005144 120227  000045          	cmpb	r2,#<'%>		; hit a format flag?
     151 005150 001430                  	beq	10$			; yes, go process
     152 005152 120227  000134          	cmpb	r2,#<'\>		; hit an escape flag?
     153 005156 001404                  	beq	3$			; yes, go process
     154 005160 010200                  2$:	mov	r2,r0			; char to print
     155 005162                         	call	@p.out(r5)		; no, just print it
       1 005162 004775  177766          	jsr	pc,@p.out(r5)
     156 005166 000764                  	br	1$			; loop
     157                                
     158                                	; process escaped character \a .. \z
     159                                
     160 005170                         3$:	call	900$			; get the escaped character
       1 005170 004737  006050          	jsr	pc,900$
     161 005174 002771                  	blt	2$			; quick exit for [NUL-@] range
     162 005176 120227  000172          	cmpb	r2,#<'z>		;
     163 005202 003366                  	bgt	2$			; exit if [{-DEL]
     164 005204 120227  000141          	cmpb	r2,#<'a>		;
     165 005210 002005                  	bge	4$			; br if [a-z]	
     166 005212 120227  000132          	cmpb	r2,#<'Z>		;
     167 005216 003360                  	bgt	2$			; br if [[-`]
     168 005220 152702  000040          	bisb	#40,r2			; force to [a-z] range
     169 005224 116202  005745          4$:	movb	1000$-<'a>(r2),r2	; translate a..z to escaped
     170 005230 000753                  	br	2$			; go print
     171                                
     172                                	; process format flag %[-+]?(0?\d+([.]\d+)?)?[lh]?[iduscpxo]
     173                                
     174 005232 112765  000040  177776  10$:	movb	#<' >,p.fil(r5)		; blank fill
     175 005240 105065  177777          	clrb	p.flg(r5)		; clear flags
     176 005244 005065  177774          	clr	p.wid(r5)		; init width spec
     177 005250 005065  177772          	clr	p.pre(r5)		; init precision spec
     178 005254 005065  177770          	clr	p.len(r5)		; no digits yet
     179                                
     180 005260                         11$:	call	900$			; get next format character
       1 005260 004737  006050          	jsr	pc,900$
     181 005264 002045                  	bge	40$			; br if [A-DEL]
     182 005266 120227  000045          	cmpb	r2,#<'%>		; check for '%'
     183 005272 001732                  	beq	2$			; br if yes
     184                                
     185                                	; some character in range [NUL-@]
     186                                
     187 005274 120227  000055          	cmpb	r2,#<'->		; check for '-'
     188 005300 001004                  	bne	12$			; br if not
     189 005302 152765  000001  177777  	bisb	#pf.ljus,p.flg(r5)	; yes, set a flag
     190 005310 000763                  	br	11$			; loop
     191 005312 120227  000053          12$:	cmpb	r2,#<'+>		; check for '+'
     192 005316 001004                  	bne	13$			; br if not
     193 005320 152765  000002  177777  	bisb	#pf.sign,p.flg(r5)	; yes, set a flag
     194 005326 000754                  	br	11$			; loop
     195 005330 120227  000043          13$:	cmpb	r2,#<'#>		; check for '#'
     196 005334 001004                  	bne	20$			; br if not
     197 005336 152765  000004  177777  	bisb	#pf.altr,p.flg(r5)	; yes, set a flag
     198 005344 000745                  	br	11$			; loop
     199                                
     200 005346                         20$:	call	800$			; get a number if present
       1 005346 004737  005754          	jsr	pc,800$
     201 005352 010165  177774          	mov	r1,p.wid(r5)		; save number as width
     202                                
     203 005356 120227  000056          	cmpb	r2,#<'.>		; check for .
     204 005362 001006                  	bne	40$			; br if not, should be alpha
     205 005364                         	call	900$			; get next character
       1 005364 004737  006050          	jsr	pc,900$
     206                                
     207 005370                         	call	800$			; get a number if present
       1 005370 004737  005754          	jsr	pc,800$
     208 005374 010165  177772          	mov	r1,p.pre(r5)		; save number as precision
     209                                
     210                                	; flag is in range [A-Za-z]
     211                                
     212 005400 005000                  40$:	clr	r0			; zap numerics
     213 005402 005001                  	clr	r1			;
     214 005404 120227  000101          41$:	cmpb	r2,#<'A>		; check for [:-@]
     215 005410 002663                  	blt	2$			; br if yes
     216 005412 120227  000172          	cmpb	r2,#<'z>		; check for [{-DEL]
     217 005416 003260                  	bgt	2$			; br if yes
     218 005420 120227  000141          	cmpb	r2,#<'a>		; check for [a-z]
     219 005424 002003                  	bge	42$			; br if yes
     220 005426 120227  000132          	cmpb	r2,#<'Z>		; check for [A-Z]
     221 005432 003252                  	bgt	2$			; br if no
     222 005434 042702  000040          42$:	bic	#40,r2			; force to [a-z] to [A-Z] range
     223 005440 012401                  	mov	(r4)+,r1		; get the next value as lsb
     224 005442 006302                  	asl	r2			; char*2 for word offset
     225 005444 000172  005246          	jmp	@400$-<2*'A>(r2)	; dispatch
     226                                
     227                                400$:	;----	aaaa,bbbb,cccc,dddd,eeee,ffff,gggg,hhhh,iiii,jjjj,kkkk,llll,mmmm
     228 005450 005534  005740  005600  	.word	401$,470$,420$,430$,401$,401$,401$,401$,430$,401$,401$,405$,401$
         005456 005620  005534  005534  
         005464 005534  005534  005620  
         005472 005534  005534  005550  
         005500 005534                  
     229                                	;----	nnnn,oooo,pppp,qqqq,rrrr,ssss,tttt,uuuu,vvvv,wwww,xxxx,yyyy,zzzz
     230 005502 005534  005710  005710  	.word	401$,450$,450$,401$,401$,410$,401$,440$,401$,401$,460$,401$,401$
         005510 005534  005534  005566  
         005516 005534  005674  005534  
         005524 005534  005724  005534  
         005532 005534                  
     231                                
     232 005534 005744                  401$:	tst	-(r4)			; %<illegal>: backup argument pointer
     233 005536 005002                  	clr	r2			; zap
     234 005540 156302  177777          	bisb	-1(r3),r2		; retrieve last character
     235 005544 000137  005160          	jmp	2$			; just go print
     236                                
     237 005550                         405$:	call	900$			; %l: get next character
       1 005550 004737  006050          	jsr	pc,900$
     238 005554 152765  000010  177777  	bisb	#pf.long,p.flg(r5)	; indicate longword value
     239 005562 010100                  	mov	r1,r0			; copy 1st arg to msb
     240 005564 000707                  	br	41$			; and go parse next flag
     241                                
     242 005566 010102                  410$:	mov	r1,r2			; %s: get next arg as string address
     243 005570                         	call	prtstr			; print as a string
       1 005570 004737  006510          	jsr	pc,prtstr
     244 005574 000137  005140          	jmp	1$			; continue at the top
     245                                
     246 005600 005046                  420$:	clr	-(sp)			; %c: zap upper byte
     247 005602 110116                  	movb	r1,(sp)			; insert the character
     248 005604 010602                  	mov	sp,r2			; point at string
     249 005606                         	call	prtstr			; print as a string
       1 005606 004737  006510          	jsr	pc,prtstr
     250 005612 005726                  	tst	(sp)+			; flush temp string
     251 005614 000137  005140          	jmp	1$			; continue at the top
     252                                
     253 005620 012702  000012          430$:	mov	#10.,r2			; %d,%i: decimal radix
     254 005624 132765  000010  177777  	bitb	#pf.long,p.flg(r5)	; longword value?
     255 005632 001004                  	bne	431$			; br if yes
     256 005634 005000                  	clr	r0			; zap
     257 005636 005701                  	tst	r1			; no; test lsb sign
     258 005640 100001                  	bpl	431$			; br if plus/zero
     259 005642 005100                  	com	r0			; extend -1 to msb
     260 005644 005700                  431$:	tst	r0			; test msb sign
     261 005646 002006                  	bge	439$			; br if zero or positive
     262 005650 005400                  	neg	r0			; negative; make positive
     263 005652 005401                  	neg	r1			;
     264 005654 005600                  	sbc	r0			;
     265 005656 152765  000020  177777  	bisb	#pf.nega,p.flg(r5)	; set flag indicating negative
     266 005664                         439$:	call	prt32u			; print as unsigned decimal w/sign
       1 005664 004737  006140          	jsr	pc,prt32u
     267 005670 000137  005140          	jmp	1$			; continue at the top
     268                                
     269 005674 012702  000012          440$:	mov	#10.,r2			; %u: decimal radix
     270 005700                         	call	prt32u			; print as an unsigned decimal
       1 005700 004737  006140          	jsr	pc,prt32u
     271 005704 000137  005140          	jmp	1$			; continue at the top
     272                                
     273 005710 012702  000010          450$:	mov	#8.,r2			; %o,%p: octal radix
     274 005714                         	call	prt32u			; print as an unsigned hex
       1 005714 004737  006140          	jsr	pc,prt32u
     275 005720 000137  005140          	jmp	1$			; continue at the top
     276                                
     277 005724 012702  000020          460$:	mov	#16.,r2			; %x: hexadecimal radix
     278 005730                         	call	prt32u			; print as an unsigned hex
       1 005730 004737  006140          	jsr	pc,prt32u
     279 005734 000137  005140          	jmp	1$			; continue at the top
     280                                
     281 005740 012702  000002          470$:	mov	#2.,r2			; %b: binary radix
     282 005744                         	call	prt32u			; print as an unsigned binary
       1 005744 004737  006140          	jsr	pc,prt32u
     283 005750 000137  005140          	jmp	1$			; continue at the top
     284                                
     285                                	; ---------------------------------------------------------
     286                                	; get a number as '[0-9]+' or '*'
     287                                
     288 005754 120227  000052          800$:	cmpb	r2,#<'*>		; check for '*' indirection
     289 005760 001427                  	beq	880$			; br if yes
     290 005762 120227  000060          	cmpb	r2,#<'0>		; check for leading '0' character
     291 005766 001002                  	bne	810$			; br if not
     292 005770 110265  177776          	movb	r2,p.fil(r5)		; yes, set a flag
     293 005774 005001                  810$:	clr	r1			; number accumulated here
     294 005776 120227  000060          820$:	cmpb	r2,#<'0>		; check for '0'
     295 006002 002421                  	blt	890$			; br if less that a '0'
     296 006004 120227  000071          	cmpb	r2,#<'9>		; check for '9'
     297 006010 003016                  	bgt	890$			; br if greater than '9'
     298 006012 162702  000060          	sub	#<'0>,r2		; offset to range 0..9
     299 006016 006301                  	asl	r1			; number *= 2.
     300 006020 010100                  	mov	r1,r0			; (number*2.)
     301 006022 006300                  	asl	r0			; (number*4.)
     302 006024 006300                  	asl	r0			; (number*8.)
     303 006026 060001                  	add	r0,r1			; number = number*8. + number*2.
     304 006030 060201                  	add	r2,r1			; add in this digit
     305 006032                         	call	900$			; get next format character
       1 006032 004737  006050          	jsr	pc,900$
     306 006036 000757                  	br	820$			; and loop
     307 006040 012401                  880$:	mov	(r4)+,r1		; get next arg as number
     308 006042                         	call	900$			; get next character
       1 006042 004737  006050          	jsr	pc,900$
     309 006046                         890$:	return				; return
       1 006046 000207                  	rts	pc
     310                                
     311                                	; ---------------------------------------------------------
     312                                	; get next character (or exit) routine; result in r2
     313                                
     314 006050 112302                  900$:	movb	(r3)+,r2		; get next format character
     315 006052 042702  177600          	bic	#^c177,r2		; 7bit ascii only
     316 006056 001403                  	beq	990$			; end of string seen
     317 006060 120227  000101          	cmpb	r2,#<'A>		; check for [A-DEL]
     318 006064                         	return				; leave CC set with result
       1 006064 000207                  	rts	pc
     319                                
     320 006066 010506                  990$:	mov	r5,sp			; flush frame
     321 006070 012605                  	mov	(sp)+,r5		; restore reg
     322 006072 012604                  	mov	(sp)+,r4		;
     323 006074 012603                  	mov	(sp)+,r3		;
     324 006076 012602                  	mov	(sp)+,r2		;
     325 006100 012601                  	mov	(sp)+,r1		;
     326 006102 012600                  	mov	(sp)+,r0		;
     327 006104                         	return				; return
       1 006104 000207                  	rts	pc
     328                                
     329                                	; ---------------------------------------------------------
     330                                	; escaped character table
     331                                1000$:	;	aaa bbb ccc ddd eee fff ggg hhh iii jjj kkk lll mmm
     332                                	;	BEL  BS         ESC  FF
     333 006106    007     010     143  	.byte	007,010,143,144,033,014,147,150,151,152,153,154,155
         006111    144     033     014  
         006114    147     150     151  
         006117    152     153     154  
         006122    155                  
     334                                	;	nnn ooo ppp qqq rrr sss ttt uuu vvv www xxx yyy zzz
     335                                	;	 LF              CR      HT      VT
     336 006123    012     157     160  	.byte	012,157,160,161,015,163,011,165,013,167,170,172,172
         006126    161     015     163  
         006131    011     165     013  
         006134    167     170     172  
         006137    172                  
     337                                	; ---------------------------------------------------------
     338                                
     339                                ; --------------------------------------------------------------------------------
     340                                ;
     341                                ; digit print routine .. print a 32b value as unsigned digits
     342                                ;
     343                                ;	call:	mov	datahi,r0
     344                                ;		mov	datalo,r1
     345                                ;		mov	#radix,r2 ; 2. or 8. or 10. or 16.
     346                                ;		call	prt32u
     347                                ;
     348                                ;		r0 - data msb      (not saved)
     349                                ;		r1 - data lsb      (not saved)
     350                                ;		r2 - radix         (not saved)
     351                                ;		r3 - ptr to format     (saved)
     352                                ;		r4 - ptr to arglist    (saved) [input not used]
     353                                ;		r5 - ptr to flags      (saved)
     354                                ;
     355 006140 010346                  prt32u:	mov	r3,-(sp)		; save regs we use
     356 006142 010446                  	mov	r4,-(sp)		;
     357                                
     358                                	; render all the digits onto the stack (lsd first, msd last)
     359                                
     360 006144 005046                  	clr	-(sp)			; zero flag
     361 006146 010246                  1$:	mov	r2,-(sp)		; radix lsb
     362 006150 005046                  	clr	-(sp)			;   and msb
     363 006152 010146                  	mov	r1,-(sp)		; number lsb
     364 006154 010046                  	mov	r0,-(sp)		;    and msb
     365 006156                         	call	uldiv			; get quo and rem
       1 006156 004737  006756          	jsr	pc,uldiv
     366 006162 016602  000006          	mov	6.(sp),r2		; restore radix from stack
     367 006166 062706  000010          	add	#8.,sp			; flush args
     368 006172 062703  000060          	add	#<'0>,r3		; make rem lsb a digit
     369 006176 020327  000071          	cmp	r3,#<'9>		; still a valid digit?
     370 006202 003402                  	ble	2$			; br if yes
     371 006204 062703  000007          	add	#<'A>-<':>,r3		; offset to 'A...'Z range
     372 006210 010346                  2$:	mov	r3,-(sp)		; save
     373 006212 005265  177770          	inc	p.len(r5)		; count digits
     374 006216 005701                  	tst	r1			; any lsb left?
     375 006220 001352                  	bne	1$			; br if yes
     376 006222 005700                  	tst	r0			; any msb left?
     377 006224 001350                  	bne	1$			; br if yes
     378                                
     379                                	; check if we generated the minimum number of digits requested
     380                                
     381 006226 026565  177770  177772  10$:	cmp	p.len(r5),p.pre(r5)	; compare length to precision
     382 006234 103005                  	bhis	20$			; br we're OK
     383 006236 012746  000060          	mov	#<'0>,-(sp)		; nope, add another digit
     384 006242 005265  177770          	inc	p.len(r5)		; count digits
     385 006246 000767                  	br	10$			; and loop	
     386                                
     387                                	; check for options (#) flag
     388                                
     389 006250 132765  000004  177777  20$:	bitb	#pf.altf,p.flg(r5)	; check for options flag
     390 006256 001422                  	beq	30$			; br if not set
     391 006260 020227  000020          	cmp	r2,#16.			; radix 16?
     392 006264 001407                  	beq	21$			; br if yes
     393 006266 020227  000010          	cmp	r2,#8.			; radix 8?
     394 006272 001014                  	bne	30$			; br if not
     395 006274 022716  000060          	cmp	#<'0>,(sp)		; first digit already zero?
     396 006300 001411                  	beq	30$			; yes, no need to add
     397 006302 000404                  	br	22$			; no, add a leading zero
     398 006304 012746  000170          21$:	mov	#<'x>,-(sp)		; add a '0x' prefix
     399 006310 005265  177770          	inc	p.len(r5)		; count it
     400 006314 012746  000060          22$:	mov	#<'0>,-(sp)		;
     401 006320 005265  177770          	inc	p.len(r5)		; count it
     402                                
     403                                	; check if we need a sign (+/-/none)
     404                                
     405 006324 132765  000020  177777  30$:	bitb	#pf.nega,p.flg(r5)	; was original value negative?
     406 006332 001403                  	beq	31$			; br if not
     407 006334 012746  000055          	mov	#<'->,-(sp)		; minus sign
     408 006340 000406                  	br	32$			;
     409 006342 132765  000002  177777  31$:	bitb	#pf.sign,p.flg(r5)	; sign always requested?
     410 006350 001404                  	beq	50$			; br if not
     411 006352 012746  000053          	mov	#<'+>,-(sp)		; plus sign
     412 006356 005265  177770          32$:	inc	p.len(r5)		; count all chars generated
     413                                
     414                                	; processing for right justification
     415                                
     416 006362 132765  000001  177777  50$:	bitb	#pf.ljus,p.flg(r5)	; check left-justify flag
     417 006370 001020                  	bne	70$			; br if left justified
     418 006372 116501  177776          	movb	p.fil(r5),r1		; get fill character
     419 006376 026565  177770  177774  51$:	cmp	p.len(r5),p.wid(r5)	; compare length to width
     420 006404 103012                  	bhis	70$			; br if we're OK
     421 006406 011600                  	mov	(sp),r0			; copy last character
     422 006410 010146                  	mov	r1,-(sp)		; add a fill character
     423 006412 020100                  	cmp	r1,r0			; check fill/last char order
     424 006414 101403                  	blos	52$			; br if order OK
     425 006416 010016                  	mov	r0,(sp)			; copy sign/last char
     426 006420 010166  000002          	mov	r1,2(sp)		; insert fill after sign
     427 006424 005265  177770          52$:	inc	p.len(r5)		; count it
     428 006430 000762                  	br	51$			; loop
     429                                
     430                                	; print all digits in order (sign..msd..lsd)
     431                                
     432 006432 005001                  70$:	clr	r1			; count characters output
     433 006434 012600                  71$:	mov	(sp)+,r0		; get a digit
     434 006436 001404                  	beq	80$			; br if no more
     435 006440                         	call	@p.out(r5)		; print it
       1 006440 004775  177766          	jsr	pc,@p.out(r5)
     436 006444 005201                  	inc	r1			; count it
     437 006446 000772                  	br	71$			; loop
     438                                
     439                                	; processing for left justification
     440                                
     441 006450 132765  000001  177777  80$:	bitb	#pf.ljus,p.flg(r5)	; check left-justify flag
     442 006456 001411                  	beq	90$			; br if is right justified
     443 006460 012700  000040          	mov	#<' >,r0		; space fill on right
     444 006464 020165  177774          81$:	cmp	r1,p.wid(r5)		; compare length to width
     445 006470 103004                  	bhis	90$			; br we're OK
     446 006472                         	call	@p.out(r5)		; print it
       1 006472 004775  177766          	jsr	pc,@p.out(r5)
     447 006476 005201                  	inc	r1			; count characters
     448 006500 000771                  	br	81$			; and loop	
     449                                
     450                                	; and done
     451                                
     452 006502 012604                  90$:	mov	(sp)+,r4		; restore regs
     453 006504 012603                  	mov	(sp)+,r3		;
     454 006506                         	return				; return
       1 006506 000207                  	rts	pc
     455                                
     456                                ; --------------------------------------------------------------------------------
     457                                ;
     458                                ; asciz string print routine
     459                                ;
     460                                ;	call:	mov	#strptr,r2
     461                                ;		call	prtstr
     462                                ;
     463                                ;		r0 - temp          (not saved)
     464                                ;		r1 - temp          (not saved)
     465                                ;		r2 - ptr to string (not saved)
     466                                ;		r3 - ptr to format     (saved) [input not used]
     467                                ;		r4 - ptr to arglist    (saved) [input not used]
     468                                ;		r5 - ptr to flags      (saved)
     469                                ;
     470 006510 010346                  prtstr:	mov	r3,-(sp)		; save regs
     471 006512 010446                  	mov	r4,-(sp)		;
     472                                
     473                                	; compute length of string
     474                                
     475 006514 010203                  	mov	r2,r3			; copy ptr to string
     476 006516 105723                  1$:	tstb	(r3)+			; check a byte
     477 006520 001376                  	bne	1$			; br if more string
     478 006522 160203                  	sub	r2,r3			; compute length
     479 006524 005303                  	dec	r3			; minus the trailing null	
     480                                
     481                                	; set precision to length if precision is zero
     482                                
     483 006526 005765  177772          	tst	p.pre(r5)		; check requested precision
     484 006532 001002                  	bne	20$			; br if nonzero
     485 006534 010365  177772          	mov	r3,p.pre(r5)		; else set to string length
     486 006540 020365  177772          20$:	cmp	r3,p.pre(r5)		; compare actual length to precision
     487 006544 101402                  	blos	50$			; br if actual <= precision
     488 006546 016503  177772          	mov	p.pre(r5),r3		; else set actual to precision
     489                                
     490                                	; processing for right justification
     491                                
     492 006552 132765  000001  177777  50$:	bitb	#pf.ljus,p.flg(r5)	; check left-justify flag
     493 006560 001002                  	bne	70$			; br if left justified
     494 006562                         	call	100$			; do fill
       1 006562 004737  006630          	jsr	pc,100$
     495                                
     496                                	; print string 
     497                                
     498 006566 010301                  70$:	mov	r3,r1			; copy length
     499 006570 001406                  	beq	80$			; br if no characters
     500 006572 112200                  71$:	movb	(r2)+,r0		; get a character
     501 006574 001404                  	beq	80$			; br if no characters
     502 006576                         	call	@p.out(r5)		; print it
       1 006576 004775  177766          	jsr	pc,@p.out(r5)
     503 006602 005301                  	dec	r1			; count
     504 006604 001372                  	bne	71$			; loop
     505                                
     506                                	; processing for left justification
     507                                
     508 006606 132765  000001  177777  80$:	bitb	#pf.ljus,p.flg(r5)	; check left-justify flag
     509 006614 001402                  	beq	90$			; br if is right justified
     510 006616                         	call	100$			; do fill
       1 006616 004737  006630          	jsr	pc,100$
     511                                
     512                                	; and done
     513                                
     514 006622 012604                  90$:	mov	(sp)+,r4		; restore
     515 006624 012603                  	mov	(sp)+,r3		;
     516 006626                         	return				; return
       1 006626 000207                  	rts	pc
     517                                
     518                                	; ----------------------------------------------------
     519                                	; generate fill characters
     520                                
     521 006630 016501  177774          100$:	mov	p.wid(r5),r1		; requested width
     522 006634 160301                  	sub	r3,r1			; subtract string width
     523 006636 101406                  	blos	102$			; br if no fill needed
     524 006640 116500  177776          	movb	p.fil(r5),r0		; get fill character
     525 006644                         101$:	call	@p.out(r5)		; print a fill character
       1 006644 004775  177766          	jsr	pc,@p.out(r5)
     526 006650 005301                  	dec	r1			; count
     527 006652 001374                  	bne	101$			; loop
     528 006654                         102$:	return				; done
       1 006654 000207                  	rts	pc
     529                                
     530                                ; --------------------------------------------------------------------------------
     531                                
     532                                .include "mac/muldiv.mac"
       1                                ;=================================================================================
       2                                ; muldiv.mac - 32b mul/div routines for macro11 diagnostics
       3                                ; (C) 2009-2016 Donald North. All rights reserved.
       4                                ;=================================================================================
       5                                
       6                                ; --------------------------------------------------------------------------------
       7                                ;
       8                                ; unsigned 32b * 32b => 32b multiplication
       9                                ; 
      10                                ; from the 2.9BSD stdio C lib, using simple shift/add algorithm
      11                                ; 
      12                                ;	call:	mov	#b.lo,-(sp)
      13                                ;		mov	#b.hi,-(sp)
      14                                ;		mov	#a.lo,-(sp)
      15                                ;		mov	#a.hi,-(sp)
      16                                ;		call	ulmul
      17                                ;		add	#8.,sp
      18                                ;		mov	r1,q.lo
      19                                ;		mov	r0,q.hi
      20                                ;
      21 006656 010246                  ulmul::	mov	r2,-(sp)		; save
      22 006660 010346                  	mov	r3,-(sp)		;
      23 006662 010446                  	mov	r4,-(sp)		;
      24 006664 010546                  	mov	r5,-(sp)		;
      25                                
      26 006666 016605  000020          	mov	8.+8.(sp),r5		; b.lo
      27 006672 016604  000016          	mov	6.+8.(sp),r4		; b.hi
      28 006676 016603  000014          	mov	4.+8.(sp),r3		; a.lo
      29 006702 016602  000012          	mov	2.+8.(sp),r2		; a.hi
      30 006706 005001                  	clr	r1			; q.lo
      31 006710 005000                  	clr	r0			; q.hi
      32                                
      33 006712 000241                  1$:	clc				; shiftin zeroes
      34 006714 006004                  	ror	r4			; shift multiplier right one
      35 006716 006005                  	ror	r5			;
      36 006720 103003                  	bcc	2$			; br if shifted out a zero
      37 006722 060301                  	add	r3,r1			; else add multiplicand to product
      38 006724 005500                  	adc	r0			; propagate C
      39 006726 060200                  	add	r2,r0			;
      40 006730 006303                  2$:	asl	r3			; shift multiplicant left one
      41 006732 006102                  	rol	r2			;
      42 006734 005704                  	tst	r4			; any high multiplier bits left?
      43 006736 001365                  	bne	1$			; br if yes
      44 006740 005705                  	tst	r5			; any low multiplier bits left?
      45 006742 001363                  	bne	1$			; br if yes
      46                                
      47 006744 012605                  	mov	(sp)+,r5		; restore
      48 006746 012604                  	mov	(sp)+,r4		;
      49 006750 012603                  	mov	(sp)+,r3		;
      50 006752 012602                  	mov	(sp)+,r2		;
      51 006754                         	return				; done
       1 006754 000207                  	rts	pc
      52                                
      53                                ; --------------------------------------------------------------------------------
      54                                ;
      55                                ; unsigned 32b / 32b => 32b, 32b division with remainder
      56                                ; 
      57                                ; from Hennessey & Patterson Appendix A
      58                                ;
      59                                ;	call:	mov	#den.lo,-(sp)	; 8.(sp)
      60                                ;		mov	#den.hi,-(sp)	; 6.(sp)
      61                                ;		mov	#num.lo,-(sp)	; 4.(sp)
      62                                ;		mov	#num.hi,-(sp)	; 2.(sp)
      63                                ;		call	uldiv
      64                                ;		add	#8.,sp
      65                                ;		mov	r3,rem.lo
      66                                ;		mov	r2,rem.hi
      67                                ;		mov	r1,quo.lo
      68                                ;		mov	r0,quo.hi
      69                                ;
      70 006756 010446                  uldiv::	mov	r4,-(sp)		; save
      71 006760 010546                  	mov	r5,-(sp)		;
      72                                
      73 006762 016601  000010          	mov	4.+4.(sp),r1		; num.lo
      74 006766 016600  000006          	mov	2.+4.(sp),r0		; num.hi
      75                                
      76 006772 005005                  	clr	r5			; tmp.lo
      77 006774 005004                  	clr	r4			; tmp.hi
      78                                
      79 006776 012746  000037          	mov	#31.,-(sp)		; bit count
      80                                
      81 007002 006301                  1$:	asl	r1			; (tmp,num) <<= 1
      82 007004 006100                  	rol	r0			;
      83 007006 006105                  	rol	r5			;
      84 007010 006104                  	rol	r4			;
      85                                
      86 007012 010503                  	mov	r5,r3			; rem = tmp - den
      87 007014 010402                  	mov	r4,r2			;
      88 007016 166603  000016          	sub	8.+6.(sp),r3		;
      89 007022 005602                  	sbc	r2			;
      90 007024 166602  000014          	sub	6.+6.(sp),r2		;
      91                                
      92 007030 100403                  	bmi	2$			; br if rem < 0
      93                                
      94 007032 005201                  	inc	r1			; quo |= 1
      95 007034 010305                  	mov	r3,r5			; tmp = rem
      96 007036 010204                  	mov	r2,r4			;
      97                                
      98 007040 005316                  2$:	dec	(sp)			; count bits
      99 007042 002357                  	bge	1$			; loop if more
     100 007044 005726                  	tst	(sp)+			; flush counter
     101                                
     102 007046 005702                  	tst	r2			; test for rem < 0
     103 007050 002005                  	bge	3$			; br if not
     104                                
     105 007052 066603  000014          	add	8.+4.(sp),r3		; rem += den correction
     106 007056 005502                  	adc	r2			;
     107 007060 066602  000012          	add	6.+4.(sp),r2		;
     108                                
     109 007064 012605                  3$:	mov	(sp)+,r5		; restore
     110 007066 012604                  	mov	(sp)+,r4		;
     111 007070                         	return				; done
       1 007070 000207                  	rts	pc
     112                                
     113                                ; --------------------------------------------------------------------------------
     114                                ;
     115                                ; signed 32b / 32b => 32b, 32b division with remainder
     116                                ; 
     117                                ;	call:	mov	#den.lo,-(sp)	; 8.(sp)
     118                                ;		mov	#den.hi,-(sp)	; 6.(sp)
     119                                ;		mov	#num.lo,-(sp)	; 4.(sp)
     120                                ;		mov	#num.hi,-(sp)	; 2.(sp)
     121                                ;		call	sldiv
     122                                ;		add	#8.,sp
     123                                ;		mov	r3,rem.lo
     124                                ;		mov	r2,rem.hi
     125                                ;		mov	r1,quo.lo
     126                                ;		mov	r0,quo.hi
     127                                ;
     128 007072 010446                  sldiv::	mov	r4,-(sp)		; save
     129                                
     130 007074 016603  000012          	mov	8.+2.(sp),r3		; den.lo
     131 007100 016602  000010          	mov	6.+2.(sp),r2		; den.hi
     132 007104 016601  000006          	mov	4.+2.(sp),r1		; num.lo
     133 007110 016600  000004          	mov	2.+2.(sp),r0		; num.hi
     134                                
     135 007114 005004                  	clr	r4			; pos
     136                                
     137 007116 005700                  	tst	r0			; num sign
     138 007120 002006                  	bge	10$			; br if pos
     139                                
     140 007122 005104                  	com	r4			; neg
     141                                
     142 007124 005101                  	com	r1			; negate num
     143 007126 005100                  	com	r0			;
     144 007130 062701  000001          	add	#1,r1			;
     145 007134 005500                  	adc	r0			; 
     146                                
     147 007136 005702                  10$:	tst	r2			; den sign
     148 007140 002006                  	bge	20$			; br if pos
     149                                
     150 007142 105104                  	comb	r4			; neg
     151                                
     152 007144 005103                  	com	r3			; negate den
     153 007146 005102                  	com	r2			;
     154 007150 062703  000001          	add	#1,r3			;
     155 007154 005502                  	adc	r2			; 
     156                                	
     157 007156 010346                  20$:	mov	r3,-(sp)		; den.lo
     158 007160 010246                  	mov	r2,-(sp)		; den.hi
     159 007162 010146                  	mov	r1,-(sp)		; num.lo
     160 007164 010046                  	mov	r0,-(sp)		; num.hi
     161 007166                         	call	uldiv			;
       1 007166 004737  006756          	jsr	pc,uldiv
     162 007172 062706  000010          	add	#8.,sp			; 
     163                                
     164 007176 005704                  	tst	r4			; invert result
     165 007200 002005                  	bge	30$			;
     166                                
     167 007202 005103                   	com	r3			; negate rem
     168 007204 005102                  	com	r2			;
     169 007206 062703  000001          	add	#1,r3			;
     170 007212 005502                  	adc	r2			; 
     171                                
     172 007214 105704                  30$:	tstb	r4			; invert result
     173 007216 002005                  	bge	40$			;
     174                                
     175 007220 005101                  	com	r1			; negate quo
     176 007222 005100                  	com	r0			;
     177 007224 062701  000001          	add	#1,r1			;
     178 007230 005500                  	adc	r0			; 
     179                                
     180 007232 012604                  40$:	mov	(sp)+,r4		; restore
     181 007234                         	return				; done
       1 007234 000207                  	rts	pc
     182                                
     183                                ;================================================================================
     184                                ; end of muldiv.mac
     185                                ;================================================================================
     185                                
     533                                
     534                                ; --------------------------------------------------------------------------------
     535                                
     536        000000                  .iif ne,pf.sep,	.end
     537                                
     538                                ;=================================================================================
     539                                ; end of printf.mac
     540                                ;=================================================================================
     540                                
     316                                
     317                                ; --------------------------------------------------------------------------------
     318                                
     319                                .end
     319                                


Symbol table

$$NUM  = 000002           3$10   = 007064   L       70$8   = 006566   L       BIT1   = 000002           P.SR1  = 000010           
$$POS  = 000200           3$6    = 005170   L       71$7   = 006434   L       BIT10  = 002000           P.SR2  = 000006           
$ENDAD = 004526           30$11  = 007214   L       71$8   = 006572   L       BIT11  = 004000           P.SR3  = 000004           
$SAV42 = 002002           30$7   = 006324   L       710$1  = 003526   L       BIT12  = 010000           P.SR4  = 000002           
.      = 007236           31$7   = 006342   L       711$1  = 004200   L       BIT13  = 020000           P.SR5  = 000000           
1$10   = 007002   L       32$7   = 006356   L       712$1  = 004240   L       BIT14  = 040000           P.WID  = 177774           
1$4    = 005032   L       32768$0= 002220   L       713$1  = 004277   L       BIT15  = 100000           PASSES = 002004           
1$5    = 005112   L       32768$1= 003112   L       714$1  = 004340   L       BIT2   = 000004           PF.ALT = 000004           
1$6    = 005140   L       32769$0= 002226   L       730$1  = 004351   L       BIT3   = 000010           PF.LJU = 000001           
1$7    = 006146   L       32770$0= 002244   L       731$1  = 004352   L       BIT4   = 000020           PF.LON = 000010           
1$8    = 006516   L       32771$0= 002256   L       732$1  = 004404   L       BIT5   = 000040           PF.NEG = 000020           
1$9    = 006712   L       4$6    = 005224   L       740$1  = 004442   L       BIT6   = 000100           PF.SEP = 000000           
10$11  = 007136   L       40$11  = 007232   L       741$1  = 004447   L       BIT7   = 000200           PF.SIG = 000002           
10$2   = 004544   L       40$3   = 004612   L       750$1  = 004454   L       BIT8   = 000400           PRINTF = 004766 G         
10$6   = 005232   L       40$6   = 005400   L       751$1  = 004474   L       BIT9   = 001000           PRT32U = 006140           
10$7   = 006226   L       400$6  = 005450   L       80$3   = 004666   L       CONSOL = 165144 G         PRTALL = 000001           
100$1  = 002320   L       401$6  = 005534   L       80$7   = 006450   L       CR     = 000015           PRTSTR = 006510           
100$8  = 006630   L       405$6  = 005550   L       80$8   = 006606   L       DIVIDE = 004564           PSW    = 177776 G         
1000$6 = 006106   L       41$6   = 005404   L       800$6  = 005754   L       DONE   = 004502           RCVCC  = 002036           
101$8  = 006644   L       410$6  = 005566   L       81$7   = 006464   L       DPYREG = 177570 G         RCVR0  = 002030           
102$8  = 006654   L       42$6   = 005434   L       810$6  = 005774   L       ERRFLG = 002010           RCVR1  = 002032           
11$6   = 005260   L       420$6  = 005600   L       820$6  = 005776   L       EXPCC  = 002026           RCVR2  = 002034           
12$6   = 005312   L       430$6  = 005620   L       880$6  = 006040   L       EXPR0  = 002020           SLDIV  = 007072 G         
13$6   = 005330   L       431$6  = 005644   L       890$6  = 006046   L       EXPR1  = 002022           SPRINT = 005046 G         
140$1  = 002556   L       439$6  = 005664   L       90$3   = 004710   L       EXPR2  = 002024           SRCR0  = 002012           
150$1  = 002566   L       440$6  = 005674   L       90$7   = 006502   L       LF     = 000012           SRCR1  = 002014           
155$1  = 002600   L       450$6  = 005710   L       90$8   = 006622   L       LOOP   = 002300           SRCR2  = 002016           
180$1  = 002770   L       460$6  = 005724   L       900$6  = 006050   L       MSG1   = 002040           STACK  = 002000           
190$1  = 003042   L       470$6  = 005740   L       990$6  = 006066   L       MSG2   = 002103           START  = 002200           
2$10   = 007040   L       50$3   = 004642   L       BIT0   = 000001           MSGPTR = 002006           SWIREG = 177570 G         
2$6    = 005160   L       50$7   = 006362   L       BIT00  = 000001           N.ARGS = 000016           TST$NO = 000001           
2$7    = 006210   L       50$8   = 006552   L       BIT01  = 000002           N.LAST = 000014           TTRBUF = 177562 G         
2$9    = 006730   L       500$1  = 003116   L       BIT02  = 000004           NOXXDP = 004542           TTRCSR = 177560 G         
20$11  = 007156   L       500$3  = 004722   L       BIT03  = 000010           P.FIL  = 177776           TTXBUF = 177566 G         
20$6   = 005346   L       501$1  = 003526   L       BIT04  = 000020           P.FLG  = 177777           TTXCSR = 177564 G         
20$7   = 006250   L       51$7   = 006376   L       BIT05  = 000040           P.LEN  = 177770           ULDIV  = 006756 G         
20$8   = 006540   L       52$7   = 006424   L       BIT06  = 000100           P.OUT  = 177766           ULMUL  = 006656 G         
200$1  = 003076   L       60$3   = 004652   L       BIT07  = 000200           P.PRE  = 177772           XPRINT = 005136           
21$7   = 006304   L       70$3   = 004660   L       BIT08  = 000400           P.PTR  = 177764           
22$7   = 006314   L       70$7   = 006432   L       BIT09  = 001000           P.SR0  = 000012           


Program sections:

. ABS.  007236    000   (RW,I,GBL,ABS,OVR,NOSAV)
        000000    001   (RW,I,LCL,REL,CON,NOSAV)
