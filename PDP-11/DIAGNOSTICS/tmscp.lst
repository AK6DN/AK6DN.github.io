       1                                .title	TMSCP Controller Diagnostic Test
       2                                
       3                                ; (C) 2012 Donald North. All rights reserved.
       4                                
       5                                .include "mac/stddef.mac"
       1                                ;================================================================================
       2                                ; stddef.mac - standard definitions
       3                                ; (C) 2009 Donald North. All rights reserved.
       4                                ;================================================================================
       5                                .macro	align	arg1
      16                                ;================================================================================
      17                                .macro	savreg	arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8
      28                                ;================================================================================
      29                                .macro	resreg	arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8
      40                                ;================================================================================
      41                                .macro	call	proc
      44                                .macro	return
      47                                .macro	calls	proc arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8 arg9 arg10 arg11 arg12 arg13 arg14 arg15 arg16
      67                                ;================================================================================
      68                                .macro	jeq	label ?a1
      73                                .macro	jne	label ?a1
      78                                .macro	jpl	label ?a1
      83                                .macro	jmi	label ?a1
      88                                .macro	jlo	label ?a1
      93                                .macro	jhis	label ?a1
      98                                .macro	jlos	label ?a1
     103                                .macro	jhi	label ?a1
     108                                .macro	jlt	label ?a1
     113                                .macro	jge	label ?a1
     118                                .macro	jle	label ?a1
     123                                .macro	jgt	label ?a1
     128                                .macro	jcc	label ?a1
     133                                .macro	jcs	label ?a1
     138                                .macro	jvc	label ?a1
     143                                .macro	jvs	label ?a1
     148                                ;================================================================================
     149                                .macro	printf	arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8 arg9 arg10 arg11 arg12 arg13 arg14 arg15 arg16
     152                                .macro	sprintf	arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8 arg9 arg10 arg11 arg12 arg13 arg14 arg15 arg16
     155                                ;================================================================================
     156                                .macro	ipl	lvl
     161                                ;================================================================================
     162                                .macro	trapcatcher	list ?a1 ?a2 ?a3 ?a4
     176                                ;================================================================================
     177        000001                  tst$no	= 1
     178                                .macro	test	title
     198                                ;================================================================================
     199                                ; end of stddef.mac
     200                                ;================================================================================
     200                                
       6                                
       7                                ; --------------------------------------------------------------------------------
       8                                
       9                                .sbttl	general definitions
      10                                
      11        000001                  UC17	=1			; 1 for UC17/UC18, 0 for TK50
      12                                
      13                                .include "mac/bits.mac"
       1                                ;================================================================================
       2                                ; bits.mac - standard bit definitions
       3                                ;================================================================================
       4                                
       5                                ;  system global fixed addresses
       6                                
       7        177776                  psw	==177776		; processor status word
       8                                
       9        165144                  console	==165144		; console routine start
      10                                
      11        177570                  swireg	==177570		; console switch register
      12        177570                  dpyreg	==swireg		; console display register
      13                                
      14        177560                  ttrcsr	==177560		; console serial device
      15        177562                  ttrbuf	==ttrcsr+2		;
      16        177564                  ttxcsr	==ttrcsr+4		;
      17        177566                  ttxbuf	==ttrcsr+6		;
      18                                
      19                                ; common values
      20                                
      21        000015                  cr	=015			; ascii CR
      22        000012                  lf	=012			; ascii LF
      23                                
      24        000001                  bit00	=000001			; bit positions
      25        000002                  bit01	=000002			;
      26        000004                  bit02	=000004			;
      27        000010                  bit03	=000010			;
      28        000020                  bit04	=000020			;
      29        000040                  bit05	=000040			;
      30        000100                  bit06	=000100			;
      31        000200                  bit07	=000200			;
      32        000400                  bit08	=000400			;
      33        001000                  bit09	=001000			;
      34        002000                  bit10	=002000			;
      35        004000                  bit11	=004000			;
      36        010000                  bit12	=010000			;
      37        020000                  bit13	=020000			;
      38        040000                  bit14	=040000			;
      39        100000                  bit15	=100000			;
      40                                	
      41        000001                  bit0	=bit00			; also
      42        000002                  bit1	=bit01			;
      43        000004                  bit2	=bit02			;
      44        000010                  bit3	=bit03			;
      45        000020                  bit4	=bit04			;
      46        000040                  bit5	=bit05			;
      47        000100                  bit6	=bit06			;
      48        000200                  bit7	=bit07			;
      49        000400                  bit8	=bit08			;
      50        001000                  bit9	=bit09			;
      51                                
      52                                ;================================================================================
      53                                ; end of bits.mac
      54                                ;================================================================================
      54                                
      14                                
      15                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      16                                
      17                                .sbttl	local definitions
      18                                
      19                                ; LCLK registers
      20                                
      21        177546                  lk$csr	=177546			; line clock csr
      22        000200                  lk_mon	=000200			; monitor but
      23        000100                  lk_ien	=000100			; intr enb bit
      24        000100                  lk$vec	=100			; vector
      25        000006                  lk_pri	=6			; priority
      26                                
      27                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      28                                
      29                                .sbttl	MSCP definitions
      30                                
      31                                .include "mscp/define.mac"
       1                                ; --------------------------------------------------------------------------------
       2                                ; define.mac - mscp/tmscp register definitions
       3                                ; (C) 2010 Donald North. All rights reserved.
       4                                ; --------------------------------------------------------------------------------
       5                                
       6                                ; MSCP controller registers
       7                                
       8                                ; SA register universal bits
       9                                
      10        003777                  sa_erc	=003777			; error code
      11        004000                  sa_st1	=004000			; step 1 state
      12        010000                  sa_st2	=010000			; step 2 state
      13        020000                  sa_st3	=020000			; step 3 state
      14        040000                  sa_st4	=040000			; step 4 state
      15        100000                  sa_err	=100000			; error indicator
      16                                
      17                                ; SA register S1 response bits
      18                                
      19        000001                  sa_rs0	=000001			; reserved lsb
      20        000377                  sa_rsv	=000377			; reserved
      21        000400                  sa_edp	=000400			; enhanced diagnostics present
      22        001000                  sa_a22	=001000			; 22b addressing present
      23        002000                  sa_nsv	=002000			; non-settable intr vector
      24                                
      25                                ; SA register S1 send bits
      26                                
      27        000177                  sa_vec	=000177			; intr vector (div by 4)
      28        000200                  sa_int	=000200			; intr enable during init
      29        000400                  sa_rl0	=000400			; response ring length lsb
      30        003400                  sa_rll	=003400			; response ring length
      31        004000                  sa_cl0	=004000			; command ring length lsb
      32        034000                  sa_cll	=034000			; command ring length
      33        040000                  sa_wrp	=040000			; wrap bit
      34        100000                  sa_stp	=100000			; step bit
      35                                
      36                                ; SA register S2 response bits
      37                                
      38        000007                  sa_rle	=000007			; response ring length echo
      39        000070                  sa_cle	=000070			; command ring length echo
      40        000200                  sa_ste	=000200			; step echo
      41        003400                  sa_cty	=003400			; controller type
      42                                
      43                                ; SA register S2 send bits
      44                                
      45        000001                  sa_prg	=000001			; enable UBA purge interrupt
      46        177776                  sa_rgl	=177776			; ring(lo) address
      47                                
      48                                ; SA register S3 response bits
      49                                
      50        000177                  sa_vee	=000177			; intr vector (div4) echo
      51        000200                  sa_ine	=000200			; intr enable echo
      52        000400                  sa_vpe	=000400			; vector-programmable echo
      53                                
      54                                ; SA register S3 send bits
      55                                
      56        077777                  sa_rgh	=077777			; ring(hi) address
      57        100000                  sa_ppt	=100000			; purge poll test enable
      58                                
      59                                ; SA register S4 response bits
      60                                
      61        000001                  sa_mc0	=000001			; microcode rev level lsb
      62        000017                  sa_mcv	=000017			; microcode rev level
      63        000020                  sa_cn0	=000020			; controller type lsb
      64        000360                  sa_cnt	=000360			; controller type
      65                                
      66                                ; SA register S4 send bits
      67                                
      68        000001                  sa_go	=000001			; controller GO bit
      69        000002                  sa_lfc	=000002			; last failure code request
      70        000374                  sa_bst	=000374			; burst level
      71                                
      72                                ; controller types in SA_CNT field
      73                                
      74        000002                  t_ud50	=2.			; UDA50 unibus disk
      75        000005                  t_tu81	=5.			; TU81 tape
      76        000006                  t_ud5a	=6.			; UDA50A unibus disk
      77        000011                  t_tk50	=9.			; TK50/TQK50 tape
      78        000016                  t_tk70	=14.			; TK70/TQK70 tape
      79        000023                  t_rqd3	=19.			; RQDX3 qbus disk
      80                                
      81                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      82                                
      83                                ; *** MSCP protocol definitions ***
      84                                
      85                                ; command/response packet offsets
      86                                
      87                                ; generic:
      88        177774                  p_len	=-4	; [2] command length, bytes
      89        177776                  p_type	=-2	; [1] msg type and credits
      90        177777                  p_cid	=-1	; [1] connection id
      91        000000                  p_crf	=0	; [4] command reference number
      92        000004                  p_unit	=4	; [2] unit number
      93        000010                  p_opcd	=10	; [1] opcode
      94        000012                  p_mod	=12	; [2] modifiers
      95        000014                  p_bcnt	=14	; [4] byte count
      96        000020                  p_buff	=20	; [12] buffer descriptor
      97        000034                  p_lbn	=34	; [4] logical block number
      98                                ; abort, get command status:
      99        000014                  p_otrf	=14	; [4] outstanding reference number
     100                                ; online, set unit characteristics:
     101        000016                  p_unfl	=16	; [2] unit flags
     102        000034                  p_dvpm	=34	; [4] device dependent parameters
     103                                ; replace:
     104        000014                  p_rbn	=14	; [4] replacement block number
     105                                ; set controller characteristics:
     106        000014                  p_vrsn	=14	; [2] MSCP version
     107        000016                  p_cntf	=16	; [2] controller flags
     108        000020                  p_htmo	=20	; [2] host timeout
     109        000024                  p_time	=24	; [8] quadword time/date
     110                                ; generic end message:
     111        000011                  p_flgs	=11	; [1] flags
     112        000012                  p_sts	=12	; [2] status
     113        000034                  p_fbbk	=34	; [4] first bad block
     114                                ; get command status end message:
     115        000020                  p_cmst	=20	; [4] command status
     116                                ; get unit status end message:
     117        000014                  p_mlun	=14	; [2] multi-unit code
     118        000024                  p_unti	=24	; [8] unit ID
     119        000034                  p_medi	=34	; [4] media ID
     120        000040                  p_shun	=40	; [2] shadow unit
     121        000044                  p_trck	=44	; [2] track size
     122        000046                  p_grp	=46	; [2] groups size
     123        000050                  p_cyl	=50	; [2] cylinder size
     124        000054                  p_rcts	=54	; [2] RCT table size
     125        000056                  p_rbns	=56	; [1] RBNs/track
     126        000057                  p_rctc	=57	; [1] RCT copies
     127                                ; online, set unit characteristics end message:
     128        000044                  p_unsz	=44	; [4] unit size
     129        000050                  p_vser	=50	; [4] volume serial number
     130                                ; set controller characteristics end message:
     131        000020                  p_ctmo	=20	; [2] controller timeout
     132        000024                  p_cnti	=24	; [8] controller ID
     133                                ;
     134        000060                  p_csiz	=60	; max command size, bytes
     135        000060                  p_msiz	=60	; max message size, bytes
     136                                
     137                                ; MSCP error log message offsets
     138                                
     139                                ; generic:
     140        000000                  l_crf	=0	; [4] command reference number
     141        000004                  l_unit	=4	; [2] unit number
     142        000006                  l_seq	=6	; [2] sequence number
     143        000010                  l_fmt	=10	; [1] format
     144        000011                  l_flgs	=11	; [1] flags
     145        000012                  l_evnt	=12	; [2] event code
     146        000014                  l_cnti	=14	; [8] controller ID
     147        000024                  l_csvr	=24	; [1] controller s/w version
     148        000025                  l_chvr	=25	; [1] controller h/w version
     149        000026                  l_mlun	=26	; [2] multi-unit code
     150        000030                  l_unti	=30	; [8] unit ID
     151        000040                  l_usvr	=40	; [1] unit s/w version
     152        000041                  l_uhvr	=41	; [1] unit h/w version
     153        000044                  l_vser	=44	' [4] volume serial number
     154                                ; host memory access errors:
     155        000004                  l_badr	=4	; [4] bus address
     156                                ; disk transfer errors:
     157        000042                  l_lvl	=42	; [1] level
     158        000043                  l_rtry	=43	; [1] retry
     159        000050                  l_hdcd	=50	; [4] header code
     160                                ; sdi errors:
     161        000054                  l_sdi	=54	; [12] sdi information
     162                                
     163                                ; MSCP command opcodes
     164                                
     165        000000                  op_nil	=0.	; [b] nop
     166        000001                  op_abo	=1.	; [b] abort
     167        000002                  op_gcs	=2.	; [b] get command status
     168        000003                  op_gus	=3.	; [b] get unit status
     169        000004                  op_scc	=4.	; [b] set controller characteristics
     170        000010                  op_avl	=8.	; [b] available
     171        000011                  op_onl	=9.	; [b] online
     172        000012                  op_suc	=10.	; [b] set unit characteristics
     173        000013                  op_dap	=11.	; [b] determine access paths
     174        000020                  op_acc	=16.	; [b] access
     175        000021                  op_ccd	=17.	; [d] compare
     176        000022                  op_ers	=18.	; [b] erase
     177        000023                  op_flu	=19.	; [d] flush
     178        000024                  op_rpl	=20.	; [?] replace
     179        000026                  op_erg	=22.	; [t] erase gap
     180        000040                  op_cmp	=32.	; [b] compare
     181        000041                  op_rd	=33.	; [b] read
     182        000042                  op_wr	=34.	; [b] write
     183        000044                  op_wtm	=36.	; [t] write tape mark
     184        000045                  op_pos	=37.	; [t] reposition
     185        000057                  op_fmt	=47.	; [d] format
     186        000077                  op_ill	=63.	; [b] illegal
     187        000100                  op_ava	=64.	; [b] available attention message
     188        000101                  op_dup	=65.	; [b] duplicate unit message
     189        000102                  op_acp	=66.	; [b] access path attention message
     190        000103                  op_rwa	=67.	; [t] rewind attention message
     191        000200                  op_end	=128.	; [b] end message flag
     192                                
     193                                ; MSCP command modifiers
     194                                
     195        100000                  md_exp	=100000	; [d] express NI
     196        040000                  md_cmp	=40000	; [b] compare NI
     197        020000                  md_cse	=20000	; [b] clear serious error
     198        010000                  md_err	=10000	; [d] force error NI
     199        010000                  md_cdl	=10000	; [t] clear data lost NI
     200        004000                  md_sch	=4000	; [t] supr cache highspeed NI
     201        002000                  md_scl	=2000	; [t] supr cache lowspeed NI
     202        001000                  md_sec	=1000	; [b] suppress error correction
     203        000400                  md_ser	=400	; [b] suppress error recovery
     204        000200                  md_dle	=200	; [t,pos] detect LEOT
     205        000100                  md_imm	=100	; [t] immediate NI
     206        000040                  md_exa	=40	; [b] excl access NI
     207        000020                  md_shd	=20	; [d] shadow NI
     208        000020                  md_unl	=20	; [t] unload
     209        000010                  md_erw	=10	; [t,wr] enable rewrite
     210        000010                  md_rev	=10	; [t,rd|pos] reverse
     211        000004                  md_swp	=4	; [b,suc] enb set wri prot
     212        000004                  md_obc	=4	; [t,pos] obj count
     213        000002                  md_imf	=2	; [d,onl] ignore fmt err NI
     214        000002                  md_rwd	=2	; [t,pos] rewind
     215        000002                  md_acl	=2	; [t,avl] all class NI
     216        000001                  md_nxu	=1	; [b,gus] next unit
     217        000001                  md_spn	=1	; [d,avl] spin down NI
     218        000001                  md_rip	=1	; [d,onl] allow rip NI
     219                                
     220                                ; MSCP end message flags
     221                                
     222        000200                  ef_bbr	=200	; [d] bad block reported
     223        000100                  ef_bbu	=100	; [d] bsd block unreported
     224        000040                  ef_log	=40	; [b] error log generated
     225        000020                  ef_sxc	=20	; [b] serious exception
     226        000010                  ef_eot	=10	; [t] end of tape
     227        000004                  ef_pls	=4	; [t] position lost
     228        000002                  ef_dls	=2	; [t] cached data lost
     229                                
     230                                ; MSCP controller flags
     231                                
     232        100000                  cf_rpl	=100000	; ctlr bad block repl
     233        000200                  cf_atn	=200	; enable attention messages
     234        000100                  cf_msc	=100	; enable misc error log messages
     235        000040                  cf_oth	=40	; enable other host's error log messages
     236        000020                  cf_ths	=20	; enable this host's error log messages
     237                                
     238                                ; MSCP unit flags
     239                                
     240        100000                  uf_rpl	=100000	; [d] report bad blocks
     241        100000                  uf_cac	=100000	; [t] cache write back
     242        020000                  uf_wph	=20000	; [b] write protect (h/w)
     243        010000                  uf_wps	=10000	; [b] write protect (s/w)
     244        004000                  uf_sch	=4000	; [t] supr cache NI
     245        002000                  uf_exa	=2000	; [b] exclusive NI
     246        001000                  uf_lod	=1000	; [t] tape loader present
     247        000400                  uf_wpd	=400	; [b] wr prot data NI
     248        000200                  uf_rmv	=200	; [d] removable media
     249        000100                  uf_wbn	=100	; [t] write back NI
     250        000040                  uf_vss	=40	; [t] supr var speed NI
     251        000020                  uf_vsu	=20	; [t] var speed unit NI
     252        000010                  uf_ewr	=10	; [t] enh write recovery NI
     253        000004                  uf_cfl	=4	; [t] cache has been flushed
     254        000002                  uf_cmw	=2	; [b] compare writes
     255        000001                  uf_cmr	=1	; [b] compare reads
     256                                
     257                                ; MSCP error log message flags
     258                                
     259        000200                  lf_suc	=200	; [b] operation successful
     260        000100                  lf_con	=100	; [b] operation continuing
     261        000040                  lf_bbr	=40	; [d] bad block repl NI
     262        000020                  lf_rct	=20	; [d] err in block repl NI
     263        000002                  lf_inf	=2	; [d] info
     264        000001                  lf_snr	=1	; [b] sequence number reset
     265                                
     266                                ; MSCP error log message formats
     267                                
     268        000000                  fm_cnt	=0.	; [b] controller errors
     269        000001                  fm_bad	=1.	; [b] host memory access errors
     270        000002                  fm_dsk	=2.	; [d] disk errors
     271        000003                  fm_sdi	=3.	; [d] SDI errors
     272        000004                  fm_sde	=4.	; [d] small disk error
     273        000005                  fm_tap	=5.	; [t] tape error
     274        000006                  fm_sti	=6.	; [t] STI comm error
     275        000007                  fm_std	=7.	; [t] STI drive error
     276        000010                  fm_stf	=8.	; [t] STI formatter error
     277        000011                  fm_rpl	=9.	; [d] bad block repl error
     278        000012                  fm_ldr	=10.	; [t] media loader error
     279        000013                  fm_ibm	=11.	; [t] sense data error log
     280                                
     281                                ; major status return codes
     282                                
     283        000000                  st_suc	=0.	; [b] success
     284        000001                  st_cmd	=1.	; [b] command invalid
     285        000002                  st_abo	=2.	; [b] command aborted
     286        000003                  st_ofl	=3.	; [b] unit offline
     287        000004                  st_avl	=4.	; [b] unit available
     288        000005                  st_mfe	=5.	; [b] media format error
     289        000006                  st_wpr	=6.	; [b] write protected
     290        000007                  st_cmp	=7.	; [b] compare error
     291        000010                  st_dat	=8.	; [b] data error
     292        000011                  st_hst	=9.	; [b] host buffer access error
     293        000012                  st_cnt	=10.	; [b] controller error
     294        000013                  st_drv	=11.	; [b] drive error
     295        000014                  st_fmt	=12.	; [t] formatter error
     296        000015                  st_bot	=13.	; [t] BOT encountered
     297        000016                  st_tmk	=14.	; [t] tape mark
     298        000020                  st_rdt	=16.	; [t] record truncated
     299        000021                  st_pol	=17.	; [t] position lost
     300        000022                  st_sxc	=18.	; [b] serious exception
     301        000023                  st_led	=19.	; [t] LEOT detect
     302        000024                  st_bbr	=20.	; [d] bad block complete
     303        000025                  st_inv	=21.	; [b] invalid parameter
     304        000026                  st_inf	=22.	; [b] information message
     305        000027                  st_ldr	=23.	; [t] media loader error
     306        000037                  st_dia	=31.	; [b] diagnostic message
     307                                	
     308        000037                  st_msk	=37	; [b] status mask
     309        000040                  st_sub	=40	; [b] subcode multiplier
     310                                
     311                                ; MSCP misc values
     312                                
     313        100000                  ds_own	=100000	; OWN bit in comm structure
     314        040000                  ds_int	=040000	; INTR bit in comm structure
     315                                
     316                                ; --------------------------------------------------------------------------------
     317                                ; end of define.mac
     318                                ; --------------------------------------------------------------------------------
     318                                
      32                                
      33        000001                  .if ne UC17
      34                                ; UC17/UC18
      35        000000                  sa_opt	=0			; step1 response reserved bits
      36        000006                  sa_ucv	=6			; step4 code version
      37                                .iff
      38                                ; TK50 (in SIMH)
      39                                sa_opt	=100			; step1 response reserved bits
      40                                sa_ucv	=5			; step4 code version
      41                                .endc
      42        000003                  sa_ctyp	=3			; tape controller type
      43                                
      44        000001                  tstcid	=1			; tape connection id
      45                                
      46                                ; --------------------------------------------------------------------------------
      47                                
      48                                .sbttl	low memory
      49                                
      50                                	.enabl	ama			; change all mode 67 references to 37
      51                                
      52 000000                         	.asect				; absolute load image
      53                                
      54        000046                  	.=46
      55 000046 020306                  	.word	$endad			; address of JSR PC,(R0)
      56        000052                  	.=52
      57 000052 000000                  	.word	0			; run options
      58                                
      59        000200                  	.=200
      60 000200 000137  012400          	jmp	@#start			; standard diagnostic entry
      61                                
      62                                ; --------------------------------------------------------------------------------
      63                                
      64                                .sbttl	global variables
      65                                
      66        002000                  	.=2000
      67 002000 177777                  stack:	.word	-1			; top of stack
      68 002002 000000                  optswi:	.word	000000			; option switches (bit0=verbose_printout)
      69 002004 000002                  numpas:	.word	2.			; number of passes to run
      70 002006 174500                  m$base:	.word	174500			; tape controller csr base
      71 002010 000260                  m$vect:	.word	260			; tape controller std vector
      72 002012 000000                  csr$ip:	.word	0			; tape controller IP register (stored)
      73 002014 000000                  csr$sa:	.word	0			; tape controller SA register (stored)
      74 002016 000000                  errors:	.word	0			; count errors
      75 002020 000000                  passes:	.word	0			; count passes
      76 002022 000000                  $sav42:	.word	0			; XXDP restart address	
      77 002024 000000                  ticklo:	.word	0			; tickcount lo
      78 002026 000000                  tickhi:	.word	0			; tickcount hi
      79 002030 000000                  dlycnt:	.word	0			; delay count
      80 002032 000000                  testno:	.word	0			; current test number
      81                                
      82                                	; MSCP buffers
      83                                
      84                                	.even				; align
      85                                
      86        000010                  bufsiz	=8.				; size in blocks
      87        010000                  buflen	=bufsiz*512.			; size in bytes
      88        002034                  buffer:	.blkb	buflen			; data buffer
      89        012034                  bufend:	.blkb	0			; end
      90                                
      91        012034                  	.blkb	4.			; header
      92        012040                  comm:	.blkb	8.			; comm structure
      93                                
      94        000060                  rlen	=p_msiz				; size in bytes
      95        012050                  	.blkb	4.			; header
      96        012054                  rpkt:	.blkb	rlen			; resp desc structure
      97        012134                  rend:	.blkb	0			; end
      98                                
      99        000060                  clen	=p_csiz				; size in bytes
     100        012134                  	.blkb	4.			; header
     101        012140                  cpkt:	.blkb	clen			; cmd desc structure
     102        012220                  cend:	.blkb	0			; end
     103                                
     104                                	.even				; align
     105                                
     106                                ; --------------------------------------------------------------------------------
     107                                
     108                                .sbttl	program start
     109                                
     110 012220                         	align	7			; pc alignment
     111                                
     112 012400 012706  002000          start:	mov	#stack,sp		; setup a stack
     113 012404 000005                  	reset				; reset the world
     114 012406 013737  000042  002022  	mov	@#42,$sav42		; save XXDP restart
     115                                
     116 012414                         	trapcatcher <2,200,206,400>	; setup a trapcatcher in low vector space
       1 012414 012700  012444          	mov	#32770$,r0    		; ptr to table
       2 012420 012001                  32768$:	mov	(r0)+,r1		; start addr
       3 012422 100415                  	bmi	32771$			; done?
       4 012424 012002                  	mov	(r0)+,r2		; end addr
       5 012426 010161  177776          32769$:	mov	r1,-2(r1)		; point vector at next word
       6 012432 005011                  	clr	(r1)			; <0> which is a halt
       7 012434 022121                  	cmp	(r1)+,(r1)+		; add four to ptr
       8 012436 020102                  	cmp	r1,r2			; reached end?
       9 012440 003772                  	ble	32769$			; not yet
      10 012442 000766                  	br	32768$			; more
      11 012444 000002  000200  000206  32770$:	.word	2,200,206,400, -1
         012452 000400  177777          
      12 012456 000240                  32771$:	nop				; placeholder
     117                                
     118 012460                         	printf	#msg1			; say hello
       1 012460                         	calls	printf #msg1               
       9 012460 012746  020360          	mov	#msg1,-(sp)
       2 012464                         	call	printf
       1 012464 004737  022662          	jsr	pc,printf
       3 012470 062706  000002          	add	#2,sp
     119                                
     120 012474 005037  002016          	clr	errors			; none yet
     121 012500 005037  002020          	clr	passes			; ditto
     122                                
     123                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     124                                
     125                                .sbttl	setup misc devices
     126                                
     127 012504 005037  002024          	clr	ticklo			; clear tick counter
     128 012510 005037  002026          	clr	tickhi			;
     129 012514 012737  020500  000100  	mov	#lkintr,lk$vec+0	; intr routine for line clock
     130 012522 012737  000300  000102  	mov	#lk_pri*bit5,lk$vec+2	; psw for intr service
     131 012530 052737  000100  177546  	bis	#lk_ien,@#lk$csr	; enable line clock interrupts
     132                                
     133                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     134                                
     135                                .sbttl	set psw to zero
     136                                
     137 012536 005046                  	clr	-(sp)			; zap psw
     138 012540 012746  012546          	mov	#loop,-(sp)		; fake pc
     139 012544 000002                  	rti				; reload psw
     140                                
     141                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     142                                
     143 012546 000240                  loop:	nop				; next pass enters here
     144 012550 012737  000001  002032  	mov	#1,testno		; starting test number
     145                                
     146                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     147                                
     148 012556                         	test	<basic controller access>
       2                                
       3                                	;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       4                                	.sbttl	Test1 - basic controller access
       5                                	;------------------------------------------------------------
       6                                
       7                                test1:	; start of test
       8                                
       9 012556 022737  000001  002032  	cmp	#1,testno		; check for sequence error
      10 012564 001401                  	beq	.+4			; OK, skip over halt
      11 012566 000000                  	halt				; FATAL - SEQUENCE ERROR
     149                                
     150 012570                         	printf	#70$,testno		; header message
       1 012570                         	calls	printf #70$ testno              
       9 012570 013746  002032          	mov	testno,-(sp)
      15 012574 012746  012712          	mov	#70$,-(sp)
       2 012600                         	call	printf
       1 012600 004737  022662          	jsr	pc,printf
       3 012604 062706  000004          	add	#4,sp
     151                                
     152 012610 013700  002006          	mov	m$base,r0		; base csr address (IP)
     153 012614 010037  002012          	mov	r0,csr$ip		; save as IP address
     154 012620                         	call	adrchk			; check if responds
       1 012620 004737  022610          	jsr	pc,adrchk
     155 012624 103402                  	bcs	10$			; br if OK
     156 012626                         	call	30$			; error message
       1 012626 004737  012662          	jsr	pc,30$
     157                                
     158 012632 013700  002006          10$:	mov	m$base,r0		; base csr address (IP)
     159 012636 062700  000002          	add	#2,r0			; base csr address (SA)
     160 012642 010037  002014          	mov	r0,csr$sa		; save as SA address
     161 012646                         	call	adrchk			; check if responds
       1 012646 004737  022610          	jsr	pc,adrchk
     162 012652 103402                  	bcs	20$			; br if OK
     163 012654                         	call	30$			; error message
       1 012654 004737  012662          	jsr	pc,30$
     164                                
     165 012660 000463                  20$:	br	99$			; next test
     166                                
     167                                	; - - - - - - - - - - - - - - - - - - - - - - - - -
     168                                
     169 012662                         30$:	printf	#71$,testno,r0		; format, bad address
       1 012662                         	calls	printf #71$ testno r0             
       9 012662 010046                  	mov	r0,-(sp)
      15 012664 013746  002032          	mov	testno,-(sp)
      21 012670 012746  012764          	mov	#71$,-(sp)
       2 012674                         	call	printf
       1 012674 004737  022662          	jsr	pc,printf
       3 012700 062706  000006          	add	#6,sp
     170 012704 005237  002016          	inc	errors			; incre error count
     171 012710                         	return				; return
       1 012710 000207                  	rts	pc
     172                                
     173                                	; - - - - - - - - - - - - - - - - - - - - - - - - -
     174                                
     175 012712    015     012     124  70$:	.asciz	<cr><lf>"Test%d: basic TMSCP controller access"<cr><lf>
         012715    145     163     164  
         012720    045     144     072  
         012723    040     142     141  
         012726    163     151     143  
         012731    040     124     115  
         012734    123     103     120  
         012737    040     143     157  
         012742    156     164     162  
         012745    157     154     154  
         012750    145     162     040  
         012753    141     143     143  
         012756    145     163     163  
         012761    015     012     000  
     176 012764    124     145     163  71$:	.asciz	"Test%d: non-existent address %.6o"<cr><lf>
         012767    164     045     144  
         012772    072     040     156  
         012775    157     156     055  
         013000    145     170     151  
         013003    163     164     145  
         013006    156     164     040  
         013011    141     144     144  
         013014    162     145     163  
         013017    163     040     045  
         013022    056     066     157  
         013025    015     012     000  
     177                                	.even
     178                                
     179 013030 005237  002032          99$:	inc	testno			; to next test
     180                                
     181                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     182                                
     183 013034                         	test	<basic controller initialization sequence>
       2                                
       3                                	;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       4                                	.sbttl	Test2 - basic controller initialization sequence
       5                                	;------------------------------------------------------------
       6                                
       7                                test2:	; start of test
       8                                
       9 013034 022737  000002  002032  	cmp	#2,testno		; check for sequence error
      10 013042 001401                  	beq	.+4			; OK, skip over halt
      11 013044 000000                  	halt				; FATAL - SEQUENCE ERROR
     184                                
     185 013046                         	printf	#70$,testno		; header message
       1 013046                         	calls	printf #70$ testno              
       9 013046 013746  002032          	mov	testno,-(sp)
      15 013052 012746  013430          	mov	#70$,-(sp)
       2 013056                         	call	printf
       1 013056 004737  022662          	jsr	pc,printf
       3 013062 062706  000004          	add	#4,sp
     186                                
     187 013066 012705  013342          	mov	#50$,r5			; data structure
     188                                
     189 013072 013704  002012          	mov	csr$ip,r4		; base csr address (IP)
     190 013076 005024                  	clr	(r4)+			; start init sequence, bump to (SA)
     191                                
     192                                	; ==> wait for SA step N
     193                                
     194 013100 011403                  10$:	mov	(r4),r3			; check SA contents
     195 013102 100015                  	bpl	11$			; ER error bit clear
     196                                
     197 013104                         	printf	#71$,testno,(r5),r3	; format, expected, received
       1 013104                         	calls	printf #71$ testno (r5) r3            
       9 013104 010346                  	mov	r3,-(sp)
      15 013106 011546                  	mov	(r5),-(sp)
      21 013110 013746  002032          	mov	testno,-(sp)
      27 013114 012746  013504          	mov	#71$,-(sp)
       2 013120                         	call	printf
       1 013120 004737  022662          	jsr	pc,printf
       3 013124 062706  000010          	add	#10,sp
     198 013130 005237  002016          	inc	errors			; incre error count
     199 013134 000475                  	br	39$			; exit
     200                                
     201 013136 036503  000002          11$:	bit	2(r5),r3		; check other state bits clear
     202 013142 001415                  	beq	12$			; br if OK
     203                                
     204 013144                         	printf	#72$,testno,(r5),r3	; format, expected, received
       1 013144                         	calls	printf #72$ testno (r5) r3            
       9 013144 010346                  	mov	r3,-(sp)
      15 013146 011546                  	mov	(r5),-(sp)
      21 013150 013746  002032          	mov	testno,-(sp)
      27 013154 012746  013615          	mov	#72$,-(sp)
       2 013160                         	call	printf
       1 013160 004737  022662          	jsr	pc,printf
       3 013164 062706  000010          	add	#10,sp
     205 013170 005237  002016          	inc	errors			; incre error count
     206 013174 000455                  	br	39$			; exit
     207                                
     208 013176 031503                  12$:	bit	(r5),r3			; check current state bit set
     209 013200 001737                  	beq	10$			; br if not yet
     210                                
     211                                	; SA step N - response at 0->1 transition
     212                                
     213 013202 020365  000004          	cmp	r3,4(r5)		; check rcv:exp
     214 013206 001416                  	beq	13$			; br if OK
     215                                
     216 013210                         	printf	#73$,testno,(r5),4(r5),r3 ; format, state, expected, received
       1 013210                         	calls	printf #73$ testno (r5) 4(r5) r3           
       9 013210 010346                  	mov	r3,-(sp)
      15 013212 016546  000004          	mov	4(r5),-(sp)
      21 013216 011546                  	mov	(r5),-(sp)
      27 013220 013746  002032          	mov	testno,-(sp)
      33 013224 012746  013733          	mov	#73$,-(sp)
       2 013230                         	call	printf
       1 013230 004737  022662          	jsr	pc,printf
       3 013234 062706  000012          	add	#12,sp
     217 013240 005237  002016          	inc	errors			; incre error count
     218                                
     219                                	; SA step N - send
     220                                
     221 013244 016514  000006          13$:	mov	6(r5),(r4)		; set step N send data
     222                                
     223                                	; SA step N - step complete at 1->0 transition
     224                                
     225 013250 016537  000010  002030  	mov	10(r5),dlycnt		; state must complete in this time
     226                                
     227 013256 005737  002030          14$:	tst	dlycnt			; has delay count expired?
     228 013262 003014                  	bgt	15$			; not yet
     229                                
     230 013264                         	printf	#74$,testno,(r5)	; format, state
       1 013264                         	calls	printf #74$ testno (r5)             
       9 013264 011546                  	mov	(r5),-(sp)
      15 013266 013746  002032          	mov	testno,-(sp)
      21 013272 012746  014064          	mov	#74$,-(sp)
       2 013276                         	call	printf
       1 013276 004737  022662          	jsr	pc,printf
       3 013302 062706  000006          	add	#6,sp
     231 013306 005237  002016          	inc	errors			; incre error count
     232 013312 000406                  	br	39$			; exit
     233                                
     234 013314 031514                  15$:	bit	(r5),(r4)		; check current state bit cleared
     235 013316 001357                  	bne	14$			; loop if still set	
     236                                
     237 013320 062705  000012          	add	#51$-50$,r5		; next state
     238 013324 005715                  	tst	(r5)			; more states?
     239 013326 001264                  	bne	10$			; br if yes
     240                                
     241                                	; ==> done, reset controller and exit
     242                                
     243 013330 012777  000000  166454  39$:	mov	#0,@csr$ip		; reset controller
     244 013336 000137  014154          	jmp	99$			; next test
     245                                
     246                                	; - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     247                                
     248                                	; step 1
     249                                
     250 013342 004000  070000          50$:	.word	sa_st1, sa_st2+sa_st3+sa_st4
     251 013346 004400                  	.word	sa_st1+<0*sa_nsv>+<0*sa_a22>+<1*sa_edp>+<sa_opt*sa_rs0>
     252 013350 100000                  	.word	sa_stp+<0*sa_cl0>+<0*sa_rl0>+<0*sa_int>+<0*sa_vec>
     253 013352 001130                  	.word	10.*60.
     254                                
     255                                	; step 2
     256                                
     257 013354 010000  064000          51$:	.word	sa_st2, sa_st1+sa_st3+sa_st4
     258 013360 010200                  	.word	sa_st2+<0*sa_cty>+<1*sa_ste>+<0*sa_cle>+<0*sa_rle>
     259 013362 013420                  	.word	60$+<0*sa_prg>
     260 013364 001130                  	.word	10.*60.
     261                                
     262                                	; step 3
     263                                
     264 013366 020000  054000          52$:	.word	sa_st3, sa_st1+sa_st2+sa_st4
     265 013372 020000                  	.word	sa_st3+<0*sa_vpe>+<0*sa_ine>+<0*sa_vee>
     266 013374 000000                  	.word	<0*sa_ppt>+<0*sa_rgh>
     267 013376 001130                  	.word	10.*60.
     268                                
     269                                	; step 4
     270                                
     271 013400 040000  034000          53$:	.word	sa_st4, sa_st1+sa_st2+sa_st3
     272 013404 040066                  	.word	sa_st4+<sa_ctyp*sa_cn0>+<sa_ucv*sa_mc0>
     273 013406 000001                  	.word	<1*sa_go>
     274 013410 001130                  	.word	10.*60.
     275                                
     276 013412 000000                  54$:	.word	0
     277                                
     278                                	; - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     279                                
     280 013414 000000  000000          	.word	0,0			; intr flags
     281 013420 012054  000000          60$:	.word	rpkt,0			; rsp desc (host owned)
     282 013424 012140  000000          	.word	cpkt,0			; cmd desc (host owned)
     283                                
     284                                	; - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     285                                
     286 013430    015     012     124  70$:	.asciz	<cr><lf>"Test%d: basic controller initialization"<cr><lf>
         013433    145     163     164  
         013436    045     144     072  
         013441    040     142     141  
         013444    163     151     143  
         013447    040     143     157  
         013452    156     164     162  
         013455    157     154     154  
         013460    145     162     040  
         013463    151     156     151  
         013466    164     151     141  
         013471    154     151     172  
         013474    141     164     151  
         013477    157     156     015  
         013502    012     000          
     287 013504    124     145     163  71$:	.ascii	"Test%d: init ER bit set in SA register"<cr><lf>
         013507    164     045     144  
         013512    072     040     151  
         013515    156     151     164  
         013520    040     105     122  
         013523    040     142     151  
         013526    164     040     163  
         013531    145     164     040  
         013534    151     156     040  
         013537    123     101     040  
         013542    162     145     147  
         013545    151     163     164  
         013550    145     162     015  
         013553    012                  
     288 013554    040     040     105  	.ascii	"  Exp'ed  Rcv'ed"<cr><lf>
         013557    170     160     047  
         013562    145     144     040  
         013565    040     122     143  
         013570    166     047     145  
         013573    144     015     012  
     289 013576    040     040     045  	.asciz	"  %.6o  %.6o"<cr><lf>
         013601    056     066     157  
         013604    040     040     045  
         013607    056     066     157  
         013612    015     012     000  
     290 013615    124     145     163  72$:	.ascii	"Test%d: S1-S4 sequence error in SA register"<cr><lf>
         013620    164     045     144  
         013623    072     040     123  
         013626    061     055     123  
         013631    064     040     163  
         013634    145     161     165  
         013637    145     156     143  
         013642    145     040     145  
         013645    162     162     157  
         013650    162     040     151  
         013653    156     040     123  
         013656    101     040     162  
         013661    145     147     151  
         013664    163     164     145  
         013667    162     015     012  
     291 013672    040     040     105  	.ascii	"  Exp'ed  Rcv'ed"<cr><lf>
         013675    170     160     047  
         013700    145     144     040  
         013703    040     122     143  
         013706    166     047     145  
         013711    144     015     012  
     292 013714    040     040     045  	.asciz	"  %.6o  %.6o"<cr><lf>
         013717    056     066     157  
         013722    040     040     045  
         013725    056     066     157  
         013730    015     012     000  
     293 013733    124     145     163  73$:	.ascii	"Test%d: step response data compare error"<cr><lf>
         013736    164     045     144  
         013741    072     040     163  
         013744    164     145     160  
         013747    040     162     145  
         013752    163     160     157  
         013755    156     163     145  
         013760    040     144     141  
         013763    164     141     040  
         013766    143     157     155  
         013771    160     141     162  
         013774    145     040     145  
         013777    162     162     157  
         014002    162     015     012  
     294 014005    040     040     123  	.ascii	"  StpBit  Exp'ed  Rcv'ed"<cr><lf>
         014010    164     160     102  
         014013    151     164     040  
         014016    040     105     170  
         014021    160     047     145  
         014024    144     040     040  
         014027    122     143     166  
         014032    047     145     144  
         014035    015     012          
     295 014037    040     040     045  	.asciz	"  %.6o  %.6o  %.6o"<cr><lf>
         014042    056     066     157  
         014045    040     040     045  
         014050    056     066     157  
         014053    040     040     045  
         014056    056     066     157  
         014061    015     012     000  
     296 014064    124     145     163  74$:	.ascii	"Test%d: step response timeout error"<cr><lf>
         014067    164     045     144  
         014072    072     040     163  
         014075    164     145     160  
         014100    040     162     145  
         014103    163     160     157  
         014106    156     163     145  
         014111    040     164     151  
         014114    155     145     157  
         014117    165     164     040  
         014122    145     162     162  
         014125    157     162     015  
         014130    012                  
     297 014131    040     040     123  	.ascii	"  StpBit"<cr><lf>
         014134    164     160     102  
         014137    151     164     015  
         014142    012                  
     298 014143    040     040     045  	.asciz	"  %.6o"<cr><lf>
         014146    056     066     157  
         014151    015     012     000  
     299                                	.even
     300                                
     301 014154 005237  002032          99$:	inc	testno			; to next test
     302                                
     303                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     304                                
     305 014160                         	test	<check controller illegal opcode response>
       2                                
       3                                	;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       4                                	.sbttl	Test3 - check controller illegal opcode response
       5                                	;------------------------------------------------------------
       6                                
       7                                test3:	; start of test
       8                                
       9 014160 022737  000003  002032  	cmp	#3,testno		; check for sequence error
      10 014166 001401                  	beq	.+4			; OK, skip over halt
      11 014170 000000                  	halt				; FATAL - SEQUENCE ERROR
     306                                
     307 014172                         	printf	#70$,testno		; header message
       1 014172                         	calls	printf #70$ testno              
       9 014172 013746  002032          	mov	testno,-(sp)
      15 014176 012746  014552          	mov	#70$,-(sp)
       2 014202                         	call	printf
       1 014202 004737  022662          	jsr	pc,printf
       3 014206 062706  000004          	add	#4,sp
     308                                
     309 014212                         	call	init			; init controller
       1 014212 004737  021524          	jsr	pc,init
     310 014216 103151                  	bcc	59$			; br if failed
     311                                
     312 014220                         	call	bufini			; init buffers
       1 014220 004737  022522          	jsr	pc,bufini
     313                                
     314 014224 013737  002020  012140  	mov	passes,cpkt+p_crf+0	; lower half of refnum
     315 014232 012737  014160  012142  	mov	#test3,cpkt+p_crf+2	; upper half of refnum
     316 014240 012737  000077  012150  	mov	#op_ill,cpkt+p_opcd	; set an illegal opcode
     317 014246 052737  100000  012042  	bis	#ds_own,comm+2		; resp desc owned by port
     318 014254 052737  100000  012046  	bis	#ds_own,comm+6		; cmd desc owned by port
     319 014262 017700  165524          	mov	@csr$ip,r0		; wake controller
     320                                
     321 014266 012737  000074  002030  	mov	#1.*60.,dlycnt		; timeout interval
     322                                
     323 014274 005737  002030          1$:	tst	dlycnt			; delay expired?
     324 014300 003506                  	ble	39$			; br if yes
     325 014302 005737  012042          	tst	comm+2			; check response desc
     326 014306 100772                  	bmi	1$			; br if port owned
     327                                
     328 014310 005737  002030          2$:	tst	dlycnt			; delay expired?
     329 014314 003500                  	ble	39$			; br if yes
     330 014316 005737  012046          	tst	comm+6			; check command desc
     331 014322 100772                  	bmi	2$			; br if port owned
     332                                	
     333 014324                         	call	dmphdr			; dump headers
       1 014324 004737  020552          	jsr	pc,dmphdr
     334                                
     335 014330 017700  165460          	mov	@csr$sa,r0		; check error status
     336 014334 100013                  	bpl	5$			; br if no error flagged
     337 014336                         	printf	#74$,testno,r0		; error message
       1 014336                         	calls	printf #74$ testno r0             
       9 014336 010046                  	mov	r0,-(sp)
      15 014340 013746  002032          	mov	testno,-(sp)
      21 014344 012746  015074          	mov	#74$,-(sp)
       2 014350                         	call	printf
       1 014350 004737  022662          	jsr	pc,printf
       3 014354 062706  000006          	add	#6,sp
     338 014360 005237  002016          	inc	errors			; count
     339                                
     340 014364 023737  002020  012054  5$:	cmp	passes,rpkt+p_crf+0	; check lower refnum
     341 014372 001004                  	bne	6$			; br if error
     342 014374 022737  014160  012056  	cmp	#test3,rpkt+p_crf+2	; check higher refnum
     343 014402 001422                  	beq	7$			; br if OK
     344 014404                         6$:	printf	#73$,testno,passes,#test3,rpkt+p_crf+0,rpkt+p_crf+2 ; wrong status
       1 014404                         	calls	printf #73$ testno passes #test3 rpkt+p_crf+0 rpkt+p_crf+2          
       9 014404 013746  012056          	mov	rpkt+p_crf+2,-(sp)
      15 014410 013746  012054          	mov	rpkt+p_crf+0,-(sp)
      21 014414 012746  014160          	mov	#test3,-(sp)
      27 014420 013746  002020          	mov	passes,-(sp)
      33 014424 013746  002032          	mov	testno,-(sp)
      39 014430 012746  014767          	mov	#73$,-(sp)
       2 014434                         	call	printf
       1 014434 004737  022662          	jsr	pc,printf
       3 014440 062706  000014          	add	#14,sp
     345 014444 005237  002016          	inc	errors			; count
     346                                
     347 014450 013700  012066          7$:	mov	rpkt+p_sts,r0		; get response status
     348 014454 012701  004001          	mov	#st_cmd+<p_opcd*400>,r1	; expected status
     349 014460 020001                  	cmp	r0,r1			; check
     350 014462 001427                  	beq	59$			; br if OK
     351 014464                         	printf	#71$,testno,r1,r0	; wrong status
       1 014464                         	calls	printf #71$ testno r1 r0            
       9 014464 010046                  	mov	r0,-(sp)
      15 014466 010146                  	mov	r1,-(sp)
      21 014470 013746  002032          	mov	testno,-(sp)
      27 014474 012746  014631          	mov	#71$,-(sp)
       2 014500                         	call	printf
       1 014500 004737  022662          	jsr	pc,printf
       3 014504 062706  000010          	add	#10,sp
     352 014510 005237  002016          	inc	errors			; count
     353 014514 000412                  	br	59$			;
     354                                
     355 014516                         39$:	printf	#72$,testno		; timeout!
       1 014516                         	calls	printf #72$ testno              
       9 014516 013746  002032          	mov	testno,-(sp)
      15 014522 012746  014714          	mov	#72$,-(sp)
       2 014526                         	call	printf
       1 014526 004737  022662          	jsr	pc,printf
       3 014532 062706  000004          	add	#4,sp
     356 014536 005237  002016          	inc	errors			; count
     357                                
     358 014542 012777  000000  165242  59$:	mov	#0,@csr$ip		; reset controller
     359                                
     360 014550 000576                  	br	99$			; next test
     361                                
     362                                	; - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     363                                
     364 014552    015     012     124  70$:	.asciz	<cr><lf>"Test%d: controller illegal opcode response"<cr><lf>
         014555    145     163     164  
         014560    045     144     072  
         014563    040     143     157  
         014566    156     164     162  
         014571    157     154     154  
         014574    145     162     040  
         014577    151     154     154  
         014602    145     147     141  
         014605    154     040     157  
         014610    160     143     157  
         014613    144     145     040  
         014616    162     145     163  
         014621    160     157     156  
         014624    163     145     015  
         014627    012     000          
     365 014631    124     145     163  71$:	.asciz	"Test%d: illegal opcode, status: exp=%#o, rcv=%#o"<cr><lf>
         014634    164     045     144  
         014637    072     040     151  
         014642    154     154     145  
         014645    147     141     154  
         014650    040     157     160  
         014653    143     157     144  
         014656    145     054     040  
         014661    163     164     141  
         014664    164     165     163  
         014667    072     040     145  
         014672    170     160     075  
         014675    045     043     157  
         014700    054     040     162  
         014703    143     166     075  
         014706    045     043     157  
         014711    015     012     000  
     366 014714    124     145     163  72$:	.asciz	"Test%d: illegal opcode, response timeout"<cr><lf>
         014717    164     045     144  
         014722    072     040     151  
         014725    154     154     145  
         014730    147     141     154  
         014733    040     157     160  
         014736    143     157     144  
         014741    145     054     040  
         014744    162     145     163  
         014747    160     157     156  
         014752    163     145     040  
         014755    164     151     155  
         014760    145     157     165  
         014763    164     015     012  
         014766    000                  
     367 014767    124     145     163  73$:	.asciz	"Test%d: illegal opcode, refnum error, exp=%#.4X%.4X, rcv=%#.4X%.4X"<cr><lf>
         014772    164     045     144  
         014775    072     040     151  
         015000    154     154     145  
         015003    147     141     154  
         015006    040     157     160  
         015011    143     157     144  
         015014    145     054     040  
         015017    162     145     146  
         015022    156     165     155  
         015025    040     145     162  
         015030    162     157     162  
         015033    054     040     145  
         015036    170     160     075  
         015041    045     043     056  
         015044    064     130     045  
         015047    056     064     130  
         015052    054     040     162  
         015055    143     166     075  
         015060    045     043     056  
         015063    064     130     045  
         015066    056     064     130  
         015071    015     012     000  
     368 015074    124     145     163  74$:	.asciz	"Test%d: illegal opcode, fatal error %#o"<cr><lf>
         015077    164     045     144  
         015102    072     040     151  
         015105    154     154     145  
         015110    147     141     154  
         015113    040     157     160  
         015116    143     157     144  
         015121    145     054     040  
         015124    146     141     164  
         015127    141     154     040  
         015132    145     162     162  
         015135    157     162     040  
         015140    045     043     157  
         015143    015     012     000  
     369                                	.even
     370                                
     371 015146 005237  002032          99$:	inc	testno			; to next test
     372                                
     373                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     374                                
     375 015152                         	test	<check online units>
       2                                
       3                                	;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       4                                	.sbttl	Test4 - check online units
       5                                	;------------------------------------------------------------
       6                                
       7                                test4:	; start of test
       8                                
       9 015152 022737  000004  002032  	cmp	#4,testno		; check for sequence error
      10 015160 001401                  	beq	.+4			; OK, skip over halt
      11 015162 000000                  	halt				; FATAL - SEQUENCE ERROR
     376                                
     377 015164                         	printf	#70$,testno		; header message
       1 015164                         	calls	printf #70$ testno              
       9 015164 013746  002032          	mov	testno,-(sp)
      15 015170 012746  015730          	mov	#70$,-(sp)
       2 015174                         	call	printf
       1 015174 004737  022662          	jsr	pc,printf
       3 015200 062706  000004          	add	#4,sp
     378                                
     379 015204                         	call	init			; init controller
       1 015204 004737  021524          	jsr	pc,init
     380 015210 103402                  	bcs	2$			; br if OK
     381 015212 000137  015706          	jmp	59$			; else error
     382                                
     383 015216 005003                  2$:	clr	r3			; init unit number
     384                                
     385 015220                         1$:	call	bufini			; init buffers
       1 015220 004737  022522          	jsr	pc,bufini
     386                                
     387 015224 013737  002020  012140  	mov	passes,cpkt+p_crf+0	; lower half of refnum
     388 015232 012737  015152  012142  	mov	#test4,cpkt+p_crf+2	; upper half of refnum
     389 015240 012737  000011  012150  	mov	#op_onl,cpkt+p_opcd	; set opcode
     390 015246 010337  012144          	mov	r3,cpkt+p_unit		; set unit
     391 015252 052737  100000  012042  	bis	#ds_own,comm+2		; resp desc owned by port
     392 015260 052737  100000  012046  	bis	#ds_own,comm+6		; cmd desc owned by port
     393 015266 017700  164520          	mov	@csr$ip,r0		; wake controller
     394                                
     395 015272 012737  001130  002030  	mov	#10.*60.,dlycnt		; timeout interval
     396                                
     397 015300 005737  002030          10$:	tst	dlycnt			; delay expired?
     398 015304 003566                  	ble	39$			; br if yes
     399 015306 005737  012042          	tst	comm+2			; check response desc
     400 015312 100772                  	bmi	10$			; br if port owned
     401                                
     402 015314 005737  002030          11$:	tst	dlycnt			; delay expired?
     403 015320 003560                  	ble	39$			; br if yes
     404 015322 005737  012046          	tst	comm+6			; check command desc
     405 015326 100772                  	bmi	11$			; br if port owned
     406                                	
     407 015330                         	call	dmphdr			; dump headers
       1 015330 004737  020552          	jsr	pc,dmphdr
     408                                
     409 015334 017700  164454          	mov	@csr$sa,r0		; check error status
     410 015340 100014                  	bpl	16$			; br if no error flagged
     411 015342                         	printf	#74$,testno,r3,r0	; error message
       1 015342                         	calls	printf #74$ testno r3 r0            
       9 015342 010046                  	mov	r0,-(sp)
      15 015344 010346                  	mov	r3,-(sp)
      21 015346 013746  002032          	mov	testno,-(sp)
      27 015352 012746  016040          	mov	#74$,-(sp)
       2 015356                         	call	printf
       1 015356 004737  022662          	jsr	pc,printf
       3 015362 062706  000010          	add	#10,sp
     412 015366 005237  002016          	inc	errors			; count
     413                                
     414 015372 023737  002020  012054  16$:	cmp	passes,rpkt+p_crf+0	; check lower refnum
     415 015400 001004                  	bne	18$			; br if error
     416 015402 022737  015152  012056  	cmp	#test4,rpkt+p_crf+2	; check higher refnum
     417 015410 001423                  	beq	17$			; br if OK
     418 015412                         18$:	printf	#77$,testno,r3,passes,#test4,rpkt+p_crf+0,rpkt+p_crf+2 ; wrong status
       1 015412                         	calls	printf #77$ testno r3 passes #test4 rpkt+p_crf+0 rpkt+p_crf+2         
       9 015412 013746  012056          	mov	rpkt+p_crf+2,-(sp)
      15 015416 013746  012054          	mov	rpkt+p_crf+0,-(sp)
      21 015422 012746  015152          	mov	#test4,-(sp)
      27 015426 013746  002020          	mov	passes,-(sp)
      33 015432 010346                  	mov	r3,-(sp)
      39 015434 013746  002032          	mov	testno,-(sp)
      45 015440 012746  016320          	mov	#77$,-(sp)
       2 015444                         	call	printf
       1 015444 004737  022662          	jsr	pc,printf
       3 015450 062706  000016          	add	#16,sp
     419 015454 005237  002016          	inc	errors			; count
     420                                
     421 015460 122737  000000  012066  17$:	cmpb	#st_suc,rpkt+p_sts	; success status?
     422 015466 001414                  	beq	12$			; br if OK
     423 015470                         	printf	#76$,testno,r3,rpkt+p_sts ; no unit present
       1 015470                         	calls	printf #76$ testno r3 rpkt+p_sts            
       9 015470 013746  012066          	mov	rpkt+p_sts,-(sp)
      15 015474 010346                  	mov	r3,-(sp)
      21 015476 013746  002032          	mov	testno,-(sp)
      27 015502 012746  016227          	mov	#76$,-(sp)
       2 015506                         	call	printf
       1 015506 004737  022662          	jsr	pc,printf
       3 015512 062706  000010          	add	#10,sp
     424 015516 000453                  	br	19$			;
     425                                
     426 015520 013737  012110  015726  12$:	mov	rpkt+p_medi+0,61$	; get LSB
     427 015526 042737  177600  015726  	bic	#^c177,61$		; extract numerics
     428 015534 013700  012112          	mov	rpkt+p_medi+2,r0	; get MSB
     429 015540 013701  012110          	mov	rpkt+p_medi+0,r1	; get LSB
     430 015544 073027  177771          	ashc	#-7,r0			; (r0,r1)>>7
     431 015550 012702  015725          	mov	#60$+5,r2		; ptr to string
     432 015554 010104                  13$:	mov	r1,r4			; get LSB
     433 015556 042704  177740          	bic	#^c37,r4		; get low 5 bits
     434 015562 001402                  	beq	14$			; zero is unused
     435 015564 062704  000100          	add	#<'A>-1,r4		; make ascii	
     436 015570 110442                  14$:	movb	r4,-(r2)		; store character
     437 015572 073027  177773          	ashc	#-5,r0			; (r0,r1)>>5
     438 015576 001366                  	bne	13$			; br if more
     439 015600                         	printf	#75$,testno,r3,rpkt+p_unsz+2,rpkt+p_unsz+0,#60$+0,#60$+2,61$
       1 015600                         	calls	printf #75$ testno r3 rpkt+p_unsz+2 rpkt+p_unsz+0 #60$+0 #60$+2 61$        
       9 015600 013746  015726          	mov	61$,-(sp)
      15 015604 012746  015722          	mov	#60$+2,-(sp)
      21 015610 012746  015720          	mov	#60$+0,-(sp)
      27 015614 013746  012120          	mov	rpkt+p_unsz+0,-(sp)
      33 015620 013746  012122          	mov	rpkt+p_unsz+2,-(sp)
      39 015624 010346                  	mov	r3,-(sp)
      45 015626 013746  002032          	mov	testno,-(sp)
      51 015632 012746  016121          	mov	#75$,-(sp)
       2 015636                         	call	printf
       1 015636 004737  022662          	jsr	pc,printf
       3 015642 062706  000020          	add	#20,sp
     440                                
     441 015646 005203                  19$:	inc	r3			; bump unit number
     442 015650 020327  000007          	cmp	r3,#7			; check for maximum
     443 015654 003014                  	bgt	59$			; done
     444 015656 000137  015220          	jmp	1$			; br if unit num is OK
     445                                
     446 015662                         39$:	printf	#72$,testno		; timeout!
       1 015662                         	calls	printf #72$ testno              
       9 015662 013746  002032          	mov	testno,-(sp)
      15 015666 012746  015767          	mov	#72$,-(sp)
       2 015672                         	call	printf
       1 015672 004737  022662          	jsr	pc,printf
       3 015676 062706  000004          	add	#4,sp
     447 015702 005237  002016          	inc	errors			; count
     448                                
     449 015706 012777  000000  164076  59$:	mov	#0,@csr$ip		; reset controller
     450                                
     451 015714 000137  016434          	jmp	99$			; next test
     452                                
     453                                	; - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     454                                
     455 015720    104     104     101  60$:	.asciz	"DDAAA"
         015723    101     101     000  
     456        015726                  61$:	.blkw	1.
     457 015730    015     012     124  70$:	.asciz	<cr><lf>"Test%d: check online units"<cr><lf>
         015733    145     163     164  
         015736    045     144     072  
         015741    040     143     150  
         015744    145     143     153  
         015747    040     157     156  
         015752    154     151     156  
         015755    145     040     165  
         015760    156     151     164  
         015763    163     015     012  
         015766    000                  
     458 015767    124     145     163  72$:	.asciz	"Test%d: online check, response timeout"<cr><lf>
         015772    164     045     144  
         015775    072     040     157  
         016000    156     154     151  
         016003    156     145     040  
         016006    143     150     145  
         016011    143     153     054  
         016014    040     162     145  
         016017    163     160     157  
         016022    156     163     145  
         016025    040     164     151  
         016030    155     145     157  
         016033    165     164     015  
         016036    012     000          
     459 016040    124     145     163  74$:	.asciz	"Test%d: online check, unit=%d, fatal error %#o"<cr><lf>
         016043    164     045     144  
         016046    072     040     157  
         016051    156     154     151  
         016054    156     145     040  
         016057    143     150     145  
         016062    143     153     054  
         016065    040     165     156  
         016070    151     164     075  
         016073    045     144     054  
         016076    040     146     141  
         016101    164     141     154  
         016104    040     145     162  
         016107    162     157     162  
         016112    040     045     043  
         016115    157     015     012  
         016120    000                  
     460 016121    124     145     163  75$:	.asciz	"Test%d: online check, unit=%d, blkcount=%lu., mediatype=%.2s:%.3s%d"<cr><lf>
         016124    164     045     144  
         016127    072     040     157  
         016132    156     154     151  
         016135    156     145     040  
         016140    143     150     145  
         016143    143     153     054  
         016146    040     165     156  
         016151    151     164     075  
         016154    045     144     054  
         016157    040     142     154  
         016162    153     143     157  
         016165    165     156     164  
         016170    075     045     154  
         016173    165     056     054  
         016176    040     155     145  
         016201    144     151     141  
         016204    164     171     160  
         016207    145     075     045  
         016212    056     062     163  
         016215    072     045     056  
         016220    063     163     045  
         016223    144     015     012  
         016226    000                  
     461 016227    124     145     163  76$:	.asciz	"Test%d: online check, unit=%d, not present, status=%#o"<cr><lf>
         016232    164     045     144  
         016235    072     040     157  
         016240    156     154     151  
         016243    156     145     040  
         016246    143     150     145  
         016251    143     153     054  
         016254    040     165     156  
         016257    151     164     075  
         016262    045     144     054  
         016265    040     156     157  
         016270    164     040     160  
         016273    162     145     163  
         016276    145     156     164  
         016301    054     040     163  
         016304    164     141     164  
         016307    165     163     075  
         016312    045     043     157  
         016315    015     012     000  
     462 016320    124     145     163  77$:	.asciz	"Test%d: online check, unit=%d, refnum error, exp=%#.4X%.4X, rcv=%#.4X%.4X"<cr><lf>
         016323    164     045     144  
         016326    072     040     157  
         016331    156     154     151  
         016334    156     145     040  
         016337    143     150     145  
         016342    143     153     054  
         016345    040     165     156  
         016350    151     164     075  
         016353    045     144     054  
         016356    040     162     145  
         016361    146     156     165  
         016364    155     040     145  
         016367    162     162     157  
         016372    162     054     040  
         016375    145     170     160  
         016400    075     045     043  
         016403    056     064     130  
         016406    045     056     064  
         016411    130     054     040  
         016414    162     143     166  
         016417    075     045     043  
         016422    056     064     130  
         016425    045     056     064  
         016430    130     015     012  
         016433    000                  
     463                                	.even
     464                                
     465 016434 005237  002032          99$:	inc	testno			; to next test
     466                                
     467                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     468                                
     469 016440                         	test	<M9312 basic boot sequence>
       2                                
       3                                	;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       4                                	.sbttl	Test5 - M9312 basic boot sequence
       5                                	;------------------------------------------------------------
       6                                
       7                                test5:	; start of test
       8                                
       9 016440 022737  000005  002032  	cmp	#5,testno		; check for sequence error
      10 016446 001401                  	beq	.+4			; OK, skip over halt
      11 016450 000000                  	halt				; FATAL - SEQUENCE ERROR
     470                                
     471 016452                         	printf	#70$,testno		; header message
       1 016452                         	calls	printf #70$ testno              
       9 016452 013746  002032          	mov	testno,-(sp)
      15 016456 012746  017304          	mov	#70$,-(sp)
       2 016462                         	call	printf
       1 016462 004737  022662          	jsr	pc,printf
       3 016466 062706  000004          	add	#4,sp
     472                                
     473 016472 005000                  	clr	r0			; unit number
     474                                
     475 016474 013701  002012          1$:	mov	csr$ip,r1		; ptr to csr
     476 016500 010021                  	mov	r0,(r1)+		; init controller (write IP), bump ptr
     477 016502 012705  004000          	mov	#sa_st1,r5		; S1 state bitmask
     478 016506 012703  017270          	mov	#60$,r3			; [MOD] point to data table
     479                                
     480 016512 005711                  10$:	tst	(r1)			; error bit set ?
     481 016514 100013                  	bpl	13$			; [MOD] br if OK
     482 016516                         	printf	#71$,testno,r0		; [ADD] controller init error exit
       1 016516                         	calls	printf #71$ testno r0             
       9 016516 010046                  	mov	r0,-(sp)
      15 016520 013746  002032          	mov	testno,-(sp)
      21 016524 012746  017352          	mov	#71$,-(sp)
       2 016530                         	call	printf
       1 016530 004737  022662          	jsr	pc,printf
       3 016534 062706  000006          	add	#6,sp
     483 016540 000137  017252          	jmp	58$			; [ADD] and die
     484 016544 031105                  13$:	bit	(r1),r5			; step bit set ?
     485 016546 001761                  	beq	10$			; not yet, wait loop
     486 016550 012311                  	mov	(r3)+,(r1)		; send next init data
     487 016552 006305                  	asl	r5			; next mask
     488 016554 100356                  	bpl	10$			; s4 done ? br if not yet
     489                                
     490 016556 012702  002034          11$:	mov	#buffer,r2		; [MOD] set buffer start
     491 016562 005022                  12$:	clr	(r2)+			; clear buffer
     492 016564 020227  012040          	cmp	r2,#comm		; check for end of buffer
     493 016570 001374                  	bne	12$			; loop if not done
     494                                
     495 016572 010237  012134          	mov	r2,cpkt-4		; set intr
     496 016576 112337  012150          	movb	(r3)+,cpkt+10		; set command
     497 016602 111337  012155          	movb	(r3),cpkt+15		; set bytecnt(hi)
     498 016606 010037  012144          	mov	r0,cpkt+4		; set unit
     499 016612 012737  002034  012160  	mov	#buffer,cpkt+p_buff	; [ADD] set buffer address
     500 016620 032737  000001  002020  	bit	#1,passes		; [ADD] check if odd pass
     501 016626 001003                  	bne	15$			; [ADD] br if odd pass
     502 016630 052737  040000  012152  	bis	#md_cmp,cpkt+p_mod	; [ADD] set compare after read option
     503 016636 012722  012054          15$:	mov	#rpkt,(r2)+		; rq desc addr
     504 016642 010522                  	mov	r5,(r2)+		; rq own bit15
     505 016644 012722  012140          	mov	#cpkt,(r2)+		; cp desc addr
     506 016650 010522                  	mov	r5,(r2)+		; cq own bit15
     507 016652 016102  177776          	mov	-2(r1),r2		; wake controller (read IP)
     508                                
     509 016656 005737  012042          20$:	tst	comm+2			; rq own controller ?
     510 016662 100775                  	bmi	20$			; loop if not done
     511 016664                         	call	dmphdr			; [ADD] print cmd/resp buffers
       1 016664 004737  020552          	jsr	pc,dmphdr
     512 016670 017702  163120          	mov	@csr$sa,r2		; [ADD] check error status
     513 016674 100014                  	bpl	16$			; [ADD] br if no error flagged
     514 016676                         	printf	#77$,testno,r0,r2	; [ADD] error message
       1 016676                         	calls	printf #77$ testno r0 r2            
       9 016676 010246                  	mov	r2,-(sp)
      15 016700 010046                  	mov	r0,-(sp)
      21 016702 013746  002032          	mov	testno,-(sp)
      27 016706 012746  020150          	mov	#77$,-(sp)
       2 016712                         	call	printf
       1 016712 004737  022662          	jsr	pc,printf
       3 016716 062706  000010          	add	#10,sp
     515 016722 005237  002016          	inc	errors			; [ADD] count
     516 016726 005002                  16$:	clr	r2			; [ADD] zap
     517 016730 153702  012150          	bisb	cpkt+p_opcd,r2		; [ADD] get original command byte
     518 016734 152702  000200          	bisb	#op_end,r2		; [ADD] make an end-command version
     519 016740 120237  012064          	cmpb	r2,rpkt+p_opcd		; [ADD] should match response packet
     520 016744 001416                  	beq	21$			; [ADD] br if OK
     521 016746                         	printf	#73$,testno,r0,r2,rpkt+p_opcd ; [ADD] warning, response cmd error
       1 016746                         	calls	printf #73$ testno r0 r2 rpkt+p_opcd           
       9 016746 013746  012064          	mov	rpkt+p_opcd,-(sp)
      15 016752 010246                  	mov	r2,-(sp)
      21 016754 010046                  	mov	r0,-(sp)
      27 016756 013746  002032          	mov	testno,-(sp)
      33 016762 012746  017547          	mov	#73$,-(sp)
       2 016766                         	call	printf
       1 016766 004737  022662          	jsr	pc,printf
       3 016772 062706  000012          	add	#12,sp
     522 016776 005237  002016          	inc	errors			; [ADD] error
     523                                
     524 017002 122737  000011  012150  21$:	cmpb	#op_onl,cpkt+p_opcd	; [ADD] ONLINE command?
     525 017010 001024                  	bne	23$			; [ADD] br if not
     526 017012 122737  000043  012066  	cmpb	#40!st_ofl,rpkt+p_sts	; [ADD] UNIT OFFLINE result?
     527 017020 001404                  	beq	22$			; [ADD] br if yes
     528 017022 122737  000003  012066  	cmpb	#st_ofl,rpkt+p_sts	; [ADD] UNIT UNKNOWN result?
     529 017030 001043                  	bne	30$			; [ADD] br if yes
     530 017032                         22$:	printf	#76$,testno,r0,rpkt+p_sts ; [ADD] no unit present
       1 017032                         	calls	printf #76$ testno r0 rpkt+p_sts            
       9 017032 013746  012066          	mov	rpkt+p_sts,-(sp)
      15 017036 010046                  	mov	r0,-(sp)
      21 017040 013746  002032          	mov	testno,-(sp)
      27 017044 012746  020065          	mov	#76$,-(sp)
       2 017050                         	call	printf
       1 017050 004737  022662          	jsr	pc,printf
       3 017054 062706  000010          	add	#10,sp
     531 017060 000451                  	br	40$			; [ADD] else OK
     532                                
     533 017062 122737  000041  012150  23$:	cmpb	#op_rd,cpkt+p_opcd	; [ADD] READ command?
     534 017070 001023                  	bne	30$			; [ADD] br if not
     535 017072 023737  012154  012070  	cmp	cpkt+p_bcnt,rpkt+p_bcnt	; [ADD] bytecount asked/rcved must match
     536 017100 001417                  	beq	30$			; [ADD] br if OK
     537 017102                         	printf	#74$,testno,r0,cpkt+p_bcnt,rpkt+p_bcnt ; [ADD] warning, response cmd error
       1 017102                         	calls	printf #74$ testno r0 cpkt+p_bcnt rpkt+p_bcnt           
       9 017102 013746  012070          	mov	rpkt+p_bcnt,-(sp)
      15 017106 013746  012154          	mov	cpkt+p_bcnt,-(sp)
      21 017112 010046                  	mov	r0,-(sp)
      27 017114 013746  002032          	mov	testno,-(sp)
      33 017120 012746  017655          	mov	#74$,-(sp)
       2 017124                         	call	printf
       1 017124 004737  022662          	jsr	pc,printf
       3 017130 062706  000012          	add	#12,sp
     538 017134 005237  002016          	inc	errors			; [ADD] error
     539                                
     540 017140 105737  012066          30$:	tstb	rpkt+p_sts		; check for error ?
     541 017144 001025                  	bne	51$			; yup, fail back to begin to retry
     542                                
     543 017146 105723                  	tstb	(r3)+			; check end of table ?
     544 017150 001602                  	beq	11$			; br if not yet
     545 017152                         	printf	#75$,testno,r0,rpkt+p_bcnt ; [ADD] indicate success
       1 017152                         	calls	printf #75$ testno r0 rpkt+p_bcnt            
       9 017152 013746  012070          	mov	rpkt+p_bcnt,-(sp)
      15 017156 010046                  	mov	r0,-(sp)
      21 017160 013746  002032          	mov	testno,-(sp)
      27 017164 012746  017765          	mov	#75$,-(sp)
       2 017170                         	call	printf
       1 017170 004737  022662          	jsr	pc,printf
       3 017174 062706  000010          	add	#10,sp
     546 017200                         	call	dmpbuf			; [ADD] print boot data block
       1 017200 004737  021154          	jsr	pc,dmpbuf
     547                                
     548 017204 005200                  40$:	inc	r0			; [ADD] bump unit number
     549 017206 020027  000007          	cmp	r0,#7			; [ADD] check for maximum
     550 017212 003021                  	bgt	59$			; [ADD] all done
     551 017214 000137  016474          	jmp	1$			; [ADD] br if unit num is OK
     552                                
     553                                	; command error exit
     554 017220                         51$:	printf	#72$,testno,r0,cpkt+p_opcd,rpkt+p_sts ; command error exit
       1 017220                         	calls	printf #72$ testno r0 cpkt+p_opcd rpkt+p_sts           
       9 017220 013746  012066          	mov	rpkt+p_sts,-(sp)
      15 017224 013746  012150          	mov	cpkt+p_opcd,-(sp)
      21 017230 010046                  	mov	r0,-(sp)
      27 017232 013746  002032          	mov	testno,-(sp)
      33 017236 012746  017441          	mov	#72$,-(sp)
       2 017242                         	call	printf
       1 017242 004737  022662          	jsr	pc,printf
       3 017246 062706  000012          	add	#12,sp
     555                                
     556                                	; error exit
     557 017252 005237  002016          58$:	inc	errors			; error
     558                                	; normal exit
     559 017256 012777  000000  162526  59$:	mov	#0,@csr$ip		; reset controller
     560 017264 000137  020226          	jmp	99$			; next test
     561                                
     562                                	; - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     563                                
     564                                	; MSCP init data
     565                                
     566 017270 100000                  60$:	.word	sa_stp			; S1: no int, ring size 1, no vector
     567 017272 012040                  	.word	comm			; S2: ringbase lo addr
     568 017274 000000                  	.word	0			; S3: no purge/poll, ringbase hi addr
     569 017276 000001                  	.word	sa_go			; S4: go bit
     570                                
     571                                	; MSCP command data
     572                                
     573 017300    011     000          	.byte	op_onl,000		; cmd=online, bytecnt_hi=000(0)
     574 017302    041     002          	.byte	op_rd,002		; cmd=read, bytecnt_hi=002(512)
     575                                
     576                                	; - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     577                                
     578 017304    015     012     124  70$:	.asciz	<cr><lf>"Test%d: M9312 basic boot sequence"<cr><lf>
         017307    145     163     164  
         017312    045     144     072  
         017315    040     115     071  
         017320    063     061     062  
         017323    040     142     141  
         017326    163     151     143  
         017331    040     142     157  
         017334    157     164     040  
         017337    163     145     161  
         017342    165     145     156  
         017345    143     145     015  
         017350    012     000          
     579 017352    124     145     163  71$:	.asciz	"Test%d: ERROR bit set during initialization, unit=%d"<cr><lf>
         017355    164     045     144  
         017360    072     040     105  
         017363    122     122     117  
         017366    122     040     142  
         017371    151     164     040  
         017374    163     145     164  
         017377    040     144     165  
         017402    162     151     156  
         017405    147     040     151  
         017410    156     151     164  
         017413    151     141     154  
         017416    151     172     141  
         017421    164     151     157  
         017424    156     054     040  
         017427    165     156     151  
         017432    164     075     045  
         017435    144     015     012  
         017440    000                  
     580 017441    124     145     163  72$:	.asciz	"Test%d: ERROR during command execution, unit=%d, cmd=%#o, error=%#o"<cr><lf>
         017444    164     045     144  
         017447    072     040     105  
         017452    122     122     117  
         017455    122     040     144  
         017460    165     162     151  
         017463    156     147     040  
         017466    143     157     155  
         017471    155     141     156  
         017474    144     040     145  
         017477    170     145     143  
         017502    165     164     151  
         017505    157     156     054  
         017510    040     165     156  
         017513    151     164     075  
         017516    045     144     054  
         017521    040     143     155  
         017524    144     075     045  
         017527    043     157     054  
         017532    040     145     162  
         017535    162     157     162  
         017540    075     045     043  
         017543    157     015     012  
         017546    000                  
     581 017547    124     145     163  73$:	.asciz	"Test%d: ERROR incorrect response command, unit=%d, exp=%#o, rcv=%#o"<cr><lf>
         017552    164     045     144  
         017555    072     040     105  
         017560    122     122     117  
         017563    122     040     151  
         017566    156     143     157  
         017571    162     162     145  
         017574    143     164     040  
         017577    162     145     163  
         017602    160     157     156  
         017605    163     145     040  
         017610    143     157     155  
         017613    155     141     156  
         017616    144     054     040  
         017621    165     156     151  
         017624    164     075     045  
         017627    144     054     040  
         017632    145     170     160  
         017635    075     045     043  
         017640    157     054     040  
         017643    162     143     166  
         017646    075     045     043  
         017651    157     015     012  
         017654    000                  
     582 017655    124     145     163  74$:	.asciz	"Test%d: ERROR incorrect response bytecount, unit=%d, exp=%#o, rcv=%#o"<cr><lf>
         017660    164     045     144  
         017663    072     040     105  
         017666    122     122     117  
         017671    122     040     151  
         017674    156     143     157  
         017677    162     162     145  
         017702    143     164     040  
         017705    162     145     163  
         017710    160     157     156  
         017713    163     145     040  
         017716    142     171     164  
         017721    145     143     157  
         017724    165     156     164  
         017727    054     040     165  
         017732    156     151     164  
         017735    075     045     144  
         017740    054     040     145  
         017743    170     160     075  
         017746    045     043     157  
         017751    054     040     162  
         017754    143     166     075  
         017757    045     043     157  
         017762    015     012     000  
     583 017765    124     145     163  75$:	.asciz	"Test%d: OK, successful bootblock read, unit=%d, bytecount=%d."<cr><lf>
         017770    164     045     144  
         017773    072     040     117  
         017776    113     054     040  
         020001    163     165     143  
         020004    143     145     163  
         020007    163     146     165  
         020012    154     040     142  
         020015    157     157     164  
         020020    142     154     157  
         020023    143     153     040  
         020026    162     145     141  
         020031    144     054     040  
         020034    165     156     151  
         020037    164     075     045  
         020042    144     054     040  
         020045    142     171     164  
         020050    145     143     157  
         020053    165     156     164  
         020056    075     045     144  
         020061    056     015     012  
         020064    000                  
     584 020065    124     145     163  76$:	.asciz	"Test%d: no device present, unit=%d, status=%#03o"<cr><lf>
         020070    164     045     144  
         020073    072     040     156  
         020076    157     040     144  
         020101    145     166     151  
         020104    143     145     040  
         020107    160     162     145  
         020112    163     145     156  
         020115    164     054     040  
         020120    165     156     151  
         020123    164     075     045  
         020126    144     054     040  
         020131    163     164     141  
         020134    164     165     163  
         020137    075     045     043  
         020142    060     063     157  
         020145    015     012     000  
     585 020150    124     145     163  77$:	.asciz	"Test%d: boot read, unit=%d, fatal error %#o"<cr><lf>
         020153    164     045     144  
         020156    072     040     142  
         020161    157     157     164  
         020164    040     162     145  
         020167    141     144     054  
         020172    040     165     156  
         020175    151     164     075  
         020200    045     144     054  
         020203    040     146     141  
         020206    164     141     154  
         020211    040     145     162  
         020214    162     157     162  
         020217    040     045     043  
         020222    157     015     012  
         020225    000                  
     586                                	.even
     587                                
     588 020226 005237  002032          99$:	inc	testno			; to next test
     589                                
     590                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     591                                
     592                                ; all done
     593                                
     594 020232 005237  002020          done:	inc	passes			; count passes
     595 020236                         	printf	#msg3,passes,errors	; output some status
       1 020236                         	calls	printf #msg3 passes errors             
       9 020236 013746  002016          	mov	errors,-(sp)
      15 020242 013746  002020          	mov	passes,-(sp)
      21 020246 012746  020443          	mov	#msg3,-(sp)
       2 020252                         	call	printf
       1 020252 004737  022662          	jsr	pc,printf
       3 020256 062706  000006          	add	#6,sp
     596 020262 023737  002004  002020  	cmp	numpas,passes		; chek if done
     597 020270 001402                  	beq	exit			; yes
     598 020272 000137  012546          	jmp	loop			; not yet
     599                                
     600 020276 013700  002022          exit:	mov	$sav42,r0		; check if loaded by XXDP
     601 020302 001407                  	beq	noxxdp			; br if not
     602 020304 000005                  	reset				; yes, reset the world
     603 020306 004710                  $endad:	jsr	pc,(r0)			; return back to XXDP
     604 020310 000240                  	nop				; standard sequence
     605 020312 000240                  	nop				;
     606 020314 000240                  	nop				;
     607 020316 000137  012546          	jmp	loop			; back for more
     608                                
     609 020322                         noxxdp:	printf	#msg2			; say goodbye
       1 020322                         	calls	printf #msg2               
       9 020322 012746  020427          	mov	#msg2,-(sp)
       2 020326                         	call	printf
       1 020326 004737  022662          	jsr	pc,printf
       3 020332 062706  000002          	add	#2,sp
     610 020336 005000                  	clr	r0			;
     611 020340 005300                  10$:	dec	r0			;
     612 020342 001376                  	bne	10$			; some delay
     613 020344 000005                  	reset				; zap the world
     614 020346 012746  000340          	mov	#<7>*bit5,-(sp)		; prio7 in psw
     615 020352 012746  165144          	mov	#console,-(sp)		; go there
     616 020356 000002                  	rti				; reload psw
     617                                
     618 020360    015     012     015  msg1:	.asciz	<cr><lf><cr><lf>"TMSCP Controller Exerciser v1.07"<cr><lf>
         020363    012     124     115  
         020366    123     103     120  
         020371    040     103     157  
         020374    156     164     162  
         020377    157     154     154  
         020402    145     162     040  
         020405    105     170     145  
         020410    162     143     151  
         020413    163     145     162  
         020416    040     166     061  
         020421    056     060     067  
         020424    015     012     000  
     619 020427    015     012     107  msg2:	.asciz	<cr><lf>"Goodbye"<cr><lf>
         020432    157     157     144  
         020435    142     171     145  
         020440    015     012     000  
     620 020443    015     012     105  msg3:	.asciz	<cr><lf>"End pass %u. errors %u."<cr><lf>
         020446    156     144     040  
         020451    160     141     163  
         020454    163     040     045  
         020457    165     056     040  
         020462    145     162     162  
         020465    157     162     163  
         020470    040     045     165  
         020473    056     015     012  
         020476    000                  
     621 020477    000                  	.even
     622                                
     623                                ; --------------------------------------------------------------------------------
     624                                ;
     625                                ; line clock interrupt routine
     626                                ;
     627 020500 062737  000001  002024  lkintr:	add	#1,ticklo		;*6* incre tickcount lo
     628 020506 005537  002026          	adc	tickhi			;*6* and propagate
     629 020512 005737  002030          	tst	dlycnt			;*6* check delay counter
     630 020516 003402                  	ble	1$			;*6* don't decre past zero
     631 020520 005337  002030          	dec	dlycnt			;*6* decre delay counter
     632 020524 042737  000200  177546  1$:	bic	#lk_mon,lk$csr		;*6* clear monitor bit
     633 020532 000002                  	rti				;*6* and done
     634                                
     635                                ; --------------------------------------------------------------------------------
     636                                ;
     637                                ; delay routine
     638                                ;
     639                                ;	call:	mov	#ticks,r0	; number of ticks to delay [1..32767]
     640                                ;		call	delay
     641                                ;
     642 020534 010037  002030          delay:	mov	r0,dlycnt		; wait this many ticks
     643 020540 003403                  	ble	2$			; br if no delay
     644 020542 005737  002030          1$:	tst	dlycnt			; are we there yet?
     645 020546 003375                  	bgt	1$			; br if not yet
     646 020550                         2$:	return				; done
       1 020550 000207                  	rts	pc
     647                                
     648                                ; --------------------------------------------------------------------------------
     649                                ;
     650                                ; command packet dumper
     651                                ;
     652                                ;	call:	call	dmphdr
     653                                ;
     654 020552 032737  000001  002002  dmphdr:	bit	#bit0,optswi		; check if extra printout enabled
     655 020560 001506                  	beq	99$			; br if not
     656 020562                         	savreg	r4,r5			; save registers
       3 020562 010446                  	mov	r4,-(sp)
       8 020564 010546                  	mov	r5,-(sp)
     657                                
     658 020566 012705  012040          	mov	#comm,r5		; block address
     659 020572                         	printf	#200$,r5,#-4,-4(r5),-2(r5),#0,(r5),2(r5),4(r5),6(r5) ; print header
       1 020572                         	calls	printf #200$ r5 #-4 -4(r5) -2(r5) #0 (r5) 2(r5) 4(r5) 6(r5)      
       9 020572 016546  000006          	mov	6(r5),-(sp)
      15 020576 016546  000004          	mov	4(r5),-(sp)
      21 020602 016546  000002          	mov	2(r5),-(sp)
      27 020606 011546                  	mov	(r5),-(sp)
      33 020610 012746  000000          	mov	#0,-(sp)
      39 020614 016546  177776          	mov	-2(r5),-(sp)
      45 020620 016546  177774          	mov	-4(r5),-(sp)
      51 020624 012746  177774          	mov	#-4,-(sp)
      57 020630 010546                  	mov	r5,-(sp)
      63 020632 012746  021000          	mov	#200$,-(sp)
       2 020636                         	call	printf
       1 020636 004737  022662          	jsr	pc,printf
       3 020642 062706  000024          	add	#24,sp
     660                                
     661 020646 012704  000040          	mov	#32.,r4			; block size
     662 020652 012705  012140          	mov	#cpkt,r5		; block address
     663 020656                         	printf	#201$,#'c,r5,#-4,-4(r5),-2(r5) ; print header
       1 020656                         	calls	printf #201$ #'c r5 #-4 -4(r5) -2(r5)          
       9 020656 016546  177776          	mov	-2(r5),-(sp)
      15 020662 016546  177774          	mov	-4(r5),-(sp)
      21 020666 012746  177774          	mov	#-4,-(sp)
      27 020672 010546                  	mov	r5,-(sp)
      33 020674 012746  000143          	mov	#'c,-(sp)
      39 020700 012746  021104          	mov	#201$,-(sp)
       2 020704                         	call	printf
       1 020704 004737  022662          	jsr	pc,printf
       3 020710 062706  000014          	add	#14,sp
     664 020714                         	call	dumper			; print block
       1 020714 004737  021256          	jsr	pc,dumper
     665                                
     666 020720 012704  000040          	mov	#32.,r4			; block size
     667 020724 012705  012054          	mov	#rpkt,r5		; block address
     668 020730                         	printf	#201$,#'r,r5,#-4,-4(r5),-2(r5) ; print header
       1 020730                         	calls	printf #201$ #'r r5 #-4 -4(r5) -2(r5)          
       9 020730 016546  177776          	mov	-2(r5),-(sp)
      15 020734 016546  177774          	mov	-4(r5),-(sp)
      21 020740 012746  177774          	mov	#-4,-(sp)
      27 020744 010546                  	mov	r5,-(sp)
      33 020746 012746  000162          	mov	#'r,-(sp)
      39 020752 012746  021104          	mov	#201$,-(sp)
       2 020756                         	call	printf
       1 020756 004737  022662          	jsr	pc,printf
       3 020762 062706  000014          	add	#14,sp
     669 020766                         	call	dumper			; print block
       1 020766 004737  021256          	jsr	pc,dumper
     670                                
     671 020772                         	resreg	r4,r5			; restore registers
       8 020772 012605                  	mov	(sp)+,r5
      13 020774 012604                  	mov	(sp)+,r4
     672 020776                         99$:	return				; and done
       1 020776 000207                  	rts	pc
     673                                
     674 021000    134     162     134  200$:	.asciz	"\r\ncomm @ %.6o\r\n%+6d  %.6o %.6o\r\n%+6o  %.6o %.6o %.6o %.6o\r\n"
         021003    156     143     157  
         021006    155     155     040  
         021011    100     040     045  
         021014    056     066     157  
         021017    134     162     134  
         021022    156     045     053  
         021025    066     144     040  
         021030    040     045     056  
         021033    066     157     040  
         021036    045     056     066  
         021041    157     134     162  
         021044    134     156     045  
         021047    053     066     157  
         021052    040     040     045  
         021055    056     066     157  
         021060    040     045     056  
         021063    066     157     040  
         021066    045     056     066  
         021071    157     040     045  
         021074    056     066     157  
         021077    134     162     134  
         021102    156     000          
     675 021104    134     162     134  201$:	.asciz	"\r\n%cpkt @ %.6o\r\n%+6d  %.6o %.6o\r\n"
         021107    156     045     143  
         021112    160     153     164  
         021115    040     100     040  
         021120    045     056     066  
         021123    157     134     162  
         021126    134     156     045  
         021131    053     066     144  
         021134    040     040     045  
         021137    056     066     157  
         021142    040     045     056  
         021145    066     157     134  
         021150    162     134     156  
         021153    000                  
     676                                	.even
     677                                
     678                                ; ---------------------------------------
     679                                
     680 021154 032737  000001  002002  dmpbuf:	bit	#bit0,optswi		; check if extra printout enabled
     681 021162 001421                  	beq	99$			; br if not
     682 021164                         	savreg	r4,r5			; save registers
       3 021164 010446                  	mov	r4,-(sp)
       8 021166 010546                  	mov	r5,-(sp)
     683                                
     684 021170 012704  000400          	mov	#256.,r4		; block size
     685 021174 012705  002034          	mov	#buffer,r5		; block address
     686 021200                         	printf	#200$,r5		; print header
       1 021200                         	calls	printf #200$ r5              
       9 021200 010546                  	mov	r5,-(sp)
      15 021202 012746  021230          	mov	#200$,-(sp)
       2 021206                         	call	printf
       1 021206 004737  022662          	jsr	pc,printf
       3 021212 062706  000004          	add	#4,sp
     687 021216                         	call	dumper			; print block
       1 021216 004737  021256          	jsr	pc,dumper
     688                                
     689 021222                         	resreg	r4,r5			; restore registers
       8 021222 012605                  	mov	(sp)+,r5
      13 021224 012604                  	mov	(sp)+,r4
     690 021226                         99$:	return				; and done
       1 021226 000207                  	rts	pc
     691                                
     692 021230    134     162     134  200$:	.asciz	"\r\nbuffer @ %.6o\r\n"
         021233    156     142     165  
         021236    146     146     145  
         021241    162     040     100  
         021244    040     045     056  
         021247    066     157     134  
         021252    162     134     156  
         021255    000                  
     693                                	.even
     694                                
     695                                ; --------------------------------------------------------------------------------
     696                                ;
     697                                ; ascii memory dump routine
     698                                ;
     699                                ;	call:	mov	#size,r4	; block size, words
     700                                ;		mov	#buffer,r5	; block address, byte
     701                                ;		call	dumper
     702                                ;
     703 021256                         dumper:	savreg	r0,r1,r2,r3,r4,r5	; save registers
       3 021256 010046                  	mov	r0,-(sp)
       8 021260 010146                  	mov	r1,-(sp)
      13 021262 010246                  	mov	r2,-(sp)
      18 021264 010346                  	mov	r3,-(sp)
      23 021266 010446                  	mov	r4,-(sp)
      28 021270 010546                  	mov	r5,-(sp)
     704 021272 005001                  	clr	r1			; word counter
     705 021274 010503                  	mov	r5,r3			; ptr to start of line
     706 021276 032701  000007          1$:	bit	#^b111,r1		; at start of line
     707 021302 001011                  	bne	2$			; br if not
     708 021304 006301                  	asl	r1			; make byte offset
     709 021306                         	printf	#205$,r1		; print line offset
       1 021306                         	calls	printf #205$ r1              
       9 021306 010146                  	mov	r1,-(sp)
      15 021310 012746  021515          	mov	#205$,-(sp)
       2 021314                         	call	printf
       1 021314 004737  022662          	jsr	pc,printf
       3 021320 062706  000004          	add	#4,sp
     710 021324 006201                  	asr	r1			; back to word offset
     711 021326                         2$:	printf	#201$,(r5)+		; print a word
       1 021326                         	calls	printf #201$ (r5)+              
       9 021326 012546                  	mov	(r5)+,-(sp)
      15 021330 012746  021474          	mov	#201$,-(sp)
       2 021334                         	call	printf
       1 021334 004737  022662          	jsr	pc,printf
       3 021340 062706  000004          	add	#4,sp
     712 021344 005201                  	inc	r1			; count words
     713 021346 032701  000007          	bit	#^b111,r1		; multiple of 8 per line
     714 021352 001037                  	bne	8$			; br if not
     715 021354                         	printf	#204$			; some space
       1 021354                         	calls	printf #204$               
       9 021354 012746  021512          	mov	#204$,-(sp)
       2 021360                         	call	printf
       1 021360 004737  022662          	jsr	pc,printf
       3 021364 062706  000002          	add	#2,sp
     716 021370 005002                  3$:	clr	r2			; zap
     717 021372 152302                  	bisb	(r3)+,r2		; get next character
     718 021374 120227  000040          	cmpb	r2,#<' >		; check for low end
     719 021400 002403                  	blt	5$			; br if illegal
     720 021402 120227  000176          	cmpb	r2,#<'~>		; check for high end
     721 021406 003402                  	ble	6$			; br if OK
     722 021410 012702  000056          5$:	mov	#<'.>,r2		; CTRL prints as '.'
     723 021414                         6$:	printf	#203$,r2		; print a character
       1 021414                         	calls	printf #203$ r2              
       9 021414 010246                  	mov	r2,-(sp)
      15 021416 012746  021507          	mov	#203$,-(sp)
       2 021422                         	call	printf
       1 021422 004737  022662          	jsr	pc,printf
       3 021426 062706  000004          	add	#4,sp
     724 021432 020305                  	cmp	r3,r5			; at next line?
     725 021434 103755                  	blo	3$			; br if not yet
     726 021436                         	printf	#202$			; yes, end the line
       1 021436                         	calls	printf #202$               
       9 021436 012746  021502          	mov	#202$,-(sp)
       2 021442                         	call	printf
       1 021442 004737  022662          	jsr	pc,printf
       3 021446 062706  000002          	add	#2,sp
     727 021452 020104                  8$:	cmp	r1,r4			; hit end of block
     728 021454 001310                  	bne	1$			; br if not yet
     729 021456                         	resreg	r0,r1,r2,r3,r4,r5	; restore registers
       8 021456 012605                  	mov	(sp)+,r5
      13 021460 012604                  	mov	(sp)+,r4
      18 021462 012603                  	mov	(sp)+,r3
      23 021464 012602                  	mov	(sp)+,r2
      28 021466 012601                  	mov	(sp)+,r1
      33 021470 012600                  	mov	(sp)+,r0
     730 021472                         	return				; and done
       1 021472 000207                  	rts	pc
     731                                
     732 021474    040     045     056  201$:	.asciz	" %.6o"
         021477    066     157     000  
     733 021502    134     162     134  202$:	.asciz	"\r\n"
         021505    156     000          
     734 021507    045     143     000  203$:	.asciz	"%c"
     735 021512    040     040     000  204$:	.asciz	"  "
     736 021515    045     053     066  205$:	.asciz	"%+6o "
         021520    157     040     000  
     737 021523    000                  	.even
     738                                
     739                                ; --------------------------------------------------------------------------------
     740                                ;
     741                                ; MSCP controller init routine
     742                                ;
     743                                ;	call:	call	init
     744                                ;
     745 021524 012705  022010          init:	mov	#50$,r5			; data structure
     746                                
     747 021530 013704  002012          	mov	csr$ip,r4		; base csr address (IP)
     748 021534 005024                  	clr	(r4)+			; start init sequence, bump to (SA)
     749                                
     750                                	; ==> wait for SA step N
     751                                
     752 021536 011403                  10$:	mov	(r4),r3			; check SA contents
     753 021540 100013                  	bpl	11$			; ER error bit clear
     754                                
     755 021542                         	printf	#71$,(r5),r3		; format, expected, received
       1 021542                         	calls	printf #71$ (r5) r3             
       9 021542 010346                  	mov	r3,-(sp)
      15 021544 011546                  	mov	(r5),-(sp)
      21 021546 012746  022062          	mov	#71$,-(sp)
       2 021552                         	call	printf
       1 021552 004737  022662          	jsr	pc,printf
       3 021556 062706  000006          	add	#6,sp
     756 021562 005237  002016          	inc	errors			; incre error count
     757 021566 000503                  	br	39$			; exit
     758                                
     759 021570 036503  000002          11$:	bit	2(r5),r3		; check other state bits clear
     760 021574 001413                  	beq	12$			; br if OK
     761                                
     762 021576                         	printf	#72$,(r5),r3		; format, expected, received
       1 021576                         	calls	printf #72$ (r5) r3             
       9 021576 010346                  	mov	r3,-(sp)
      15 021600 011546                  	mov	(r5),-(sp)
      21 021602 012746  022171          	mov	#72$,-(sp)
       2 021606                         	call	printf
       1 021606 004737  022662          	jsr	pc,printf
       3 021612 062706  000006          	add	#6,sp
     763 021616 005237  002016          	inc	errors			; incre error count
     764 021622 000465                  	br	39$			; exit
     765                                
     766 021624 031503                  12$:	bit	(r5),r3			; check current state bit set
     767 021626 001743                  	beq	10$			; br if not yet
     768                                
     769                                	; SA step N - response at 0->1 transition
     770                                
     771 021630 020365  000004          	cmp	r3,4(r5)		; check rcv:exp
     772 021634 001414                  	beq	13$			; br if OK
     773                                
     774 021636                         	printf	#73$,(r5),4(r5),r3	; format, state, expected, received
       1 021636                         	calls	printf #73$ (r5) 4(r5) r3            
       9 021636 010346                  	mov	r3,-(sp)
      15 021640 016546  000004          	mov	4(r5),-(sp)
      21 021644 011546                  	mov	(r5),-(sp)
      27 021646 012746  022305          	mov	#73$,-(sp)
       2 021652                         	call	printf
       1 021652 004737  022662          	jsr	pc,printf
       3 021656 062706  000010          	add	#10,sp
     775 021662 005237  002016          	inc	errors			; incre error count
     776                                
     777                                	; SA step N - send
     778                                
     779 021666 016514  000006          13$:	mov	6(r5),(r4)		; set step N send data
     780                                
     781                                	; SA step N - step complete at 1->0 transition
     782                                
     783 021672 016537  000010  002030  	mov	10(r5),dlycnt		; state must complete in this time
     784                                
     785 021700 005737  002030          14$:	tst	dlycnt			; has delay count expired?
     786 021704 003012                  	bgt	15$			; not yet
     787                                
     788 021706                         	printf	#74$,(r5)		; format, state
       1 021706                         	calls	printf #74$ (r5)              
       9 021706 011546                  	mov	(r5),-(sp)
      15 021710 012746  022434          	mov	#74$,-(sp)
       2 021714                         	call	printf
       1 021714 004737  022662          	jsr	pc,printf
       3 021720 062706  000004          	add	#4,sp
     789 021724 005237  002016          	inc	errors			; incre error count
     790 021730 000422                  	br	39$			; exit
     791                                
     792 021732 031514                  15$:	bit	(r5),(r4)		; check current state bit cleared
     793 021734 001361                  	bne	14$			; loop if still set	
     794                                
     795 021736 062705  000012          	add	#51$-50$,r5		; next state
     796 021742 005715                  	tst	(r5)			; more states?
     797 021744 001274                  	bne	10$			; br if yes
     798                                
     799 021746 012705  012034          	mov	#comm-4,r5		; ptr to comm structure
     800                                
     801 021752 005025                  	clr	(r5)+			; cmd intr
     802 021754 005025                  	clr	(r5)+			; resp intr
     803 021756 012725  012054          	mov	#rpkt,(r5)+		; resp pkt addr
     804 021762 005025                  	clr	(r5)+			; resp host own
     805 021764 012725  012140          	mov	#cpkt,(r5)+		; cmd pkt addr
     806 021770 005025                  	clr	(r5)+			; cmd host own
     807                                	
     808 021772 000261                  	sec				; indicate OK
     809 021774                         	return				; done, controller is ready
       1 021774 000207                  	rts	pc
     810                                
     811                                	; ==> done, reset controller and exit
     812                                
     813 021776 012777  000000  160006  39$:	mov	#0,@csr$ip		; reset controller
     814 022004 000241                  	clc				; indicate ERROR
     815 022006                         	return				; done
       1 022006 000207                  	rts	pc
     816                                
     817                                	; - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     818                                
     819                                	; step 1
     820                                
     821 022010 004000  070000          50$:	.word	sa_st1, sa_st2+sa_st3+sa_st4
     822 022014 004400                  	.word	sa_st1+<0*sa_nsv>+<0*sa_a22>+<1*sa_edp>+<sa_opt*sa_rs0>
     823 022016 100000                  	.word	sa_stp+<0*sa_cl0>+<0*sa_rl0>+<0*sa_int>+<0*sa_vec>
     824 022020 001130                  	.word	10.*60.
     825                                
     826                                	; step 2
     827                                
     828 022022 010000  064000          51$:	.word	sa_st2, sa_st1+sa_st3+sa_st4
     829 022026 010200                  	.word	sa_st2+<0*sa_cty>+<1*sa_ste>+<0*sa_cle>+<0*sa_rle>
     830 022030 012040                  	.word	comm+<0*sa_prg>
     831 022032 001130                  	.word	10.*60.
     832                                	
     833                                	; step 3
     834                                
     835 022034 020000  054000          52$:	.word	sa_st3, sa_st1+sa_st2+sa_st4
     836 022040 020000                  	.word	sa_st3+<0*sa_vpe>+<0*sa_ine>+<0*sa_vee>
     837 022042 000000                  	.word	<0*sa_ppt>+<0*sa_rgh>
     838 022044 001130                  	.word	10.*60.
     839                                
     840                                	; step 4
     841                                
     842 022046 040000  034000          53$:	.word	sa_st4, sa_st1+sa_st2+sa_st3
     843 022052 040066                  	.word	sa_st4+<sa_ctyp*sa_cn0>+<sa_ucv*sa_mc0>
     844 022054 000001                  	.word	<1*sa_go>
     845 022056 001130                  	.word	10.*60.
     846                                
     847 022060 000000                  54$:	.word	0
     848                                
     849                                	; - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     850                                
     851 022062    111     116     111  71$:	.ascii	"INIT: init ER bit set in SA register"<cr><lf>
         022065    124     072     040  
         022070    151     156     151  
         022073    164     040     105  
         022076    122     040     142  
         022101    151     164     040  
         022104    163     145     164  
         022107    040     151     156  
         022112    040     123     101  
         022115    040     162     145  
         022120    147     151     163  
         022123    164     145     162  
         022126    015     012          
     852 022130    040     040     105  	.ascii	"  Exp'ed  Rcv'ed"<cr><lf>
         022133    170     160     047  
         022136    145     144     040  
         022141    040     122     143  
         022144    166     047     145  
         022147    144     015     012  
     853 022152    040     040     045  	.asciz	"  %.6o  %.6o"<cr><lf>
         022155    056     066     157  
         022160    040     040     045  
         022163    056     066     157  
         022166    015     012     000  
     854 022171    111     116     111  72$:	.ascii	"INIT: S1-S4 sequence error in SA register"<cr><lf>
         022174    124     072     040  
         022177    123     061     055  
         022202    123     064     040  
         022205    163     145     161  
         022210    165     145     156  
         022213    143     145     040  
         022216    145     162     162  
         022221    157     162     040  
         022224    151     156     040  
         022227    123     101     040  
         022232    162     145     147  
         022235    151     163     164  
         022240    145     162     015  
         022243    012                  
     855 022244    040     040     105  	.ascii	"  Exp'ed  Rcv'ed"<cr><lf>
         022247    170     160     047  
         022252    145     144     040  
         022255    040     122     143  
         022260    166     047     145  
         022263    144     015     012  
     856 022266    040     040     045  	.asciz	"  %.6o  %.6o"<cr><lf>
         022271    056     066     157  
         022274    040     040     045  
         022277    056     066     157  
         022302    015     012     000  
     857 022305    111     116     111  73$:	.ascii	"INIT: step response data compare error"<cr><lf>
         022310    124     072     040  
         022313    163     164     145  
         022316    160     040     162  
         022321    145     163     160  
         022324    157     156     163  
         022327    145     040     144  
         022332    141     164     141  
         022335    040     143     157  
         022340    155     160     141  
         022343    162     145     040  
         022346    145     162     162  
         022351    157     162     015  
         022354    012                  
     858 022355    040     040     123  	.ascii	"  StpBit  Exp'ed  Rcv'ed"<cr><lf>
         022360    164     160     102  
         022363    151     164     040  
         022366    040     105     170  
         022371    160     047     145  
         022374    144     040     040  
         022377    122     143     166  
         022402    047     145     144  
         022405    015     012          
     859 022407    040     040     045  	.asciz	"  %.6o  %.6o  %.6o"<cr><lf>
         022412    056     066     157  
         022415    040     040     045  
         022420    056     066     157  
         022423    040     040     045  
         022426    056     066     157  
         022431    015     012     000  
     860 022434    111     116     111  74$:	.ascii	"INIT: step response timeout error"<cr><lf>
         022437    124     072     040  
         022442    163     164     145  
         022445    160     040     162  
         022450    145     163     160  
         022453    157     156     163  
         022456    145     040     164  
         022461    151     155     145  
         022464    157     165     164  
         022467    040     145     162  
         022472    162     157     162  
         022475    015     012          
     861 022477    040     040     123  	.ascii	"  StpBit"<cr><lf>
         022502    164     160     102  
         022505    151     164     015  
         022510    012                  
     862 022511    040     040     045  	.asciz	"  %.6o"<cr><lf>
         022514    056     066     157  
         022517    015     012     000  
     863                                	.even
     864                                
     865                                ; --------------------------------------------------------------------------------
     866                                ;
     867                                ; MSCP controller buffer init, set cmnd/resp to all zeroes
     868                                ;
     869                                ;	call:	call	bufini
     870                                ;
     871 022522                         bufini:	savreg	r5			; save registers
       3 022522 010546                  	mov	r5,-(sp)
     872                                
     873 022524 012705  012050          	mov	#rpkt+p_len,r5		; address
     874 022530 005025                  1$:	clr	(r5)+			; zap a word
     875 022532 020527  012134          	cmp	r5,#rend		; at end?
     876 022536 103774                  	blo	1$			; br if not yet
     877 022540 012737  000060  012050  	mov	#rlen,rpkt+p_len	; set buffer size
     878                                
     879 022546 012705  012134          	mov	#cpkt+p_len,r5		; address
     880 022552 005025                  2$:	clr	(r5)+			; zap a word
     881 022554 020527  012220          	cmp	r5,#cend		; at end?
     882 022560 103774                  	blo	2$			; br if not yet
     883 022562 012737  000060  012134  	mov	#clen,cpkt+p_len	; set buffer size
     884                                
     885 022570 112737  000001  012137  	movb	#tstcid,cpkt+p_cid	; set connection id
     886 022576 112737  000000  012136  	movb	#0,cpkt+p_type		; set msg type, credits
     887                                
     888 022604                         	resreg	r5			; restore
       8 022604 012605                  	mov	(sp)+,r5
     889 022606                         	return				; done
       1 022606 000207                  	rts	pc
     890                                
     891                                ; --------------------------------------------------------------------------------
     892                                
     893                                .include "mac/adrchk.mac"
       1                                ;================================================================================
       2                                ; adrchk.mac - routine to check if a physical address exists
       3                                ; (C) 2009 Donald North. All rights reserved.
       4                                ;================================================================================
       5                                ;
       6                                ; address check routine
       7                                ;
       8                                ;	call:	mov	#addr,r0
       9                                ;		call	adrchk
      10                                ;		bcc	we_trapped
      11                                ;		bcs	no_trap
      12                                ;
      13 022610 010546                  adrchk::mov	r5,-(sp)		; save registers
      14                                
      15 022612 013746  000004          	mov	@#4,-(sp)		; save old vector
      16 022616 013746  000006          	mov	@#6,-(sp)		;
      17 022622 010605                  	mov	sp,r5			; save sp here
      18                                
      19 022624 012737  022644  000004  	mov	#1$,@#4  		; if we timeout go here
      20 022632 005037  000006          	clr	@#6			; next psw if we trap
      21                                
      22 022636 000241                  	clc				; C=0 means we trapped
      23 022640 005710                  	tst	(r0)			; test the address, may trap
      24 022642 000261                  	sec				; C=1 means no trap
      25                                
      26 022644 010506                  1$:	mov	r5,sp			; restore stack
      27 022646 012637  000006          	mov	(sp)+,@#6		; restore old vector
      28 022652 012637  000004          	mov	(sp)+,@#4		;
      29                                
      30 022656 012605                  	mov	(sp)+,r5		; restore registers
      31 022660                         	return				; done
       1 022660 000207                  	rts	pc
      32                                
      33                                ;================================================================================
      34                                ; end of adrchk.mac
      35                                ;================================================================================
      35                                
     894                                .include "mac/printf.mac"
       1                                ;================================================================================
       2                                ; printf.mac - printf routines for macro11 diagnostics
       3                                ; (C) 2009-2016 Donald North. All rights reserved.
       4                                ;================================================================================
       5                                
       6                                .if ndf ttxcsr
       7                                	
       8                                	; separate psect (if console registers not defined)
       9                                	.psect	printf
      10                                
      11                                	; external tty references
      12                                	.globl	ttxcsr, ttxbuf
      13                                
      14                                	; standard macro definitions
      15                                 	.include "mac/stddef.mac"
      16                                
      17                                pf.sep	=1 ; flag separate compilation
      18                                
      19                                .iff
      20                                
      21        000000                  pf.sep	=0 ; flag unified compilation (via include)
      22                                	
      23                                .endc
      24                                ; 
      25                                ; global registers:
      26                                ;
      27                                ;  R5 - frame pointer
      28                                ;  R4 - argument pointer
      29                                ;  R3 - format string pointer
      30                                ;  R2 - current format character
      31                                ;  R1 - temp
      32                                ;  R0 - temp
      33                                ;
      34                                ; note:	for 11/04-05-10 compatibility, do NOT use SXT/XOR/SOB and MUL/DIV/ASH/ASHC
      35                                ; 
      36                                ; offsets from frame pointer (r5):
      37                                ; 
      38        000012                  p.sr0	=+10.	; saved r0
      39        000010                  p.sr1	=+8.	; saved r1
      40        000006                  p.sr2	=+6.	; saved r2
      41        000004                  p.sr3	=+4.	; saved r3
      42        000002                  p.sr4	=+2.	; saved r4
      43        000000                  p.sr5	=+0.	; saved r5
      44        177777                  p.flg	=-1.	; format flags (byte)
      45        177776                  p.fil	=-2.	; fill character (byte)
      46        177774                  p.wid	=-4.	; format numeric width (word)
      47        177772                  p.pre	=-6.	; format numeric precision (word)
      48        177770                  p.len	=-8.	; number of digits generated (word)
      49        177766                  p.out	=-10.	; addr(char print routine)
      50        177764                  p.ptr	=-12.	; sprintf output buffer pointer
      51                                ; 
      52        000014                  n.last	=+12.	; number of bytes allocated on stack
      53        000016                  n.args	=+14.	; offset to first argument on stack
      54                                ; 
      55                                ; bits in p.flg byte:
      56                                ; 
      57        000001                  pf.ljus	=1	; set for left justified ('-' seen)
      58        000002                  pf.sign	=2	; set for sign requested ('+' seen)
      59        000004                  pf.altf	=4	; set for alt flag ('#' seen)
      60        000010                  pf.long	=10	; set for long value (%...l. seen)
      61        000020                  pf.nega	=20	; set for negative value (msb set)
      62                                
      63                                ; --------------------------------------------------------------------------------
      64                                ;
      65                                ; printf routine .. 'C' printf(format,arg1,arg2,..,argn) ..  called in 'C' style
      66                                ;
      67                                ;	call:	mov	argN,-(sp)
      68                                ;		...
      69                                ;		mov	arg2,-(sp)
      70                                ;		mov	arg1,-(sp)
      71                                ;		mov	format,-(sp)
      72                                ;		call	printf
      73                                ;		add	#2*N,sp
      74                                ;
      75 022662 010046                  printf::mov	r0,-(sp)		; save reg
      76 022664 010146                  	mov	r1,-(sp)		;
      77 022666 010246                  	mov	r2,-(sp)		;
      78 022670 010346                  	mov	r3,-(sp)		;
      79 022672 010446                  	mov	r4,-(sp)		;
      80 022674 010546                  	mov	r5,-(sp)		;
      81                                	
      82 022676 010605                  	mov	sp,r5			; frame pointer
      83 022700 162706  000014          	sub	#n.last,sp		; reserve space on stack
      84                                	
      85 022704 010504                  	mov	r5,r4			; get frame ptr
      86 022706 062704  000016          	add	#n.args,r4		; offset to first argument
      87                                	
      88 022712 012765  022726  177766  	mov	#1$,p.out(r5)		; character output routine
      89 022720 005065  177764          	clr	p.ptr(r5)		; bufptr not used here
      90                                	
      91 022724 000442                  	br	xprintf			; continue
      92                                
      93                                	; ---------------------------------------------------------
      94                                	
      95                                	; character output to console
      96                                	
      97 022726 105737  177564          1$:	tstb	@#ttxcsr		; check if ready
      98 022732 100375                  	bpl	1$			; not yet
      99 022734 110037  177566          	movb	r0,@#ttxbuf		; send character
     100 022740                         	return				; return
       1 022740 000207                  	rts	pc
     101                                	
     102                                ; --------------------------------------------------------------------------------
     103                                ;
     104                                ; sprintf routine .. 'C' sprintf(buffer,format,arg1,arg2,..,argn) ..  called in 'C' style
     105                                ;
     106                                ;	call:	mov	argN,-(sp)
     107                                ;		...
     108                                ;		mov	arg2,-(sp)
     109                                ;		mov	arg1,-(sp)
     110                                ;		mov	format,-(sp)
     111                                ;		mov	buffer,-(sp)
     112                                ;		call	sprintf
     113                                ;		add	#2*N,sp
     114                                ;
     115 022742 010046                  sprintf::mov	r0,-(sp)		; save reg
     116 022744 010146                  	mov	r1,-(sp)		;
     117 022746 010246                  	mov	r2,-(sp)		;
     118 022750 010346                  	mov	r3,-(sp)		;
     119 022752 010446                  	mov	r4,-(sp)		;
     120 022754 010546                  	mov	r5,-(sp)		;
     121                                	
     122 022756 010605                  	mov	sp,r5			; frame pointer
     123 022760 162706  000014          	sub	#n.last,sp		; reserve space on stack
     124                                	
     125 022764 010504                  	mov	r5,r4			; get frame ptr
     126 022766 062704  000016          	add	#n.args,r4		; offset to first argument
     127                                	
     128 022772 012765  023006  177766  	mov	#1$,p.out(r5)		; character output routine
     129 023000 012465  177764          	mov	(r4)+,p.ptr(r5)		; init bufptr from argument
     130                                	
     131 023004 000412                  	br	xprintf			; continue
     132                                
     133                                	; ---------------------------------------------------------
     134                                	
     135                                	; character output to buffer
     136                                	
     137 023006 110075  177764          1$:	movb	r0,@p.ptr(r5)		; store character
     138 023012 005265  177764          	inc	p.ptr(r5)		; bump pointer
     139 023016 105075  177764          	clrb	@p.ptr(r5)		; null terminate
     140 023022 016565  177764  000012  	mov	p.ptr(r5),p.sr0(r5)	; return updated ptr in saved r0
     141 023030                         	return				; return
       1 023030 000207                  	rts	pc
     142                                	
     143                                ; --------------------------------------------------------------------------------
     144                                
     145                                	; process main format
     146                                
     147 023032 012403                  xprintf:mov	(r4)+,r3		; prime format string pointer
     148                                
     149 023034                         1$:	call	900$			; get next format character
       1 023034 004737  023744          	jsr	pc,900$
     150 023040 120227  000045          	cmpb	r2,#<'%>		; hit a format flag?
     151 023044 001430                  	beq	10$			; yes, go process
     152 023046 120227  000134          	cmpb	r2,#<'\>		; hit an escape flag?
     153 023052 001404                  	beq	3$			; yes, go process
     154 023054 010200                  2$:	mov	r2,r0			; char to print
     155 023056                         	call	@p.out(r5)		; no, just print it
       1 023056 004775  177766          	jsr	pc,@p.out(r5)
     156 023062 000764                  	br	1$			; loop
     157                                
     158                                	; process escaped character \a .. \z
     159                                
     160 023064                         3$:	call	900$			; get the escaped character
       1 023064 004737  023744          	jsr	pc,900$
     161 023070 002771                  	blt	2$			; quick exit for [NUL-@] range
     162 023072 120227  000172          	cmpb	r2,#<'z>		;
     163 023076 003366                  	bgt	2$			; exit if [{-DEL]
     164 023100 120227  000141          	cmpb	r2,#<'a>		;
     165 023104 002005                  	bge	4$			; br if [a-z]	
     166 023106 120227  000132          	cmpb	r2,#<'Z>		;
     167 023112 003360                  	bgt	2$			; br if [[-`]
     168 023114 152702  000040          	bisb	#40,r2			; force to [a-z] range
     169 023120 116202  023641          4$:	movb	1000$-<'a>(r2),r2	; translate a..z to escaped
     170 023124 000753                  	br	2$			; go print
     171                                
     172                                	; process format flag %[-+]?(0?\d+([.]\d+)?)?[lh]?[iduscpxo]
     173                                
     174 023126 112765  000040  177776  10$:	movb	#<' >,p.fil(r5)		; blank fill
     175 023134 105065  177777          	clrb	p.flg(r5)		; clear flags
     176 023140 005065  177774          	clr	p.wid(r5)		; init width spec
     177 023144 005065  177772          	clr	p.pre(r5)		; init precision spec
     178 023150 005065  177770          	clr	p.len(r5)		; no digits yet
     179                                
     180 023154                         11$:	call	900$			; get next format character
       1 023154 004737  023744          	jsr	pc,900$
     181 023160 002045                  	bge	40$			; br if [A-DEL]
     182 023162 120227  000045          	cmpb	r2,#<'%>		; check for '%'
     183 023166 001732                  	beq	2$			; br if yes
     184                                
     185                                	; some character in range [NUL-@]
     186                                
     187 023170 120227  000055          	cmpb	r2,#<'->		; check for '-'
     188 023174 001004                  	bne	12$			; br if not
     189 023176 152765  000001  177777  	bisb	#pf.ljus,p.flg(r5)	; yes, set a flag
     190 023204 000763                  	br	11$			; loop
     191 023206 120227  000053          12$:	cmpb	r2,#<'+>		; check for '+'
     192 023212 001004                  	bne	13$			; br if not
     193 023214 152765  000002  177777  	bisb	#pf.sign,p.flg(r5)	; yes, set a flag
     194 023222 000754                  	br	11$			; loop
     195 023224 120227  000043          13$:	cmpb	r2,#<'#>		; check for '#'
     196 023230 001004                  	bne	20$			; br if not
     197 023232 152765  000004  177777  	bisb	#pf.altr,p.flg(r5)	; yes, set a flag
     198 023240 000745                  	br	11$			; loop
     199                                
     200 023242                         20$:	call	800$			; get a number if present
       1 023242 004737  023650          	jsr	pc,800$
     201 023246 010165  177774          	mov	r1,p.wid(r5)		; save number as width
     202                                
     203 023252 120227  000056          	cmpb	r2,#<'.>		; check for .
     204 023256 001006                  	bne	40$			; br if not, should be alpha
     205 023260                         	call	900$			; get next character
       1 023260 004737  023744          	jsr	pc,900$
     206                                
     207 023264                         	call	800$			; get a number if present
       1 023264 004737  023650          	jsr	pc,800$
     208 023270 010165  177772          	mov	r1,p.pre(r5)		; save number as precision
     209                                
     210                                	; flag is in range [A-Za-z]
     211                                
     212 023274 005000                  40$:	clr	r0			; zap numerics
     213 023276 005001                  	clr	r1			;
     214 023300 120227  000101          41$:	cmpb	r2,#<'A>		; check for [:-@]
     215 023304 002663                  	blt	2$			; br if yes
     216 023306 120227  000172          	cmpb	r2,#<'z>		; check for [{-DEL]
     217 023312 003260                  	bgt	2$			; br if yes
     218 023314 120227  000141          	cmpb	r2,#<'a>		; check for [a-z]
     219 023320 002003                  	bge	42$			; br if yes
     220 023322 120227  000132          	cmpb	r2,#<'Z>		; check for [A-Z]
     221 023326 003252                  	bgt	2$			; br if no
     222 023330 042702  000040          42$:	bic	#40,r2			; force to [a-z] to [A-Z] range
     223 023334 012401                  	mov	(r4)+,r1		; get the next value as lsb
     224 023336 006302                  	asl	r2			; char*2 for word offset
     225 023340 000172  023142          	jmp	@400$-<2*'A>(r2)	; dispatch
     226                                
     227                                400$:	;----	aaaa,bbbb,cccc,dddd,eeee,ffff,gggg,hhhh,iiii,jjjj,kkkk,llll,mmmm
     228 023344 023430  023634  023474  	.word	401$,470$,420$,430$,401$,401$,401$,401$,430$,401$,401$,405$,401$
         023352 023514  023430  023430  
         023360 023430  023430  023514  
         023366 023430  023430  023444  
         023374 023430                  
     229                                	;----	nnnn,oooo,pppp,qqqq,rrrr,ssss,tttt,uuuu,vvvv,wwww,xxxx,yyyy,zzzz
     230 023376 023430  023604  023604  	.word	401$,450$,450$,401$,401$,410$,401$,440$,401$,401$,460$,401$,401$
         023404 023430  023430  023462  
         023412 023430  023570  023430  
         023420 023430  023620  023430  
         023426 023430                  
     231                                
     232 023430 005744                  401$:	tst	-(r4)			; %<illegal>: backup argument pointer
     233 023432 005002                  	clr	r2			; zap
     234 023434 156302  177777          	bisb	-1(r3),r2		; retrieve last character
     235 023440 000137  023054          	jmp	2$			; just go print
     236                                
     237 023444                         405$:	call	900$			; %l: get next character
       1 023444 004737  023744          	jsr	pc,900$
     238 023450 152765  000010  177777  	bisb	#pf.long,p.flg(r5)	; indicate longword value
     239 023456 010100                  	mov	r1,r0			; copy 1st arg to msb
     240 023460 000707                  	br	41$			; and go parse next flag
     241                                
     242 023462 010102                  410$:	mov	r1,r2			; %s: get next arg as string address
     243 023464                         	call	prtstr			; print as a string
       1 023464 004737  024404          	jsr	pc,prtstr
     244 023470 000137  023034          	jmp	1$			; continue at the top
     245                                
     246 023474 005046                  420$:	clr	-(sp)			; %c: zap upper byte
     247 023476 110116                  	movb	r1,(sp)			; insert the character
     248 023500 010602                  	mov	sp,r2			; point at string
     249 023502                         	call	prtstr			; print as a string
       1 023502 004737  024404          	jsr	pc,prtstr
     250 023506 005726                  	tst	(sp)+			; flush temp string
     251 023510 000137  023034          	jmp	1$			; continue at the top
     252                                
     253 023514 012702  000012          430$:	mov	#10.,r2			; %d,%i: decimal radix
     254 023520 132765  000010  177777  	bitb	#pf.long,p.flg(r5)	; longword value?
     255 023526 001004                  	bne	431$			; br if yes
     256 023530 005000                  	clr	r0			; zap
     257 023532 005701                  	tst	r1			; no; test lsb sign
     258 023534 100001                  	bpl	431$			; br if plus/zero
     259 023536 005100                  	com	r0			; extend -1 to msb
     260 023540 005700                  431$:	tst	r0			; test msb sign
     261 023542 002006                  	bge	439$			; br if zero or positive
     262 023544 005400                  	neg	r0			; negative; make positive
     263 023546 005401                  	neg	r1			;
     264 023550 005600                  	sbc	r0			;
     265 023552 152765  000020  177777  	bisb	#pf.nega,p.flg(r5)	; set flag indicating negative
     266 023560                         439$:	call	prt32u			; print as unsigned decimal w/sign
       1 023560 004737  024034          	jsr	pc,prt32u
     267 023564 000137  023034          	jmp	1$			; continue at the top
     268                                
     269 023570 012702  000012          440$:	mov	#10.,r2			; %u: decimal radix
     270 023574                         	call	prt32u			; print as an unsigned decimal
       1 023574 004737  024034          	jsr	pc,prt32u
     271 023600 000137  023034          	jmp	1$			; continue at the top
     272                                
     273 023604 012702  000010          450$:	mov	#8.,r2			; %o,%p: octal radix
     274 023610                         	call	prt32u			; print as an unsigned hex
       1 023610 004737  024034          	jsr	pc,prt32u
     275 023614 000137  023034          	jmp	1$			; continue at the top
     276                                
     277 023620 012702  000020          460$:	mov	#16.,r2			; %x: hexadecimal radix
     278 023624                         	call	prt32u			; print as an unsigned hex
       1 023624 004737  024034          	jsr	pc,prt32u
     279 023630 000137  023034          	jmp	1$			; continue at the top
     280                                
     281 023634 012702  000002          470$:	mov	#2.,r2			; %b: binary radix
     282 023640                         	call	prt32u			; print as an unsigned binary
       1 023640 004737  024034          	jsr	pc,prt32u
     283 023644 000137  023034          	jmp	1$			; continue at the top
     284                                
     285                                	; ---------------------------------------------------------
     286                                	; get a number as '[0-9]+' or '*'
     287                                
     288 023650 120227  000052          800$:	cmpb	r2,#<'*>		; check for '*' indirection
     289 023654 001427                  	beq	880$			; br if yes
     290 023656 120227  000060          	cmpb	r2,#<'0>		; check for leading '0' character
     291 023662 001002                  	bne	810$			; br if not
     292 023664 110265  177776          	movb	r2,p.fil(r5)		; yes, set a flag
     293 023670 005001                  810$:	clr	r1			; number accumulated here
     294 023672 120227  000060          820$:	cmpb	r2,#<'0>		; check for '0'
     295 023676 002421                  	blt	890$			; br if less that a '0'
     296 023700 120227  000071          	cmpb	r2,#<'9>		; check for '9'
     297 023704 003016                  	bgt	890$			; br if greater than '9'
     298 023706 162702  000060          	sub	#<'0>,r2		; offset to range 0..9
     299 023712 006301                  	asl	r1			; number *= 2.
     300 023714 010100                  	mov	r1,r0			; (number*2.)
     301 023716 006300                  	asl	r0			; (number*4.)
     302 023720 006300                  	asl	r0			; (number*8.)
     303 023722 060001                  	add	r0,r1			; number = number*8. + number*2.
     304 023724 060201                  	add	r2,r1			; add in this digit
     305 023726                         	call	900$			; get next format character
       1 023726 004737  023744          	jsr	pc,900$
     306 023732 000757                  	br	820$			; and loop
     307 023734 012401                  880$:	mov	(r4)+,r1		; get next arg as number
     308 023736                         	call	900$			; get next character
       1 023736 004737  023744          	jsr	pc,900$
     309 023742                         890$:	return				; return
       1 023742 000207                  	rts	pc
     310                                
     311                                	; ---------------------------------------------------------
     312                                	; get next character (or exit) routine; result in r2
     313                                
     314 023744 112302                  900$:	movb	(r3)+,r2		; get next format character
     315 023746 042702  177600          	bic	#^c177,r2		; 7bit ascii only
     316 023752 001403                  	beq	990$			; end of string seen
     317 023754 120227  000101          	cmpb	r2,#<'A>		; check for [A-DEL]
     318 023760                         	return				; leave CC set with result
       1 023760 000207                  	rts	pc
     319                                
     320 023762 010506                  990$:	mov	r5,sp			; flush frame
     321 023764 012605                  	mov	(sp)+,r5		; restore reg
     322 023766 012604                  	mov	(sp)+,r4		;
     323 023770 012603                  	mov	(sp)+,r3		;
     324 023772 012602                  	mov	(sp)+,r2		;
     325 023774 012601                  	mov	(sp)+,r1		;
     326 023776 012600                  	mov	(sp)+,r0		;
     327 024000                         	return				; return
       1 024000 000207                  	rts	pc
     328                                
     329                                	; ---------------------------------------------------------
     330                                	; escaped character table
     331                                1000$:	;	aaa bbb ccc ddd eee fff ggg hhh iii jjj kkk lll mmm
     332                                	;	BEL  BS         ESC  FF
     333 024002    007     010     143  	.byte	007,010,143,144,033,014,147,150,151,152,153,154,155
         024005    144     033     014  
         024010    147     150     151  
         024013    152     153     154  
         024016    155                  
     334                                	;	nnn ooo ppp qqq rrr sss ttt uuu vvv www xxx yyy zzz
     335                                	;	 LF              CR      HT      VT
     336 024017    012     157     160  	.byte	012,157,160,161,015,163,011,165,013,167,170,172,172
         024022    161     015     163  
         024025    011     165     013  
         024030    167     170     172  
         024033    172                  
     337                                	; ---------------------------------------------------------
     338                                
     339                                ; --------------------------------------------------------------------------------
     340                                ;
     341                                ; digit print routine .. print a 32b value as unsigned digits
     342                                ;
     343                                ;	call:	mov	datahi,r0
     344                                ;		mov	datalo,r1
     345                                ;		mov	#radix,r2 ; 2. or 8. or 10. or 16.
     346                                ;		call	prt32u
     347                                ;
     348                                ;		r0 - data msb      (not saved)
     349                                ;		r1 - data lsb      (not saved)
     350                                ;		r2 - radix         (not saved)
     351                                ;		r3 - ptr to format     (saved)
     352                                ;		r4 - ptr to arglist    (saved) [input not used]
     353                                ;		r5 - ptr to flags      (saved)
     354                                ;
     355 024034 010346                  prt32u:	mov	r3,-(sp)		; save regs we use
     356 024036 010446                  	mov	r4,-(sp)		;
     357                                
     358                                	; render all the digits onto the stack (lsd first, msd last)
     359                                
     360 024040 005046                  	clr	-(sp)			; zero flag
     361 024042 010246                  1$:	mov	r2,-(sp)		; radix lsb
     362 024044 005046                  	clr	-(sp)			;   and msb
     363 024046 010146                  	mov	r1,-(sp)		; number lsb
     364 024050 010046                  	mov	r0,-(sp)		;    and msb
     365 024052                         	call	uldiv			; get quo and rem
       1 024052 004737  024652          	jsr	pc,uldiv
     366 024056 016602  000006          	mov	6.(sp),r2		; restore radix from stack
     367 024062 062706  000010          	add	#8.,sp			; flush args
     368 024066 062703  000060          	add	#<'0>,r3		; make rem lsb a digit
     369 024072 020327  000071          	cmp	r3,#<'9>		; still a valid digit?
     370 024076 003402                  	ble	2$			; br if yes
     371 024100 062703  000007          	add	#<'A>-<':>,r3		; offset to 'A...'Z range
     372 024104 010346                  2$:	mov	r3,-(sp)		; save
     373 024106 005265  177770          	inc	p.len(r5)		; count digits
     374 024112 005701                  	tst	r1			; any lsb left?
     375 024114 001352                  	bne	1$			; br if yes
     376 024116 005700                  	tst	r0			; any msb left?
     377 024120 001350                  	bne	1$			; br if yes
     378                                
     379                                	; check if we generated the minimum number of digits requested
     380                                
     381 024122 026565  177770  177772  10$:	cmp	p.len(r5),p.pre(r5)	; compare length to precision
     382 024130 103005                  	bhis	20$			; br we're OK
     383 024132 012746  000060          	mov	#<'0>,-(sp)		; nope, add another digit
     384 024136 005265  177770          	inc	p.len(r5)		; count digits
     385 024142 000767                  	br	10$			; and loop	
     386                                
     387                                	; check for options (#) flag
     388                                
     389 024144 132765  000004  177777  20$:	bitb	#pf.altf,p.flg(r5)	; check for options flag
     390 024152 001422                  	beq	30$			; br if not set
     391 024154 020227  000020          	cmp	r2,#16.			; radix 16?
     392 024160 001407                  	beq	21$			; br if yes
     393 024162 020227  000010          	cmp	r2,#8.			; radix 8?
     394 024166 001014                  	bne	30$			; br if not
     395 024170 022716  000060          	cmp	#<'0>,(sp)		; first digit already zero?
     396 024174 001411                  	beq	30$			; yes, no need to add
     397 024176 000404                  	br	22$			; no, add a leading zero
     398 024200 012746  000170          21$:	mov	#<'x>,-(sp)		; add a '0x' prefix
     399 024204 005265  177770          	inc	p.len(r5)		; count it
     400 024210 012746  000060          22$:	mov	#<'0>,-(sp)		;
     401 024214 005265  177770          	inc	p.len(r5)		; count it
     402                                
     403                                	; check if we need a sign (+/-/none)
     404                                
     405 024220 132765  000020  177777  30$:	bitb	#pf.nega,p.flg(r5)	; was original value negative?
     406 024226 001403                  	beq	31$			; br if not
     407 024230 012746  000055          	mov	#<'->,-(sp)		; minus sign
     408 024234 000406                  	br	32$			;
     409 024236 132765  000002  177777  31$:	bitb	#pf.sign,p.flg(r5)	; sign always requested?
     410 024244 001404                  	beq	50$			; br if not
     411 024246 012746  000053          	mov	#<'+>,-(sp)		; plus sign
     412 024252 005265  177770          32$:	inc	p.len(r5)		; count all chars generated
     413                                
     414                                	; processing for right justification
     415                                
     416 024256 132765  000001  177777  50$:	bitb	#pf.ljus,p.flg(r5)	; check left-justify flag
     417 024264 001020                  	bne	70$			; br if left justified
     418 024266 116501  177776          	movb	p.fil(r5),r1		; get fill character
     419 024272 026565  177770  177774  51$:	cmp	p.len(r5),p.wid(r5)	; compare length to width
     420 024300 103012                  	bhis	70$			; br if we're OK
     421 024302 011600                  	mov	(sp),r0			; copy last character
     422 024304 010146                  	mov	r1,-(sp)		; add a fill character
     423 024306 020100                  	cmp	r1,r0			; check fill/last char order
     424 024310 101403                  	blos	52$			; br if order OK
     425 024312 010016                  	mov	r0,(sp)			; copy sign/last char
     426 024314 010166  000002          	mov	r1,2(sp)		; insert fill after sign
     427 024320 005265  177770          52$:	inc	p.len(r5)		; count it
     428 024324 000762                  	br	51$			; loop
     429                                
     430                                	; print all digits in order (sign..msd..lsd)
     431                                
     432 024326 005001                  70$:	clr	r1			; count characters output
     433 024330 012600                  71$:	mov	(sp)+,r0		; get a digit
     434 024332 001404                  	beq	80$			; br if no more
     435 024334                         	call	@p.out(r5)		; print it
       1 024334 004775  177766          	jsr	pc,@p.out(r5)
     436 024340 005201                  	inc	r1			; count it
     437 024342 000772                  	br	71$			; loop
     438                                
     439                                	; processing for left justification
     440                                
     441 024344 132765  000001  177777  80$:	bitb	#pf.ljus,p.flg(r5)	; check left-justify flag
     442 024352 001411                  	beq	90$			; br if is right justified
     443 024354 012700  000040          	mov	#<' >,r0		; space fill on right
     444 024360 020165  177774          81$:	cmp	r1,p.wid(r5)		; compare length to width
     445 024364 103004                  	bhis	90$			; br we're OK
     446 024366                         	call	@p.out(r5)		; print it
       1 024366 004775  177766          	jsr	pc,@p.out(r5)
     447 024372 005201                  	inc	r1			; count characters
     448 024374 000771                  	br	81$			; and loop	
     449                                
     450                                	; and done
     451                                
     452 024376 012604                  90$:	mov	(sp)+,r4		; restore regs
     453 024400 012603                  	mov	(sp)+,r3		;
     454 024402                         	return				; return
       1 024402 000207                  	rts	pc
     455                                
     456                                ; --------------------------------------------------------------------------------
     457                                ;
     458                                ; asciz string print routine
     459                                ;
     460                                ;	call:	mov	#strptr,r2
     461                                ;		call	prtstr
     462                                ;
     463                                ;		r0 - temp          (not saved)
     464                                ;		r1 - temp          (not saved)
     465                                ;		r2 - ptr to string (not saved)
     466                                ;		r3 - ptr to format     (saved) [input not used]
     467                                ;		r4 - ptr to arglist    (saved) [input not used]
     468                                ;		r5 - ptr to flags      (saved)
     469                                ;
     470 024404 010346                  prtstr:	mov	r3,-(sp)		; save regs
     471 024406 010446                  	mov	r4,-(sp)		;
     472                                
     473                                	; compute length of string
     474                                
     475 024410 010203                  	mov	r2,r3			; copy ptr to string
     476 024412 105723                  1$:	tstb	(r3)+			; check a byte
     477 024414 001376                  	bne	1$			; br if more string
     478 024416 160203                  	sub	r2,r3			; compute length
     479 024420 005303                  	dec	r3			; minus the trailing null	
     480                                
     481                                	; set precision to length if precision is zero
     482                                
     483 024422 005765  177772          	tst	p.pre(r5)		; check requested precision
     484 024426 001002                  	bne	20$			; br if nonzero
     485 024430 010365  177772          	mov	r3,p.pre(r5)		; else set to string length
     486 024434 020365  177772          20$:	cmp	r3,p.pre(r5)		; compare actual length to precision
     487 024440 101402                  	blos	50$			; br if actual <= precision
     488 024442 016503  177772          	mov	p.pre(r5),r3		; else set actual to precision
     489                                
     490                                	; processing for right justification
     491                                
     492 024446 132765  000001  177777  50$:	bitb	#pf.ljus,p.flg(r5)	; check left-justify flag
     493 024454 001002                  	bne	70$			; br if left justified
     494 024456                         	call	100$			; do fill
       1 024456 004737  024524          	jsr	pc,100$
     495                                
     496                                	; print string 
     497                                
     498 024462 010301                  70$:	mov	r3,r1			; copy length
     499 024464 001406                  	beq	80$			; br if no characters
     500 024466 112200                  71$:	movb	(r2)+,r0		; get a character
     501 024470 001404                  	beq	80$			; br if no characters
     502 024472                         	call	@p.out(r5)		; print it
       1 024472 004775  177766          	jsr	pc,@p.out(r5)
     503 024476 005301                  	dec	r1			; count
     504 024500 001372                  	bne	71$			; loop
     505                                
     506                                	; processing for left justification
     507                                
     508 024502 132765  000001  177777  80$:	bitb	#pf.ljus,p.flg(r5)	; check left-justify flag
     509 024510 001402                  	beq	90$			; br if is right justified
     510 024512                         	call	100$			; do fill
       1 024512 004737  024524          	jsr	pc,100$
     511                                
     512                                	; and done
     513                                
     514 024516 012604                  90$:	mov	(sp)+,r4		; restore
     515 024520 012603                  	mov	(sp)+,r3		;
     516 024522                         	return				; return
       1 024522 000207                  	rts	pc
     517                                
     518                                	; ----------------------------------------------------
     519                                	; generate fill characters
     520                                
     521 024524 016501  177774          100$:	mov	p.wid(r5),r1		; requested width
     522 024530 160301                  	sub	r3,r1			; subtract string width
     523 024532 101406                  	blos	102$			; br if no fill needed
     524 024534 116500  177776          	movb	p.fil(r5),r0		; get fill character
     525 024540                         101$:	call	@p.out(r5)		; print a fill character
       1 024540 004775  177766          	jsr	pc,@p.out(r5)
     526 024544 005301                  	dec	r1			; count
     527 024546 001374                  	bne	101$			; loop
     528 024550                         102$:	return				; done
       1 024550 000207                  	rts	pc
     529                                
     530                                ; --------------------------------------------------------------------------------
     531                                
     532                                .include "mac/muldiv.mac"
       1                                ;=================================================================================
       2                                ; muldiv.mac - 32b mul/div routines for macro11 diagnostics
       3                                ; (C) 2009-2016 Donald North. All rights reserved.
       4                                ;=================================================================================
       5                                
       6                                ; --------------------------------------------------------------------------------
       7                                ;
       8                                ; unsigned 32b * 32b => 32b multiplication
       9                                ; 
      10                                ; from the 2.9BSD stdio C lib, using simple shift/add algorithm
      11                                ; 
      12                                ;	call:	mov	#b.lo,-(sp)
      13                                ;		mov	#b.hi,-(sp)
      14                                ;		mov	#a.lo,-(sp)
      15                                ;		mov	#a.hi,-(sp)
      16                                ;		call	ulmul
      17                                ;		add	#8.,sp
      18                                ;		mov	r1,q.lo
      19                                ;		mov	r0,q.hi
      20                                ;
      21 024552 010246                  ulmul::	mov	r2,-(sp)		; save
      22 024554 010346                  	mov	r3,-(sp)		;
      23 024556 010446                  	mov	r4,-(sp)		;
      24 024560 010546                  	mov	r5,-(sp)		;
      25                                
      26 024562 016605  000020          	mov	8.+8.(sp),r5		; b.lo
      27 024566 016604  000016          	mov	6.+8.(sp),r4		; b.hi
      28 024572 016603  000014          	mov	4.+8.(sp),r3		; a.lo
      29 024576 016602  000012          	mov	2.+8.(sp),r2		; a.hi
      30 024602 005001                  	clr	r1			; q.lo
      31 024604 005000                  	clr	r0			; q.hi
      32                                
      33 024606 000241                  1$:	clc				; shiftin zeroes
      34 024610 006004                  	ror	r4			; shift multiplier right one
      35 024612 006005                  	ror	r5			;
      36 024614 103003                  	bcc	2$			; br if shifted out a zero
      37 024616 060301                  	add	r3,r1			; else add multiplicand to product
      38 024620 005500                  	adc	r0			; propagate C
      39 024622 060200                  	add	r2,r0			;
      40 024624 006303                  2$:	asl	r3			; shift multiplicant left one
      41 024626 006102                  	rol	r2			;
      42 024630 005704                  	tst	r4			; any high multiplier bits left?
      43 024632 001365                  	bne	1$			; br if yes
      44 024634 005705                  	tst	r5			; any low multiplier bits left?
      45 024636 001363                  	bne	1$			; br if yes
      46                                
      47 024640 012605                  	mov	(sp)+,r5		; restore
      48 024642 012604                  	mov	(sp)+,r4		;
      49 024644 012603                  	mov	(sp)+,r3		;
      50 024646 012602                  	mov	(sp)+,r2		;
      51 024650                         	return				; done
       1 024650 000207                  	rts	pc
      52                                
      53                                ; --------------------------------------------------------------------------------
      54                                ;
      55                                ; unsigned 32b / 32b => 32b, 32b division with remainder
      56                                ; 
      57                                ; from Hennessey & Patterson Appendix A
      58                                ;
      59                                ;	call:	mov	#den.lo,-(sp)	; 8.(sp)
      60                                ;		mov	#den.hi,-(sp)	; 6.(sp)
      61                                ;		mov	#num.lo,-(sp)	; 4.(sp)
      62                                ;		mov	#num.hi,-(sp)	; 2.(sp)
      63                                ;		call	uldiv
      64                                ;		add	#8.,sp
      65                                ;		mov	r3,rem.lo
      66                                ;		mov	r2,rem.hi
      67                                ;		mov	r1,quo.lo
      68                                ;		mov	r0,quo.hi
      69                                ;
      70 024652 010446                  uldiv::	mov	r4,-(sp)		; save
      71 024654 010546                  	mov	r5,-(sp)		;
      72                                
      73 024656 016601  000010          	mov	4.+4.(sp),r1		; num.lo
      74 024662 016600  000006          	mov	2.+4.(sp),r0		; num.hi
      75                                
      76 024666 005005                  	clr	r5			; tmp.lo
      77 024670 005004                  	clr	r4			; tmp.hi
      78                                
      79 024672 012746  000037          	mov	#31.,-(sp)		; bit count
      80                                
      81 024676 006301                  1$:	asl	r1			; (tmp,num) <<= 1
      82 024700 006100                  	rol	r0			;
      83 024702 006105                  	rol	r5			;
      84 024704 006104                  	rol	r4			;
      85                                
      86 024706 010503                  	mov	r5,r3			; rem = tmp - den
      87 024710 010402                  	mov	r4,r2			;
      88 024712 166603  000016          	sub	8.+6.(sp),r3		;
      89 024716 005602                  	sbc	r2			;
      90 024720 166602  000014          	sub	6.+6.(sp),r2		;
      91                                
      92 024724 100403                  	bmi	2$			; br if rem < 0
      93                                
      94 024726 005201                  	inc	r1			; quo |= 1
      95 024730 010305                  	mov	r3,r5			; tmp = rem
      96 024732 010204                  	mov	r2,r4			;
      97                                
      98 024734 005316                  2$:	dec	(sp)			; count bits
      99 024736 002357                  	bge	1$			; loop if more
     100 024740 005726                  	tst	(sp)+			; flush counter
     101                                
     102 024742 005702                  	tst	r2			; test for rem < 0
     103 024744 002005                  	bge	3$			; br if not
     104                                
     105 024746 066603  000014          	add	8.+4.(sp),r3		; rem += den correction
     106 024752 005502                  	adc	r2			;
     107 024754 066602  000012          	add	6.+4.(sp),r2		;
     108                                
     109 024760 012605                  3$:	mov	(sp)+,r5		; restore
     110 024762 012604                  	mov	(sp)+,r4		;
     111 024764                         	return				; done
       1 024764 000207                  	rts	pc
     112                                
     113                                ; --------------------------------------------------------------------------------
     114                                ;
     115                                ; signed 32b / 32b => 32b, 32b division with remainder
     116                                ; 
     117                                ;	call:	mov	#den.lo,-(sp)	; 8.(sp)
     118                                ;		mov	#den.hi,-(sp)	; 6.(sp)
     119                                ;		mov	#num.lo,-(sp)	; 4.(sp)
     120                                ;		mov	#num.hi,-(sp)	; 2.(sp)
     121                                ;		call	sldiv
     122                                ;		add	#8.,sp
     123                                ;		mov	r3,rem.lo
     124                                ;		mov	r2,rem.hi
     125                                ;		mov	r1,quo.lo
     126                                ;		mov	r0,quo.hi
     127                                ;
     128 024766 010446                  sldiv::	mov	r4,-(sp)		; save
     129                                
     130 024770 016603  000012          	mov	8.+2.(sp),r3		; den.lo
     131 024774 016602  000010          	mov	6.+2.(sp),r2		; den.hi
     132 025000 016601  000006          	mov	4.+2.(sp),r1		; num.lo
     133 025004 016600  000004          	mov	2.+2.(sp),r0		; num.hi
     134                                
     135 025010 005004                  	clr	r4			; pos
     136                                
     137 025012 005700                  	tst	r0			; num sign
     138 025014 002006                  	bge	10$			; br if pos
     139                                
     140 025016 005104                  	com	r4			; neg
     141                                
     142 025020 005101                  	com	r1			; negate num
     143 025022 005100                  	com	r0			;
     144 025024 062701  000001          	add	#1,r1			;
     145 025030 005500                  	adc	r0			; 
     146                                
     147 025032 005702                  10$:	tst	r2			; den sign
     148 025034 002006                  	bge	20$			; br if pos
     149                                
     150 025036 105104                  	comb	r4			; neg
     151                                
     152 025040 005103                  	com	r3			; negate den
     153 025042 005102                  	com	r2			;
     154 025044 062703  000001          	add	#1,r3			;
     155 025050 005502                  	adc	r2			; 
     156                                	
     157 025052 010346                  20$:	mov	r3,-(sp)		; den.lo
     158 025054 010246                  	mov	r2,-(sp)		; den.hi
     159 025056 010146                  	mov	r1,-(sp)		; num.lo
     160 025060 010046                  	mov	r0,-(sp)		; num.hi
     161 025062                         	call	uldiv			;
       1 025062 004737  024652          	jsr	pc,uldiv
     162 025066 062706  000010          	add	#8.,sp			; 
     163                                
     164 025072 005704                  	tst	r4			; invert result
     165 025074 002005                  	bge	30$			;
     166                                
     167 025076 005103                   	com	r3			; negate rem
     168 025100 005102                  	com	r2			;
     169 025102 062703  000001          	add	#1,r3			;
     170 025106 005502                  	adc	r2			; 
     171                                
     172 025110 105704                  30$:	tstb	r4			; invert result
     173 025112 002005                  	bge	40$			;
     174                                
     175 025114 005101                  	com	r1			; negate quo
     176 025116 005100                  	com	r0			;
     177 025120 062701  000001          	add	#1,r1			;
     178 025124 005500                  	adc	r0			; 
     179                                
     180 025126 012604                  40$:	mov	(sp)+,r4		; restore
     181 025130                         	return				; done
       1 025130 000207                  	rts	pc
     182                                
     183                                ;================================================================================
     184                                ; end of muldiv.mac
     185                                ;================================================================================
     185                                
     533                                
     534                                ; --------------------------------------------------------------------------------
     535                                
     536        000000                  .iif ne,pf.sep,	.end
     537                                
     538                                ;=================================================================================
     539                                ; end of printf.mac
     540                                ;=================================================================================
     540                                
     895                                
     896                                .end
     896                                


Symbol table

$$NUM  =000004           405$17 =023444   L       BIT13  =020000           MD_RWD =000002           SA_BST =000374           
$$POS  =000200           41$17  =023300   L       BIT14  =040000           MD_SCH =004000           SA_CL0 =004000           
$ENDAD =020306           410$17 =023462   L       BIT15  =100000           MD_SCL =002000           SA_CLE =000070           
$SAV42 =002022           42$17  =023330   L       BIT2   =000004           MD_SEC =001000           SA_CLL =034000           
.      =******           420$17 =023474   L       BIT3   =000010           MD_SER =000400           SA_CN0 =000020           
1$11   =021276   L       430$17 =023514   L       BIT4   =000020           MD_SHD =000020           SA_CNT =000360           
1$13   =022530   L       431$17 =023540   L       BIT5   =000040           MD_SPN =000001           SA_CTY =000003           
1$14   =022644   L       439$17 =023560   L       BIT6   =000100           MD_SWP =000004           SA_EDP =000400           
1$15   =022726   L       440$17 =023570   L       BIT7   =000200           MD_UNL =000020           SA_ERC =003777           
1$16   =023006   L       450$17 =023604   L       BIT8   =000400           MSG1   =020360           SA_ERR =100000           
1$17   =023034   L       460$17 =023620   L       BIT9   =001000           MSG2   =020427           SA_GO  =000001           
1$18   =024042   L       470$17 =023634   L       BUFEND =012034           MSG3   =020443           SA_INE =000200           
1$19   =024412   L       5$11   =021410   L       BUFFER =002034           N.ARGS =000016           SA_INT =000200           
1$20   =024606   L       5$3    =014364   L       BUFINI =022522           N.LAST =000014           SA_LFC =000002           
1$21   =024676   L       50$12  =022010   L       BUFLEN =010000           NOXXDP =020322           SA_MC0 =000001           
1$3    =014274   L       50$18  =024256   L       BUFSIZ =000010           NUMPAS =002004           SA_MCV =000017           
1$4    =015220   L       50$19  =024446   L       CEND   =012220           OPTSWI =002002           SA_NSV =002000           
1$5    =016474   L       50$2   =013342   L       CF_ATN =000200           OP_ABO =000001           SA_OPT =000000           
1$7    =020524   L       51$12  =022022   L       CF_MSC =000100           OP_ACC =000020           SA_PPT =100000           
1$8    =020542   L       51$18  =024272   L       CF_OTH =000040           OP_ACP =000102           SA_PRG =000001           
10$1   =012632   L       51$2   =013354   L       CF_RPL =100000           OP_AVA =000100           SA_RGH =077777           
10$12  =021536   L       51$5   =017220   L       CF_THS =000020           OP_AVL =000010           SA_RGL =177776           
10$17  =023126   L       52$12  =022034   L       CLEN   =000060           OP_CCD =000021           SA_RL0 =000400           
10$18  =024122   L       52$18  =024320   L       COMM   =012040           OP_CMP =000040           SA_RLE =000007           
10$2   =013100   L       52$2   =013366   L       CONSOL =165144 G         OP_DAP =000013           SA_RLL =003400           
10$22  =025032   L       53$12  =022046   L       CPKT   =012140           OP_DUP =000101           SA_RS0 =000001           
10$4   =015300   L       53$2   =013400   L       CR     =000015           OP_END =000200           SA_RSV =000377           
10$5   =016512   L       54$12  =022060   L       CSR$IP =002012           OP_ERG =000026           SA_ST1 =004000           
10$6   =020340   L       54$2   =013412   L       CSR$SA =002014           OP_ERS =000022           SA_ST2 =010000           
100$19 =024524   L       58$5   =017252   L       DELAY  =020534           OP_FLU =000023           SA_ST3 =020000           
1000$17=024002   L       59$3   =014542   L       DLYCNT =002030           OP_FMT =000057           SA_ST4 =040000           
101$19 =024540   L       59$4   =015706   L       DMPBUF =021154           OP_GCS =000002           SA_STE =000200           
102$19 =024550   L       59$5   =017256   L       DMPHDR =020552           OP_GUS =000003           SA_STP =100000           
11$12  =021570   L       6$11   =021414   L       DONE   =020232           OP_ILL =000077           SA_UCV =000006           
11$17  =023154   L       6$3    =014404   L       DPYREG =177570 G         OP_NIL =000000           SA_VEC =000177           
11$2   =013136   L       60$2   =013420   L       DS_INT =040000           OP_ONL =000011           SA_VEE =000177           
11$4   =015314   L       60$4   =015720   L       DS_OWN =100000           OP_POS =000045           SA_VPE =000400           
11$5   =016556   L       60$5   =017270   L       DUMPER =021256           OP_RD  =000041           SA_WRP =040000           
12$12  =021624   L       61$4   =015726   L       EF_BBR =000200           OP_RPL =000024           SLDIV  =024766 G         
12$17  =023206   L       7$3    =014450   L       EF_BBU =000100           OP_RWA =000103           SPRINT =022742 G         
12$2   =013176   L       70$1   =012712   L       EF_DLS =000002           OP_SCC =000004           STACK  =002000           
12$4   =015520   L       70$18  =024326   L       EF_EOT =000010           OP_SUC =000012           START  =012400           
12$5   =016562   L       70$19  =024462   L       EF_LOG =000040           OP_WR  =000042           ST_ABO =000002           
13$12  =021666   L       70$2   =013430   L       EF_PLS =000004           OP_WTM =000044           ST_AVL =000004           
13$17  =023224   L       70$3   =014552   L       EF_SXC =000020           P.FIL  =177776           ST_BBR =000024           
13$2   =013244   L       70$4   =015730   L       ERRORS =002016           P.FLG  =177777           ST_BOT =000015           
13$4   =015554   L       70$5   =017304   L       EXIT   =020276           P.LEN  =177770           ST_CMD =000001           
13$5   =016544   L       71$1   =012764   L       FM_BAD =000001           P.OUT  =177766           ST_CMP =000007           
14$12  =021700   L       71$12  =022062   L       FM_CNT =000000           P.PRE  =177772           ST_CNT =000012           
14$2   =013256   L       71$18  =024330   L       FM_DSK =000002           P.PTR  =177764           ST_DAT =000010           
14$4   =015570   L       71$19  =024466   L       FM_IBM =000013           P.SR0  =000012           ST_DIA =000037           
15$12  =021732   L       71$2   =013504   L       FM_LDR =000012           P.SR1  =000010           ST_DRV =000013           
15$2   =013314   L       71$3   =014631   L       FM_RPL =000011           P.SR2  =000006           ST_FMT =000014           
15$5   =016636   L       71$5   =017352   L       FM_SDE =000004           P.SR3  =000004           ST_HST =000011           
16$4   =015372   L       72$12  =022171   L       FM_SDI =000003           P.SR4  =000002           ST_INF =000026           
16$5   =016726   L       72$2   =013615   L       FM_STD =000007           P.SR5  =000000           ST_INV =000025           
17$4   =015460   L       72$3   =014714   L       FM_STF =000010           P.WID  =177774           ST_LDR =000027           
18$4   =015412   L       72$4   =015767   L       FM_STI =000006           PASSES =002020           ST_LED =000023           
19$4   =015646   L       72$5   =017441   L       FM_TAP =000005           PF.ALT =000004           ST_MFE =000005           
2$11   =021326   L       73$12  =022305   L       INIT   =021524           PF.LJU =000001           ST_MSK =000037           
2$13   =022552   L       73$2   =013733   L       LF     =000012           PF.LON =000010           ST_OFL =000003           
2$17   =023054   L       73$3   =014767   L       LF_BBR =000040           PF.NEG =000020           ST_POL =000021           
2$18   =024104   L       73$5   =017547   L       LF_CON =000100           PF.SEP =000000           ST_RDT =000020           
2$20   =024624   L       74$12  =022434   L       LF_INF =000002           PF.SIG =000002           ST_SUB =000040           
2$21   =024734   L       74$2   =014064   L       LF_RCT =000020           PRINTF =022662 G         ST_SUC =000000           
2$3    =014310   L       74$3   =015074   L       LF_SNR =000001           PRT32U =024034           ST_SXC =000022           
2$4    =015216   L       74$4   =016040   L       LF_SUC =000200           PRTSTR =024404           ST_TMK =000016           
2$8    =020550   L       74$5   =017655   L       LK$CSR =177546           PSW    =177776 G         ST_WPR =000006           
20$1   =012660   L       75$4   =016121   L       LK$VEC =000100           P_BCNT =000014           SWIREG =177570 G         
20$17  =023242   L       75$5   =017765   L       LKINTR =020500           P_BUFF =000020           TEST1  =012556           
20$18  =024144   L       76$4   =016227   L       LK_IEN =000100           P_CID  =177777           TEST2  =013034           
20$19  =024434   L       76$5   =020065   L       LK_MON =000200           P_CMST =000020           TEST3  =014160           
20$22  =025052   L       77$4   =016320   L       LK_PRI =000006           P_CNTF =000016           TEST4  =015152           
20$5   =016656   L       77$5   =020150   L       LOOP   =012546           P_CNTI =000024           TEST5  =016440           
200$10 =021230   L       8$11   =021452   L       L_BADR =000004           P_CRF  =000000           TESTNO =002032           
200$9  =021000   L       80$18  =024344   L       L_CHVR =000025           P_CSIZ =000060           TICKHI =002026           
201$11 =021474   L       80$19  =024502   L       L_CNTI =000014           P_CTMO =000020           TICKLO =002024           
201$9  =021104   L       800$17 =023650   L       L_CRF  =000000           P_CYL  =000050           TST$NO =000006           
202$11 =021502   L       81$18  =024360   L       L_CSVR =000024           P_DVPM =000034           TSTCID =000001           
203$11 =021507   L       810$17 =023670   L       L_EVNT =000012           P_FBBK =000034           TTRBUF =177562 G         
204$11 =021512   L       820$17 =023672   L       L_FLGS =000011           P_FLGS =000011           TTRCSR =177560 G         
205$11 =021515   L       880$17 =023734   L       L_FMT  =000010           P_GRP  =000046           TTXBUF =177566 G         
21$18  =024200   L       890$17 =023742   L       L_HDCD =000050           P_HTMO =000020           TTXCSR =177564 G         
21$5   =017002   L       90$18  =024376   L       L_LVL  =000042           P_LBN  =000034           T_RQD3 =000023           
22$18  =024210   L       90$19  =024516   L       L_MLUN =000026           P_LEN  =177774           T_TK50 =000011           
22$5   =017032   L       900$17 =023744   L       L_RTRY =000043           P_MEDI =000034           T_TK70 =000016           
23$5   =017062   L       99$1   =013030   L       L_SDI  =000054           P_MLUN =000014           T_TU81 =000005           
3$11   =021370   L       99$10  =021226   L       L_SEQ  =000006           P_MOD  =000012           T_UD50 =000002           
3$17   =023064   L       99$2   =014154   L       L_UHVR =000041           P_MSIZ =000060           T_UD5A =000006           
3$21   =024760   L       99$3   =015146   L       L_UNIT =000004           P_OPCD =000010           UC17   =000001           
30$1   =012662   L       99$4   =016434   L       L_UNTI =000030           P_OTRF =000014           UF_CAC =100000           
30$18  =024220   L       99$5   =020226   L       L_USVR =000040           P_RBN  =000014           UF_CFL =000004           
30$22  =025110   L       99$9   =020776   L       L_VSER =000044           P_RBNS =000056           UF_CMR =000001           
30$5   =017140   L       990$17 =023762   L       M$BASE =002006           P_RCTC =000057           UF_CMW =000002           
31$18  =024236   L       ADRCHK =022610 G         M$VECT =002010           P_RCTS =000054           UF_EWR =000010           
32$18  =024252   L       BIT0   =000001           MD_ACL =000002           P_SHUN =000040           UF_EXA =002000           
32768$0=012420   L       BIT00  =000001           MD_CDL =010000           P_STS  =000012           UF_LOD =001000           
32769$0=012426   L       BIT01  =000002           MD_CMP =040000           P_TIME =000024           UF_RMV =000200           
32770$0=012444   L       BIT02  =000004           MD_CSE =020000           P_TRCK =000044           UF_RPL =100000           
32771$0=012456   L       BIT03  =000010           MD_DLE =000200           P_TYPE =177776           UF_SCH =004000           
39$12  =021776   L       BIT04  =000020           MD_ERR =010000           P_UNFL =000016           UF_VSS =000040           
39$2   =013330   L       BIT05  =000040           MD_ERW =000010           P_UNIT =000004           UF_VSU =000020           
39$3   =014516   L       BIT06  =000100           MD_EXA =000040           P_UNSZ =000044           UF_WBN =000100           
39$4   =015662   L       BIT07  =000200           MD_EXP =100000           P_UNTI =000024           UF_WPD =000400           
4$17   =023120   L       BIT08  =000400           MD_IMF =000002           P_VRSN =000014           UF_WPH =020000           
40$17  =023274   L       BIT09  =001000           MD_IMM =000100           P_VSER =000050           UF_WPS =010000           
40$22  =025126   L       BIT1   =000002           MD_NXU =000001           REND   =012134           ULDIV  =024652 G         
40$5   =017204   L       BIT10  =002000           MD_OBC =000004           RLEN   =000060           ULMUL  =024552 G         
400$17 =023344   L       BIT11  =004000           MD_REV =000010           RPKT   =012054           XPRINT =023032           
401$17 =023430   L       BIT12  =010000           MD_RIP =000001           SA_A22 =001000           


Program sections:

. ABS.  025132    000   (RW,I,GBL,ABS,OVR,NOSAV)
        000000    001   (RW,I,LCL,REL,CON,NOSAV)
