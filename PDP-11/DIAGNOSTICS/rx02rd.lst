       1                                .title  RX211 read physical disk
       2                                
       3                                ; (C) 2016 Donald North. All rights reserved.
       4                                
       5                                .include "mac/stddef.mac"
       1                                ;================================================================================
       2                                ; stddef.mac - standard definitions
       3                                ; (C) 2009 Donald North. All rights reserved.
       4                                ;================================================================================
       5                                .macro	align	arg1
      16                                ;================================================================================
      17                                .macro	savreg	arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8
      28                                ;================================================================================
      29                                .macro	resreg	arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8
      40                                ;================================================================================
      41                                .macro	call	proc
      44                                .macro	return
      47                                .macro	calls	proc arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8 arg9 arg10 arg11 arg12 arg13 arg14 arg15 arg16
      67                                ;================================================================================
      68                                .macro	jeq	label ?a1
      73                                .macro	jne	label ?a1
      78                                .macro	jpl	label ?a1
      83                                .macro	jmi	label ?a1
      88                                .macro	jlo	label ?a1
      93                                .macro	jhis	label ?a1
      98                                .macro	jlos	label ?a1
     103                                .macro	jhi	label ?a1
     108                                .macro	jlt	label ?a1
     113                                .macro	jge	label ?a1
     118                                .macro	jle	label ?a1
     123                                .macro	jgt	label ?a1
     128                                .macro	jcc	label ?a1
     133                                .macro	jcs	label ?a1
     138                                .macro	jvc	label ?a1
     143                                .macro	jvs	label ?a1
     148                                ;================================================================================
     149                                .macro	printf	arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8 arg9 arg10 arg11 arg12 arg13 arg14 arg15 arg16
     152                                .macro	sprintf	arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8 arg9 arg10 arg11 arg12 arg13 arg14 arg15 arg16
     155                                ;================================================================================
     156                                .macro	ipl	lvl
     161                                ;================================================================================
     162                                .macro	trapcatcher	list ?a1 ?a2 ?a3 ?a4
     176                                ;================================================================================
     177        000001                  tst$no	= 1
     178                                .macro	test	title
     198                                ;================================================================================
     199                                ; end of stddef.mac
     200                                ;================================================================================
     200                                
       6                                
       7                                ; --------------------------------------------------------------------------------
       8                                
       9                                .sbttl  general definitions
      10                                
      11                                .include "mac/bits.mac"
       1                                ;================================================================================
       2                                ; bits.mac - standard bit definitions
       3                                ;================================================================================
       4                                
       5                                ;  system global fixed addresses
       6                                
       7        177776                  psw	==177776		; processor status word
       8                                
       9        165144                  console	==165144		; console routine start
      10                                
      11        177570                  swireg	==177570		; console switch register
      12        177570                  dpyreg	==swireg		; console display register
      13                                
      14        177560                  ttrcsr	==177560		; console serial device
      15        177562                  ttrbuf	==ttrcsr+2		;
      16        177564                  ttxcsr	==ttrcsr+4		;
      17        177566                  ttxbuf	==ttrcsr+6		;
      18                                
      19                                ; common values
      20                                
      21        000015                  cr	=015			; ascii CR
      22        000012                  lf	=012			; ascii LF
      23                                
      24        000001                  bit00	=000001			; bit positions
      25        000002                  bit01	=000002			;
      26        000004                  bit02	=000004			;
      27        000010                  bit03	=000010			;
      28        000020                  bit04	=000020			;
      29        000040                  bit05	=000040			;
      30        000100                  bit06	=000100			;
      31        000200                  bit07	=000200			;
      32        000400                  bit08	=000400			;
      33        001000                  bit09	=001000			;
      34        002000                  bit10	=002000			;
      35        004000                  bit11	=004000			;
      36        010000                  bit12	=010000			;
      37        020000                  bit13	=020000			;
      38        040000                  bit14	=040000			;
      39        100000                  bit15	=100000			;
      40                                	
      41        000001                  bit0	=bit00			; also
      42        000002                  bit1	=bit01			;
      43        000004                  bit2	=bit02			;
      44        000010                  bit3	=bit03			;
      45        000020                  bit4	=bit04			;
      46        000040                  bit5	=bit05			;
      47        000100                  bit6	=bit06			;
      48        000200                  bit7	=bit07			;
      49        000400                  bit8	=bit08			;
      50        001000                  bit9	=bit09			;
      51                                
      52                                ;================================================================================
      53                                ; end of bits.mac
      54                                ;================================================================================
      54                                
      12                                
      13                                ; LCLK registers
      14                                
      15        177546                  lk$csr	=177546			; line clock csr
      16        000200                  lk_mon	=000200			; monitor but
      17        000100                  lk_ien	=000100			; intr enb bit
      18        000100                  lk$vec	=100			; vector
      19        000006                  lk_pri	=6			; priority
      20                                
      21                                ; --------------------------------------------------------------------------------
      22                                
      23                                .sbttl  RX211 device registers
      24                                
      25                                .include "rx/define.mac"
       1                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       2                                
       3                                ; RX11/RX211 device registers
       4                                
       5                                ; register declarations
       6                                
       7        177170                  rx$cs	= 177170
       8        177172                  rx$db	= rx$cs+2
       9                                
      10                                ; command/status register
      11                                
      12        100000                  rc_error = bit15
      13        040000                  rc_init  = bit14
      14        020000                  rc_a17   = bit13	; RX211 only
      15        010000                  rc_a16   = bit12	; RX211 only
      16        004000                  rc_rx02  = bit11	; RX211 only
      17        002000                  rc_nu10	 = bit10
      18        001000                  rc_head	 = bit09	; RX211 only
      19        000400                  rc_den   = bit08	; RX211 only
      20        000200                  rc_treq  = bit07
      21        000100                  rc_ien   = bit06
      22        000040                  rc_done  = bit05
      23        000020                  rc_unit  = bit04
      24        000000                  rc_fill  = 0*bit01
      25        000002                  rc_empt  = 1*bit01
      26        000004                  rc_wr    = 2*bit01
      27        000006                  rc_rd    = 3*bit01
      28        000010                  rc_sde   = 4*bit01	; RX211 only
      29        000012                  rc_rds   = 5*bit01
      30        000014                  rc_wrd   = 6*bit01
      31        000016                  rc_rde   = 7*bit01
      32        000016                  rc_cmd	 = 7*bit01
      33        000001                  rc_go    = bit00
      34                                
      35        072017                  rc_wocs	 = bit14 + bit13 + bit12 + bit10 + bit03 + bit02 + bit01 + bit00 ; cs undef bits
      36                                
      37        177400                  rc_wodb	 = bit15 + bit14 + bit13 + bit12 + bit11 + bit10 + bit09 + bit08 ; db undef bits
      38                                
      39        170000                  rc_woes	 = bit15 + bit14 + bit13 + bit12				 ; es undef bits
      40                                
      41        100240                  rc_any	 = rc_error+rc_treq+rc_done ; error/status bits
      42                                
      43                                ; error/status register
      44                                
      45        004000                  re_nxm  = bit11		; RX211 only
      46        002000                  re_wco  = bit10		; RX211 only
      47        001000                  re_nu9	= bit09
      48        000400                  re_unit = bit08
      49        000200                  re_drdy = bit07
      50        000100                  re_ddat = bit06
      51        000040                  re_dden = bit05
      52        000020                  re_derr = bit04
      53        000010                  re_aclo = bit03		; RX211 only
      54        000004                  re_done = bit02
      55        000002                  re_perr	= bit01
      56        000001                  re_cerr = bit00
      57                                
      58                                ; device characteristics
      59                                
      60        000000                  rx_tal   =   0.  ; min track address
      61        000114                  rx_tah   =  76.  ; max track address
      62        000001                  rx_sal   =   1.  ; min sector address
      63        000032                  rx_sah   =  26.  ; max sector address
      64        000200                  rx_wps   = 128.  ; words per sector (RX02; RX01 mode is half this)
      65        000400                  rx_bps   = 256.  ; bytes per sector (RX02; RX01 mode is half this)
      66                                	
      67                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      67                                
      26                                	
      27                                ; --------------------------------------------------------------------------------
      28                                	
      29                                .sbttl	low memory
      30                                
      31                                   	.enabl	ama			; change all mode 67 references to 37
      32                                
      33 000000                           	.asect				; absolute load image;	
      34                                
      35        000046                  	.=46
      36 000046 006010                  	.word	$endad			; address of JSR PC,(R0)
      37        000052                  	.=52
      38 000052 000000                  	.word	0			; run options
      39                                
      40        000200                  	.=200
      41 000200 000137  004000          	jmp	@#start			; standard diagnostic entry
      42                                
      43                                ; --------------------------------------------------------------------------------
      44                                
      45                                .sbttl	global variables
      46                                
      47 000204                         	align	10.
      48                                
      49 002000 177777                  stack:	.word	-1			; top of stack
      50 002002 000000                  switch:	.word	0			; option switches:
      51        000001                  sw_lst	=bit00				;   set for verbose printout on each block
      52        000002                  sw_dot	=bit01				;   set for dot print
      53 002004 000000                  $sav42:	.word	0			; XXDP restart address
      54 002006 000000                  unit:	.word	0			; 0 or 1, unit ID
      55 002010 000001                  densty:	.word	1			; 0 (single) or 1 (double) density
      56 002012 000000                  base:	.word	0			; density and unit
      57 002014 000000                  sector:	.word	0			; sector address
      58 002016 000000                  track:	.word	0			; track address
      59 002020 000000                  ticker:	.word	0			; tick count
      60 002022 000200                  count:	.word	rx_wps			; word count
      61 002024 002410                  bufptr:	.word	buffer			; a(buffer)
      62 002026 002400                  errptr:	.word	errbuf			; a(errbuf)
      63                                
      64 002030                         	align	8.
      65                                
      66        002400                  errbuf:	.blkw	4			; error buffer
      67        002410                  buffer:	.blkw	rx_wps			; sector buffer
      68                                
      69                                ; --------------------------------------------------------------------------------
      70                                	
      71                                .sbttl	main program
      72                                	
      73 003010                         	align	11.
      74                                
      75 004000 012706  002000          start:	mov	#stack,sp		; setup stack
      76 004004 000005                  	reset				; reset the world
      77 004006 013737  000042  002004  	mov	@#42,$sav42		; save XXDP restart
      78                                
      79 004014                         	trapcatcher <2,200,206,400>	; setup a trapcatcher in low vector space
       1 004014 012700  004044          	mov	#32770$,r0    		; ptr to table
       2 004020 012001                  32768$:	mov	(r0)+,r1		; start addr
       3 004022 100415                  	bmi	32771$			; done?
       4 004024 012002                  	mov	(r0)+,r2		; end addr
       5 004026 010161  177776          32769$:	mov	r1,-2(r1)		; point vector at next word
       6 004032 005011                  	clr	(r1)			; <0> which is a halt
       7 004034 022121                  	cmp	(r1)+,(r1)+		; add four to ptr
       8 004036 020102                  	cmp	r1,r2			; reached end?
       9 004040 003772                  	ble	32769$			; not yet
      10 004042 000766                  	br	32768$			; more
      11 004044 000002  000200  000206  32770$:	.word	2,200,206,400, -1
         004052 000400  177777          
      12 004056 000240                  32771$:	nop				; placeholder
      80                                
      81 004060                         	printf	#msg1			; say hello
       1 004060                         	calls	printf #msg1               
       9 004060 012746  005724          	mov	#msg1,-(sp)
       2 004064                         	call	printf
       1 004064 004737  006464          	jsr	pc,printf
       3 004070 062706  000002          	add	#2,sp
      82                                	
      83 004074 005037  002020          	clr	ticker			; init tick count
      84                                	
      85 004100 012737  006044  000100  	mov	#lkintr,lk$vec+0	; intr routine for line clock
      86 004106 012737  000300  000102  	mov	#lk_pri*bit5,lk$vec+2	; psw for intr service
      87 004114 052737  000100  177546  	bis	#lk_ien,@#lk$csr	; enable line clock interrupts
      88                                
      89 004122 005046                  	clr	-(sp)			; zap psw
      90 004124 012746  004132          	mov	#1$,-(sp)		; fake pc
      91 004130 000002                  	rti				; reload psw
      92 004132 000240                  1$:	nop				; placeholder
      93                                
      94                                	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      95                                
      96                                	; init sequence
      97                                
      98 004134 052777  040000  001730  	bis	#rc_init,@rxcs		; set INIT
      99                                
     100 004142                         	call	delay			; wait
       1 004142 004737  006060          	jsr	pc,delay
     101                                
     102 004146 017700  001720          	mov	@rxcs,r0		; get value with INIT set
     103 004152 042700  072017          	bic	#rc_wocs,r0		;
     104 004156 017701  001712          	mov	@rxdb,r1		;
     105 004162 042701  170000          	bic	#rc_woes,r1		;  
     106                                
     107                                	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     108                                
     109                                	; setup unit and density bits in cs
     110                                
     111 004166 013701  002006          	mov	unit,r1			; unit number (0,1)
     112 004172 005401                  	neg	r1			; make (000000,177777)
     113 004174 042701  177757          	bic	#^c<rc_unit>,r1		; mask
     114 004200 010137  002012          	mov	r1,base			; store
     115                                
     116 004204 013701  002010          	mov	densty,r1		; data density (0,1)
     117 004210 005401                  	neg	r1			; make (000000,177777)
     118 004212 042701  177377          	bic	#^c<rc_den>,r1		; mask
     119 004216 050137  002012          	bis	r1,base			; merge
     120                                
     121 004222 013701  002010          	mov	densty,r1		; data density
     122 004226 062701  000061          	add	#<'1>,r1		; make 1 or 2 for print
     123 004232                         	printf	#200$,unit,r1		; status
       1 004232                         	calls	printf #200$ unit r1             
       9 004232 010146                  	mov	r1,-(sp)
      15 004234 013746  002006          	mov	unit,-(sp)
      21 004240 012746  005374          	mov	#200$,-(sp)
       2 004244                         	call	printf
       1 004244 004737  006464          	jsr	pc,printf
       3 004250 062706  000006          	add	#6,sp
     124                                
     125                                	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     126                                
     127                                	; check media density
     128                                
     129 004254 013702  002012          	mov	base,r2			; density and unit
     130 004260                         	call	rxstat			; read status
       1 004260 004737  006412          	jsr	pc,rxstat
     131 004264                         	printf	#102$,r0,r1		; print rxcs and rxdb
       1 004264                         	calls	printf #102$ r0 r1             
       9 004264 010146                  	mov	r1,-(sp)
      15 004266 010046                  	mov	r0,-(sp)
      21 004270 012746  005200          	mov	#102$,-(sp)
       2 004274                         	call	printf
       1 004274 004737  006464          	jsr	pc,printf
       3 004300 062706  000006          	add	#6,sp
     132                                
     133                                	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     134                                
     135                                	; setup track/sector loop
     136                                
     137 004304                         	printf	#203$			; print header
       1 004304                         	calls	printf #203$               
       9 004304 012746  005570          	mov	#203$,-(sp)
       2 004310                         	call	printf
       1 004310 004737  006464          	jsr	pc,printf
       3 004314 062706  000002          	add	#2,sp
     138                                
     139 004320 005037  002020          	clr	ticker			; init tick count
     140                                
     141 004324 012737  000000  002016  	mov	#rx_tal,track		; starting track
     142                                
     143 004332 012737  000001  002014  10$:	mov	#rx_sal,sector		; starting sector
     144                                
     145 004340 032737  000001  002002  20$:	bit	#sw_lst,switch		; check if verbose
     146 004346 001414                  	beq	21$			; br if not
     147 004350                         	printf	#201$,unit,track,sector	; status
       1 004350                         	calls	printf #201$ unit track sector            
       9 004350 013746  002014          	mov	sector,-(sp)
      15 004354 013746  002016          	mov	track,-(sp)
      21 004360 013746  002006          	mov	unit,-(sp)
      27 004364 012746  005442          	mov	#201$,-(sp)
       2 004370                         	call	printf
       1 004370 004737  006464          	jsr	pc,printf
       3 004374 062706  000010          	add	#10,sp
     148 004400 000240                  21$:	nop				; 
     149                                
     150                                	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     151                                
     152                                	; read a sector
     153                                
     154 004402 013700  002014          	mov	sector,r0		; sector address
     155 004406 013701  002016          	mov	track,r1		; track address
     156 004412 013702  002012          	mov	base,r2			; density and unit
     157 004416                          	call	rxrd			; read current sector
       1 004416 004737  006104          	jsr	pc,rxrd
     158                                
     159 004422 032737  000001  002002  	bit	#sw_lst,switch		; check if verbose
     160 004430 001410                  	beq	49$			; br if not
     161 004432                         	printf	#104$,r0,r1		; print rxcs and rxdb
       1 004432                         	calls	printf #104$ r0 r1             
       9 004432 010146                  	mov	r1,-(sp)
      15 004434 010046                  	mov	r0,-(sp)
      21 004436 012746  005276          	mov	#104$,-(sp)
       2 004442                         	call	printf
       1 004442 004737  006464          	jsr	pc,printf
       3 004446 062706  000006          	add	#6,sp
     162 004452 000240                  49$:	nop				; 
     163                                
     164                                	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     165                                
     166                                	; read extended status
     167                                
     168 004454 005000                  	clr	r0			; not used
     169 004456 013701  002026          	mov	errptr,r1		; buffer pointer
     170 004462 013702  002012          	mov	base,r2			; density and unit
     171 004466                           	call	rxrdes			; read extended status
       1 004466 004737  006272          	jsr	pc,rxrdes
     172                                
     173 004472 032737  000001  002002  	bit	#sw_lst,switch		; check if verbose
     174 004500 001441                  	beq	59$			; br if not
     175                                
     176 004502                         	printf	#105$,r0,r1		; print rxcs and rxdb
       1 004502                         	calls	printf #105$ r0 r1             
       9 004502 010146                  	mov	r1,-(sp)
      15 004504 010046                  	mov	r0,-(sp)
      21 004506 012746  005335          	mov	#105$,-(sp)
       2 004512                         	call	printf
       1 004512 004737  006464          	jsr	pc,printf
       3 004516 062706  000006          	add	#6,sp
     177                                
     178 004522 012700  000001          	mov	#1,r0			; word counter
     179 004526 013701  002026          	mov	errptr,r1		; buffer pointer
     180 004532 005002                  50$:	clr	r2			; lower byte
     181 004534 152102                  	bisb	(r1)+,r2		; 
     182 004536 005003                  	clr	r3			; upper byte
     183 004540 152103                  	bisb	(r1)+,r3		; 
     184 004542                         	printf	#202$,r0,r3,r3,r3,r2,r2,r2 ; print
       1 004542                         	calls	printf #202$ r0 r3 r3 r3 r2 r2 r2        
       9 004542 010246                  	mov	r2,-(sp)
      15 004544 010246                  	mov	r2,-(sp)
      21 004546 010246                  	mov	r2,-(sp)
      27 004550 010346                  	mov	r3,-(sp)
      33 004552 010346                  	mov	r3,-(sp)
      39 004554 010346                  	mov	r3,-(sp)
      45 004556 010046                  	mov	r0,-(sp)
      51 004560 012746  005516          	mov	#202$,-(sp)
       2 004564                         	call	printf
       1 004564 004737  006464          	jsr	pc,printf
       3 004570 062706  000020          	add	#20,sp
     185 004574 005200                  	inc	r0			; count
     186 004576 020027  000004          	cmp	r0,#4			; loop end
     187 004602 003753                  	ble	50$			; br if more
     188                                	
     189 004604 000240                  59$:	nop				; 
     190                                
     191                                	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     192                                
     193                                	; empty sector buffer
     194                                
     195 004606 013700  002022          	mov	count,r0		; word count
     196 004612 013701  002024          	mov	bufptr,r1		; buffer address
     197 004616 013702  002012          	mov	base,r2			; density and unit
     198 004622                          	call	rxempt			; empty sector buffer
       1 004622 004737  006202          	jsr	pc,rxempt
     199                                
     200 004626 032737  000001  002002  	bit	#sw_lst,switch		; check if verbose
     201 004634 001410                  	beq	61$			; br if not
     202 004636                         	printf	#103$,r0,r1		; print rxcs and rxdb
       1 004636                         	calls	printf #103$ r0 r1             
       9 004636 010146                  	mov	r1,-(sp)
      15 004640 010046                  	mov	r0,-(sp)
      21 004642 012746  005237          	mov	#103$,-(sp)
       2 004646                         	call	printf
       1 004646 004737  006464          	jsr	pc,printf
       3 004652 062706  000006          	add	#6,sp
     203 004656 000240                  61$:	nop				; 
     204                                
     205                                	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     206                                
     207                                	; dump buffer data
     208                                
     209 004660 032737  000001  002002  	bit	#sw_lst,switch		; check if verbose
     210 004666 001455                  	beq	76$			; br if not
     211                                
     212 004670 013700  002022          	mov	count,r0		; word count
     213 004674 013701  002024          	mov	bufptr,r1		; buffer pointer
     214 004700 005002                  	clr	r2			; checksum
     215 004702 005004                  	clr	r4			; index
     216 004704 012103                  70$:	mov	(r1)+,r3		; get data word
     217 004706 060302                  	add	r3,r2			; compute checksum
     218 004710                         	printf	#214$,r3		; print
       1 004710                         	calls	printf #214$ r3              
       9 004710 010346                  	mov	r3,-(sp)
      15 004712 012746  005647          	mov	#214$,-(sp)
       2 004716                         	call	printf
       1 004716 004737  006464          	jsr	pc,printf
       3 004722 062706  000004          	add	#4,sp
     219 004726 000303                  	swab	r3			; swap
     220 004730                         	printf	#214$,r3		; print
       1 004730                         	calls	printf #214$ r3              
       9 004730 010346                  	mov	r3,-(sp)
      15 004732 012746  005647          	mov	#214$,-(sp)
       2 004736                         	call	printf
       1 004736 004737  006464          	jsr	pc,printf
       3 004742 062706  000004          	add	#4,sp
     221 004746 000303                  	swab	r3			; swap
     222 004750 005204                  	inc	r4			; bump
     223 004752 042704  177740          	bic	#^c37,r4		; mask to low 5 bits
     224 004756 001006                  	bne	71$			; br if non zero
     225 004760                         	printf	#213$			; print crlf
       1 004760                         	calls	printf #213$               
       9 004760 012746  005644          	mov	#213$,-(sp)
       2 004764                         	call	printf
       1 004764 004737  006464          	jsr	pc,printf
       3 004770 062706  000002          	add	#2,sp
     226 004774 005300                  71$:	dec	r0			; decr word cound
     227 004776 001342                  	bne	70$			; loop if more
     228 005000 164102                  	sub	-(r1),r2		; back out last two words
     229 005002 164102                  	sub	-(r1),r2		; 
     230 005004                         	printf	#215$,r2		; print checksum
       1 005004                         	calls	printf #215$ r2              
       9 005004 010246                  	mov	r2,-(sp)
      15 005006 012746  005652          	mov	#215$,-(sp)
       2 005012                         	call	printf
       1 005012 004737  006464          	jsr	pc,printf
       3 005016 062706  000004          	add	#4,sp
     231                                
     232 005022 000240                  76$:	nop				; 
     233                                
     234                                	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     235                                
     236                                	; sector / track loop
     237                                
     238 005024 032737  000002  002002  	bit	#sw_dot,switch		; check if verbose
     239 005032 001406                  	beq	82$			; br if not
     240 005034                         	printf	#216$			; '.'
       1 005034                         	calls	printf #216$               
       9 005034 012746  005670          	mov	#216$,-(sp)
       2 005040                         	call	printf
       1 005040 004737  006464          	jsr	pc,printf
       3 005044 062706  000002          	add	#2,sp
     241 005050 000240                  82$:	nop				;
     242                                
     243 005052 005237  002014          	inc	sector			; bump sector
     244 005056 023727  002014  000032  	cmp	sector,#rx_sah		; hit maximum?
     245 005064                         	jle	20$			; loop if more
       1 005064 003002                  	bgt	32772$
       2 005066 000137  004340          	jmp	20$
       3                                32772$:
     246                                
     247 005072 032737  000002  002002  	bit	#sw_dot,switch		; check if verbose
     248 005100 001406                  	beq	84$			; br if not
     249 005102                         	printf	#213$			; crlf
       1 005102                         	calls	printf #213$               
       9 005102 012746  005644          	mov	#213$,-(sp)
       2 005106                         	call	printf
       1 005106 004737  006464          	jsr	pc,printf
       3 005112 062706  000002          	add	#2,sp
     250 005116 000240                  84$:	nop				;
     251                                
     252 005120 005237  002016          	inc	track			; bump track
     253 005124 023727  002016  000114  	cmp	track,#rx_tah		; hit maximum?
     254 005132                         	jle	10$			; loop if more
       1 005132 003002                  	bgt	32773$
       2 005134 000137  004332          	jmp	10$
       3                                32773$:
     255                                
     256                                	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     257                                
     258                                	; done
     259                                
     260 005140                         90$:	printf	#217$,ticker		; print tick count
       1 005140                         	calls	printf #217$ ticker              
       9 005140 013746  002020          	mov	ticker,-(sp)
      15 005144 012746  005672          	mov	#217$,-(sp)
       2 005150                         	call	printf
       1 005150 004737  006464          	jsr	pc,printf
       3 005154 062706  000004          	add	#4,sp
     261                                
     262 005160                         	printf	#400$			; status
       1 005160                         	calls	printf #400$               
       9 005160 012746  005712          	mov	#400$,-(sp)
       2 005164                         	call	printf
       1 005164 004737  006464          	jsr	pc,printf
       3 005170 062706  000002          	add	#2,sp
     263 005174 000137  005764          	jmp	done			; all done
     264                                
     265                                ; --------------------------------------------------------------------------------
     266                                
     267 005200    163     164     141  102$:	.asciz	"status:  rxcs=%06o rxdb=%06o"<cr><lf>
         005203    164     165     163  
         005206    072     040     040  
         005211    162     170     143  
         005214    163     075     045  
         005217    060     066     157  
         005222    040     162     170  
         005225    144     142     075  
         005230    045     060     066  
         005233    157     015     012  
         005236    000                  
     268 005237    145     155     160  103$:	.asciz	"empty:   rxcs=%06o rxdb=%06o"<cr><lf>
         005242    164     171     072  
         005245    040     040     040  
         005250    162     170     143  
         005253    163     075     045  
         005256    060     066     157  
         005261    040     162     170  
         005264    144     142     075  
         005267    045     060     066  
         005272    157     015     012  
         005275    000                  
     269 005276    162     145     141  104$:	.asciz	"read:    rxcs=%06o rxdb=%06o"<cr><lf>
         005301    144     072     040  
         005304    040     040     040  
         005307    162     170     143  
         005312    163     075     045  
         005315    060     066     157  
         005320    040     162     170  
         005323    144     142     075  
         005326    045     060     066  
         005331    157     015     012  
         005334    000                  
     270 005335    145     162     162  105$:	.asciz	"errstat: rxcs=%06o rxdb=%06o"<cr><lf>
         005340    163     164     141  
         005343    164     072     040  
         005346    162     170     143  
         005351    163     075     045  
         005354    060     066     157  
         005357    040     162     170  
         005362    144     142     075  
         005365    045     060     066  
         005370    157     015     012  
         005373    000                  
     271                                
     272 005374    015     012     141  200$:	.asciz	<cr><lf>"assuming drive=%d density=%cX ..."<cr><lf>
         005377    163     163     165  
         005402    155     151     156  
         005405    147     040     144  
         005410    162     151     166  
         005413    145     075     045  
         005416    144     040     144  
         005421    145     156     163  
         005424    151     164     171  
         005427    075     045     143  
         005432    130     040     056  
         005435    056     056     015  
         005440    012     000          
     273 005442    015     012     162  201$:	.asciz	<cr><lf>"reading drive=%d track=%d sector=%d ..."<cr><lf>
         005445    145     141     144  
         005450    151     156     147  
         005453    040     144     162  
         005456    151     166     145  
         005461    075     045     144  
         005464    040     164     162  
         005467    141     143     153  
         005472    075     045     144  
         005475    040     163     145  
         005500    143     164     157  
         005503    162     075     045  
         005506    144     040     056  
         005511    056     056     015  
         005514    012     000          
     274 005516    167     157     162  202$:	.asciz	"word%d: %3d[%03o](%08b) %3d[%03o](%08b)"<cr><lf>
         005521    144     045     144  
         005524    072     040     045  
         005527    063     144     133  
         005532    045     060     063  
         005535    157     135     050  
         005540    045     060     070  
         005543    142     051     040  
         005546    045     063     144  
         005551    133     045     060  
         005554    063     157     135  
         005557    050     045     060  
         005562    070     142     051  
         005565    015     012     000  
     275 005570    015     012     162  203$:	.asciz	<cr><lf>"reading all sectors of all tracks ..."<cr><lf><cr><lf>
         005573    145     141     144  
         005576    151     156     147  
         005601    040     141     154  
         005604    154     040     163  
         005607    145     143     164  
         005612    157     162     163  
         005615    040     157     146  
         005620    040     141     154  
         005623    154     040     164  
         005626    162     141     143  
         005631    153     163     040  
         005634    056     056     056  
         005637    015     012     015  
         005642    012     000          
     276                                
     277 005644    015     012     000  213$:	.asciz	<cr><lf>
     278 005647    045     143     000  214$:	.asciz	"%c"
     279 005652    143     150     153  215$:	.asciz	"chksum=%04x"<cr><lf>
         005655    163     165     155  
         005660    075     045     060  
         005663    064     170     015  
         005666    012     000          
     280 005670    056     000          216$:	.asciz	"."
     281 005672    056     056     056  217$:	.asciz	"... ticks=%u."<cr><lf>
         005675    040     164     151  
         005700    143     153     163  
         005703    075     045     165  
         005706    056     015     012  
         005711    000                  
     282                                
     283 005712    015     012     104  400$:	.asciz	<cr><lf>"Done!"<cr><lf>
         005715    157     156     145  
         005720    041     015     012  
         005723    000                  
     284                                
     285 005724    015     012     122  msg1:	.asciz	<cr><lf>"RX211 read v1.0"<cr><lf>
         005727    130     062     061  
         005732    061     040     162  
         005735    145     141     144  
         005740    040     166     061  
         005743    056     060     015  
         005746    012     000          
     286 005750    015     012     107  msg2:	.asciz	<cr><lf>"Goodbye"<cr><lf>
         005753    157     157     144  
         005756    142     171     145  
         005761    015     012     000  
     287                                	.even
     288                                
     289                                ; --------------------------------------------------------------------------------
     290                                
     291 005764                         done:	printf	#msg2			; say goodbye
       1 005764                         	calls	printf #msg2               
       9 005764 012746  005750          	mov	#msg2,-(sp)
       2 005770                         	call	printf
       1 005770 004737  006464          	jsr	pc,printf
       3 005774 062706  000002          	add	#2,sp
     292                                
     293 006000 013700  002004          exit:	mov	$sav42,r0		; check if loaded by XXDP
     294 006004 001407                  	beq	noxxdp			; br if not
     295 006006 000005                  	reset				; yes, reset the world
     296 006010 004710                  $endad:	jsr	pc,(r0)			; return back to XXDP
     297 006012 000240                  	nop				; standard sequence
     298 006014 000240                  	nop				;
     299 006016 000240                  	nop				;
     300 006020 000137  004000          	jmp	start			; back for more
     301                                
     302 006024 005000                  noxxdp:	clr	r0			;
     303 006026 077001                  	sob	r0,.			; some delay
     304 006030 000005                  	reset				; zap the world
     305 006032 012746  000340          	mov	#<7>*bit5,-(sp)		; prio7 in psw
     306 006036 012746  165144          	mov	#console,-(sp)		; go there
     307 006042 000002                  	rti				; reload psw
     308                                	
     309                                ; --------------------------------------------------------------------------------
     310                                
     311                                .sbttl	line clock interrupt routine
     312                                
     313 006044 005237  002020          lkintr:	inc	ticker			;*6* incre tickcount
     314 006050 042737  000200  177546  	bic	#lk_mon,lk$csr		;*6* clear monitor bit
     315 006056 000002                  	rti				;*6* and done
     316                                
     317                                ; --------------------------------------------------------------------------------
     318                                	
     319                                .sbttl	local routines
     320                                
     321                                ; delay
     322                                
     323 006060 005000                  delay:	clr	r0			; init counter
     324 006062 010000                  1$:	mov	r0,r0			; waste time
     325 006064 005300                  	dec	r0			; count
     326 006066 001375                  	bne	1$			; loop
     327 006070                         	return				; 
       1 006070 000207                  	rts	pc
     328                                
     329                                ; --------------------------------------------------------------------------------
     330                                	
     331                                .sbttl	support routines
     332                                
     333                                .include "rx/driver.mac"
       1                                
       2                                ; --------------------------------------------------------------------------------
       3                                
       4                                ; RX211/RX02 device support routines
       5                                
       6 006072 177170                  rxcs:	.word	rx$cs			; a(rxcs)
       7 006074 177172                  rxdb:	.word	rx$db			; a(rxdb)
       8                                
       9                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      10                                
      11                                ; initiate a sector read/write
      12                                ;
      13                                ; arguments: r0	= sector address
      14                                ;            r1	= track address
      15                                ;	     r2	= density, unit
      16                                ; 
      17                                ; return:    r0 = operation status from @rxcs (set cc)
      18                                ;            r1 = operation status from @rxdb
      19                                ;            r2	= density, unit, command, go
      20                                
      21 006076 052702  000005          rxwr:	bis	#rc_wr+rc_go,r2		; write sector and go
      22 006102 000403                  	br	rxrdwr			; do read/write sequence
      23                                
      24 006104 052702  000007          rxrd:	bis	#rc_rd+rc_go,r2		; read sector and go
      25 006110 000400                  	br	rxrdwr			; do read/write sequence
      26                                
      27 006112 032777  000040  177752  rxrdwr:	bit	#rc_done,@rxcs		; wait for done
      28 006120 001774                  	beq	rxrdwr			; br if not yet
      29                                	
      30 006122 010277  177744          	mov	r2,@rxcs		; execute command
      31                                	
      32 006126 032777  100200  177736  1$:	bit	#rc_treq+rc_error,@rxcs	; wait for transfer request or error
      33 006134 001774                  	beq	1$			; br if not yet
      34 006136 100411                  	bmi	8$			; br if error
      35                                	
      36 006140 010077  177730          	mov	r0,@rxdb		; sector address
      37                                	
      38 006144 032777  100200  177720  2$:	bit	#rc_treq+rc_error,@rxcs	; wait for transfer request or error
      39 006152 001774                  	beq	2$			; br if not yet
      40 006154 100402                  	bmi	8$			; br if error
      41                                	
      42 006156 010177  177712          	mov	r1,@rxdb		; track address
      43                                	
      44 006162 032777  100040  177702  8$:	bit	#rc_done+rc_error,@rxcs	; wait for done or error
      45 006170 001774                  	beq	8$			; br if not yet
      46                                	
      47 006172 000523                  9$:	br	rxret			; cleanup
      48                                
      49                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      50                                
      51                                ; initiate a buffer fill/empty
      52                                ;
      53                                ; arguments: r0	= word count
      54                                ;            r1	= buffer address
      55                                ;	     r2	= density, unit
      56                                ; 
      57                                ; return:    r0 = operation status from @rxcs (set cc)
      58                                ;            r1 = operation status from @rxdb
      59                                ;            r2	= density, unit, command, go
      60                                	
      61 006174 052702  000001          rxfill:	bis	#rc_fill+rc_go,r2	; fill buffer and go
      62 006200 000403                  	br	rxflem			; do fill/empty sequence
      63                                
      64 006202 052702  000003          rxempt:	bis	#rc_empt+rc_go,r2	; empty buffer and go
      65 006206 000400                  	br	rxflem			; do fill/empty sequence
      66                                
      67 006210 032777  000040  177654  rxflem:	bit	#rc_done,@rxcs		; wait for done
      68 006216 001774                  	beq	rxflem			; br if not yet
      69                                	
      70 006220 010277  177646          	mov	r2,@rxcs		; execute command
      71                                	
      72 006224 032777  100200  177640  1$:	bit	#rc_treq+rc_error,@rxcs	; wait for transfer request or error
      73 006232 001774                  	beq	1$			; br if not yet
      74 006234 100411                  	bmi	8$			; br if error
      75                                
      76 006236 010077  177632          	mov	r0,@rxdb		; word count
      77                                
      78 006242 032777  100200  177622  2$:	bit	#rc_treq+rc_error,@rxcs	; wait for transfer request or error
      79 006250 001774                  	beq	2$			; br if not yet
      80 006252 100402                  	bmi	8$			; br if error
      81                                	
      82 006254 010177  177614          	mov	r1,@rxdb		; buffer address
      83                                	
      84 006260 032777  100040  177604  8$:	bit	#rc_done+rc_error,@rxcs	; wait for done or error
      85 006266 001774                  	beq	8$			; br if not yet
      86                                	
      87 006270 000464                  9$:	br	rxret			; cleanup
      88                                
      89                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      90                                
      91                                ; read extended error status
      92                                ;
      93                                ; arguments: r0	= n/a
      94                                ;            r1	= buffer address
      95                                ;	     r2	= density, unit
      96                                ; 
      97                                ; return:    r0 = operation status from @rxcs (set cc)
      98                                ;            r1 = operation status from @rxdb
      99                                ;            r2	= density, unit, command, go
     100                                	
     101 006272 052702  000017          rxrdes:	bis	#rc_rde+rc_go,r2	; read error status and go
     102                                
     103 006276 032777  000040  177566  1$:	bit	#rc_done,@rxcs		; wait for done
     104 006304 001774                  	beq	1$			; br if not yet
     105                                	
     106 006306 010277  177560          	mov	r2,@rxcs		; execute command
     107                                	
     108 006312 032777  100200  177552  2$:	bit	#rc_treq+rc_error,@rxcs	; wait for transfer request or error
     109 006320 001774                  	beq	2$			; br if not yet
     110 006322 100402                  	bmi	8$			; br if error
     111                                
     112 006324 010177  177544           	mov	r1,@rxdb		; buffer address
     113                                	
     114 006330 032777  100040  177534  8$:	bit	#rc_done+rc_error,@rxcs	; wait for done or error
     115 006336 001774                  	beq	8$			; br if not yet
     116                                	
     117 006340 000440                  9$:	br	rxret			; cleanup
     118                                
     119                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     120                                
     121                                ; set media density
     122                                ;
     123                                ; arguments: r0	= n/a
     124                                ;            r1	= <'I> unlock code
     125                                ;	     r2	= density, unit
     126                                ; 
     127                                ; return:    r0 = operation status from @rxcs (set cc)
     128                                ;            r1 = operation status from @rxdb
     129                                ;            r2	= density, unit, command, go
     130                                
     131 006342 052702  000011          rxsden:	bis	#rc_sde+rc_go,r2	; set media density and go
     132                                	
     133 006346 032777  000040  177516  1$:	bit	#rc_done,@rxcs		; wait for done
     134 006354 001774                  	beq	1$			; br if not yet
     135                                
     136 006356 010277  177510          	mov	r2,@rxcs		; execute command
     137                                	
     138 006362 032777  100200  177502  2$:	bit	#rc_treq+rc_error,@rxcs	; wait for transfer request or error
     139 006370 001774                  	beq	2$			; br if not yet
     140 006372 100402                  	bmi	8$			; br if error
     141                                	
     142 006374 010177  177474          	mov	r1,@rxdb		; unlock code
     143                                	
     144 006400 032777  100040  177464  8$:	bit	#rc_done+rc_error,@rxcs	; wait for done or error
     145 006406 001774                  	beq	8$			; br if not yet
     146                                	
     147 006410 000414                  9$:	br	rxret			; cleanup
     148                                
     149                                ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     150                                
     151                                ; read status
     152                                ;
     153                                ; arguments: r0	= n/a
     154                                ;            r1	= n/a
     155                                ;	     r2	= density, unit
     156                                ; 
     157                                ; return:    r0 = operation status from @rxcs (set cc)
     158                                ;            r1 = operation status from @rxdb
     159                                ;            r2	= density, unit, command, go
     160                                	
     161 006412 052702  000013          rxstat:	bis	#rc_rds+rc_go,r2	; read status and go
     162                                
     163 006416 032777  000040  177446  1$:	bit	#rc_done,@rxcs		; wait for done
     164 006424 001774                  	beq	1$			; br if not yet
     165                                
     166 006426 010277  177440          	mov	r2,@rxcs		; execute command
     167                                	
     168 006432 032777  100040  177432  2$:	bit	#rc_done+rc_error,@rxcs	; wait for done or error
     169 006440 001774                  	beq	2$			; br if not yet
     170                                	
     171 006442 017701  177426          rxret:	mov	@rxdb,r1		; get RXES
     172 006446 042701  170000          	bic	#rc_woes,r1		; mask d/c bits
     173 006452 017700  177414          	mov	@rxcs,r0		; get RXCS
     174 006456 042700  072017          	bic	#rc_wocs,r0		; mask d/c bits
     175 006462                         	return				; return
       1 006462 000207                  	rts	pc
     176                                
     177                                ; --------------------------------------------------------------------------------
     178                                
     178                                
     334                                
     335                                .include "mac/printf.mac"
       1                                ;================================================================================
       2                                ; printf.mac - printf routines for macro11 diagnostics
       3                                ; (C) 2009-2016 Donald North. All rights reserved.
       4                                ;================================================================================
       5                                
       6                                .if ndf ttxcsr
       7                                	
       8                                	; separate psect (if console registers not defined)
       9                                	.psect	printf
      10                                
      11                                	; external tty references
      12                                	.globl	ttxcsr, ttxbuf
      13                                
      14                                	; standard macro definitions
      15                                 	.include "mac/stddef.mac"
      16                                
      17                                pf.sep	=1 ; flag separate compilation
      18                                
      19                                .iff
      20                                
      21        000000                  pf.sep	=0 ; flag unified compilation (via include)
      22                                	
      23                                .endc
      24                                ; 
      25                                ; global registers:
      26                                ;
      27                                ;  R5 - frame pointer
      28                                ;  R4 - argument pointer
      29                                ;  R3 - format string pointer
      30                                ;  R2 - current format character
      31                                ;  R1 - temp
      32                                ;  R0 - temp
      33                                ;
      34                                ; note:	for 11/04-05-10 compatibility, do NOT use SXT/XOR/SOB and MUL/DIV/ASH/ASHC
      35                                ; 
      36                                ; offsets from frame pointer (r5):
      37                                ; 
      38        000012                  p.sr0	=+10.	; saved r0
      39        000010                  p.sr1	=+8.	; saved r1
      40        000006                  p.sr2	=+6.	; saved r2
      41        000004                  p.sr3	=+4.	; saved r3
      42        000002                  p.sr4	=+2.	; saved r4
      43        000000                  p.sr5	=+0.	; saved r5
      44        177777                  p.flg	=-1.	; format flags (byte)
      45        177776                  p.fil	=-2.	; fill character (byte)
      46        177774                  p.wid	=-4.	; format numeric width (word)
      47        177772                  p.pre	=-6.	; format numeric precision (word)
      48        177770                  p.len	=-8.	; number of digits generated (word)
      49        177766                  p.out	=-10.	; addr(char print routine)
      50        177764                  p.ptr	=-12.	; sprintf output buffer pointer
      51                                ; 
      52        000014                  n.last	=+12.	; number of bytes allocated on stack
      53        000016                  n.args	=+14.	; offset to first argument on stack
      54                                ; 
      55                                ; bits in p.flg byte:
      56                                ; 
      57        000001                  pf.ljus	=1	; set for left justified ('-' seen)
      58        000002                  pf.sign	=2	; set for sign requested ('+' seen)
      59        000004                  pf.altf	=4	; set for alt flag ('#' seen)
      60        000010                  pf.long	=10	; set for long value (%...l. seen)
      61        000020                  pf.nega	=20	; set for negative value (msb set)
      62                                
      63                                ; --------------------------------------------------------------------------------
      64                                ;
      65                                ; printf routine .. 'C' printf(format,arg1,arg2,..,argn) ..  called in 'C' style
      66                                ;
      67                                ;	call:	mov	argN,-(sp)
      68                                ;		...
      69                                ;		mov	arg2,-(sp)
      70                                ;		mov	arg1,-(sp)
      71                                ;		mov	format,-(sp)
      72                                ;		call	printf
      73                                ;		add	#2*N,sp
      74                                ;
      75 006464 010046                  printf::mov	r0,-(sp)		; save reg
      76 006466 010146                  	mov	r1,-(sp)		;
      77 006470 010246                  	mov	r2,-(sp)		;
      78 006472 010346                  	mov	r3,-(sp)		;
      79 006474 010446                  	mov	r4,-(sp)		;
      80 006476 010546                  	mov	r5,-(sp)		;
      81                                	
      82 006500 010605                  	mov	sp,r5			; frame pointer
      83 006502 162706  000014          	sub	#n.last,sp		; reserve space on stack
      84                                	
      85 006506 010504                  	mov	r5,r4			; get frame ptr
      86 006510 062704  000016          	add	#n.args,r4		; offset to first argument
      87                                	
      88 006514 012765  006530  177766  	mov	#1$,p.out(r5)		; character output routine
      89 006522 005065  177764          	clr	p.ptr(r5)		; bufptr not used here
      90                                	
      91 006526 000442                  	br	xprintf			; continue
      92                                
      93                                	; ---------------------------------------------------------
      94                                	
      95                                	; character output to console
      96                                	
      97 006530 105737  177564          1$:	tstb	@#ttxcsr		; check if ready
      98 006534 100375                  	bpl	1$			; not yet
      99 006536 110037  177566          	movb	r0,@#ttxbuf		; send character
     100 006542                         	return				; return
       1 006542 000207                  	rts	pc
     101                                	
     102                                ; --------------------------------------------------------------------------------
     103                                ;
     104                                ; sprintf routine .. 'C' sprintf(buffer,format,arg1,arg2,..,argn) ..  called in 'C' style
     105                                ;
     106                                ;	call:	mov	argN,-(sp)
     107                                ;		...
     108                                ;		mov	arg2,-(sp)
     109                                ;		mov	arg1,-(sp)
     110                                ;		mov	format,-(sp)
     111                                ;		mov	buffer,-(sp)
     112                                ;		call	sprintf
     113                                ;		add	#2*N,sp
     114                                ;
     115 006544 010046                  sprintf::mov	r0,-(sp)		; save reg
     116 006546 010146                  	mov	r1,-(sp)		;
     117 006550 010246                  	mov	r2,-(sp)		;
     118 006552 010346                  	mov	r3,-(sp)		;
     119 006554 010446                  	mov	r4,-(sp)		;
     120 006556 010546                  	mov	r5,-(sp)		;
     121                                	
     122 006560 010605                  	mov	sp,r5			; frame pointer
     123 006562 162706  000014          	sub	#n.last,sp		; reserve space on stack
     124                                	
     125 006566 010504                  	mov	r5,r4			; get frame ptr
     126 006570 062704  000016          	add	#n.args,r4		; offset to first argument
     127                                	
     128 006574 012765  006610  177766  	mov	#1$,p.out(r5)		; character output routine
     129 006602 012465  177764          	mov	(r4)+,p.ptr(r5)		; init bufptr from argument
     130                                	
     131 006606 000412                  	br	xprintf			; continue
     132                                
     133                                	; ---------------------------------------------------------
     134                                	
     135                                	; character output to buffer
     136                                	
     137 006610 110075  177764          1$:	movb	r0,@p.ptr(r5)		; store character
     138 006614 005265  177764          	inc	p.ptr(r5)		; bump pointer
     139 006620 105075  177764          	clrb	@p.ptr(r5)		; null terminate
     140 006624 016565  177764  000012  	mov	p.ptr(r5),p.sr0(r5)	; return updated ptr in saved r0
     141 006632                         	return				; return
       1 006632 000207                  	rts	pc
     142                                	
     143                                ; --------------------------------------------------------------------------------
     144                                
     145                                	; process main format
     146                                
     147 006634 012403                  xprintf:mov	(r4)+,r3		; prime format string pointer
     148                                
     149 006636                         1$:	call	900$			; get next format character
       1 006636 004737  007546          	jsr	pc,900$
     150 006642 120227  000045          	cmpb	r2,#<'%>		; hit a format flag?
     151 006646 001430                  	beq	10$			; yes, go process
     152 006650 120227  000134          	cmpb	r2,#<'\>		; hit an escape flag?
     153 006654 001404                  	beq	3$			; yes, go process
     154 006656 010200                  2$:	mov	r2,r0			; char to print
     155 006660                         	call	@p.out(r5)		; no, just print it
       1 006660 004775  177766          	jsr	pc,@p.out(r5)
     156 006664 000764                  	br	1$			; loop
     157                                
     158                                	; process escaped character \a .. \z
     159                                
     160 006666                         3$:	call	900$			; get the escaped character
       1 006666 004737  007546          	jsr	pc,900$
     161 006672 002771                  	blt	2$			; quick exit for [NUL-@] range
     162 006674 120227  000172          	cmpb	r2,#<'z>		;
     163 006700 003366                  	bgt	2$			; exit if [{-DEL]
     164 006702 120227  000141          	cmpb	r2,#<'a>		;
     165 006706 002005                  	bge	4$			; br if [a-z]	
     166 006710 120227  000132          	cmpb	r2,#<'Z>		;
     167 006714 003360                  	bgt	2$			; br if [[-`]
     168 006716 152702  000040          	bisb	#40,r2			; force to [a-z] range
     169 006722 116202  007443          4$:	movb	1000$-<'a>(r2),r2	; translate a..z to escaped
     170 006726 000753                  	br	2$			; go print
     171                                
     172                                	; process format flag %[-+]?(0?\d+([.]\d+)?)?[lh]?[iduscpxo]
     173                                
     174 006730 112765  000040  177776  10$:	movb	#<' >,p.fil(r5)		; blank fill
     175 006736 105065  177777          	clrb	p.flg(r5)		; clear flags
     176 006742 005065  177774          	clr	p.wid(r5)		; init width spec
     177 006746 005065  177772          	clr	p.pre(r5)		; init precision spec
     178 006752 005065  177770          	clr	p.len(r5)		; no digits yet
     179                                
     180 006756                         11$:	call	900$			; get next format character
       1 006756 004737  007546          	jsr	pc,900$
     181 006762 002045                  	bge	40$			; br if [A-DEL]
     182 006764 120227  000045          	cmpb	r2,#<'%>		; check for '%'
     183 006770 001732                  	beq	2$			; br if yes
     184                                
     185                                	; some character in range [NUL-@]
     186                                
     187 006772 120227  000055          	cmpb	r2,#<'->		; check for '-'
     188 006776 001004                  	bne	12$			; br if not
     189 007000 152765  000001  177777  	bisb	#pf.ljus,p.flg(r5)	; yes, set a flag
     190 007006 000763                  	br	11$			; loop
     191 007010 120227  000053          12$:	cmpb	r2,#<'+>		; check for '+'
     192 007014 001004                  	bne	13$			; br if not
     193 007016 152765  000002  177777  	bisb	#pf.sign,p.flg(r5)	; yes, set a flag
     194 007024 000754                  	br	11$			; loop
     195 007026 120227  000043          13$:	cmpb	r2,#<'#>		; check for '#'
     196 007032 001004                  	bne	20$			; br if not
     197 007034 152765  000004  177777  	bisb	#pf.altr,p.flg(r5)	; yes, set a flag
     198 007042 000745                  	br	11$			; loop
     199                                
     200 007044                         20$:	call	800$			; get a number if present
       1 007044 004737  007452          	jsr	pc,800$
     201 007050 010165  177774          	mov	r1,p.wid(r5)		; save number as width
     202                                
     203 007054 120227  000056          	cmpb	r2,#<'.>		; check for .
     204 007060 001006                  	bne	40$			; br if not, should be alpha
     205 007062                         	call	900$			; get next character
       1 007062 004737  007546          	jsr	pc,900$
     206                                
     207 007066                         	call	800$			; get a number if present
       1 007066 004737  007452          	jsr	pc,800$
     208 007072 010165  177772          	mov	r1,p.pre(r5)		; save number as precision
     209                                
     210                                	; flag is in range [A-Za-z]
     211                                
     212 007076 005000                  40$:	clr	r0			; zap numerics
     213 007100 005001                  	clr	r1			;
     214 007102 120227  000101          41$:	cmpb	r2,#<'A>		; check for [:-@]
     215 007106 002663                  	blt	2$			; br if yes
     216 007110 120227  000172          	cmpb	r2,#<'z>		; check for [{-DEL]
     217 007114 003260                  	bgt	2$			; br if yes
     218 007116 120227  000141          	cmpb	r2,#<'a>		; check for [a-z]
     219 007122 002003                  	bge	42$			; br if yes
     220 007124 120227  000132          	cmpb	r2,#<'Z>		; check for [A-Z]
     221 007130 003252                  	bgt	2$			; br if no
     222 007132 042702  000040          42$:	bic	#40,r2			; force to [a-z] to [A-Z] range
     223 007136 012401                  	mov	(r4)+,r1		; get the next value as lsb
     224 007140 006302                  	asl	r2			; char*2 for word offset
     225 007142 000172  006744          	jmp	@400$-<2*'A>(r2)	; dispatch
     226                                
     227                                400$:	;----	aaaa,bbbb,cccc,dddd,eeee,ffff,gggg,hhhh,iiii,jjjj,kkkk,llll,mmmm
     228 007146 007232  007436  007276  	.word	401$,470$,420$,430$,401$,401$,401$,401$,430$,401$,401$,405$,401$
         007154 007316  007232  007232  
         007162 007232  007232  007316  
         007170 007232  007232  007246  
         007176 007232                  
     229                                	;----	nnnn,oooo,pppp,qqqq,rrrr,ssss,tttt,uuuu,vvvv,wwww,xxxx,yyyy,zzzz
     230 007200 007232  007406  007406  	.word	401$,450$,450$,401$,401$,410$,401$,440$,401$,401$,460$,401$,401$
         007206 007232  007232  007264  
         007214 007232  007372  007232  
         007222 007232  007422  007232  
         007230 007232                  
     231                                
     232 007232 005744                  401$:	tst	-(r4)			; %<illegal>: backup argument pointer
     233 007234 005002                  	clr	r2			; zap
     234 007236 156302  177777          	bisb	-1(r3),r2		; retrieve last character
     235 007242 000137  006656          	jmp	2$			; just go print
     236                                
     237 007246                         405$:	call	900$			; %l: get next character
       1 007246 004737  007546          	jsr	pc,900$
     238 007252 152765  000010  177777  	bisb	#pf.long,p.flg(r5)	; indicate longword value
     239 007260 010100                  	mov	r1,r0			; copy 1st arg to msb
     240 007262 000707                  	br	41$			; and go parse next flag
     241                                
     242 007264 010102                  410$:	mov	r1,r2			; %s: get next arg as string address
     243 007266                         	call	prtstr			; print as a string
       1 007266 004737  010206          	jsr	pc,prtstr
     244 007272 000137  006636          	jmp	1$			; continue at the top
     245                                
     246 007276 005046                  420$:	clr	-(sp)			; %c: zap upper byte
     247 007300 110116                  	movb	r1,(sp)			; insert the character
     248 007302 010602                  	mov	sp,r2			; point at string
     249 007304                         	call	prtstr			; print as a string
       1 007304 004737  010206          	jsr	pc,prtstr
     250 007310 005726                  	tst	(sp)+			; flush temp string
     251 007312 000137  006636          	jmp	1$			; continue at the top
     252                                
     253 007316 012702  000012          430$:	mov	#10.,r2			; %d,%i: decimal radix
     254 007322 132765  000010  177777  	bitb	#pf.long,p.flg(r5)	; longword value?
     255 007330 001004                  	bne	431$			; br if yes
     256 007332 005000                  	clr	r0			; zap
     257 007334 005701                  	tst	r1			; no; test lsb sign
     258 007336 100001                  	bpl	431$			; br if plus/zero
     259 007340 005100                  	com	r0			; extend -1 to msb
     260 007342 005700                  431$:	tst	r0			; test msb sign
     261 007344 002006                  	bge	439$			; br if zero or positive
     262 007346 005400                  	neg	r0			; negative; make positive
     263 007350 005401                  	neg	r1			;
     264 007352 005600                  	sbc	r0			;
     265 007354 152765  000020  177777  	bisb	#pf.nega,p.flg(r5)	; set flag indicating negative
     266 007362                         439$:	call	prt32u			; print as unsigned decimal w/sign
       1 007362 004737  007636          	jsr	pc,prt32u
     267 007366 000137  006636          	jmp	1$			; continue at the top
     268                                
     269 007372 012702  000012          440$:	mov	#10.,r2			; %u: decimal radix
     270 007376                         	call	prt32u			; print as an unsigned decimal
       1 007376 004737  007636          	jsr	pc,prt32u
     271 007402 000137  006636          	jmp	1$			; continue at the top
     272                                
     273 007406 012702  000010          450$:	mov	#8.,r2			; %o,%p: octal radix
     274 007412                         	call	prt32u			; print as an unsigned hex
       1 007412 004737  007636          	jsr	pc,prt32u
     275 007416 000137  006636          	jmp	1$			; continue at the top
     276                                
     277 007422 012702  000020          460$:	mov	#16.,r2			; %x: hexadecimal radix
     278 007426                         	call	prt32u			; print as an unsigned hex
       1 007426 004737  007636          	jsr	pc,prt32u
     279 007432 000137  006636          	jmp	1$			; continue at the top
     280                                
     281 007436 012702  000002          470$:	mov	#2.,r2			; %b: binary radix
     282 007442                         	call	prt32u			; print as an unsigned binary
       1 007442 004737  007636          	jsr	pc,prt32u
     283 007446 000137  006636          	jmp	1$			; continue at the top
     284                                
     285                                	; ---------------------------------------------------------
     286                                	; get a number as '[0-9]+' or '*'
     287                                
     288 007452 120227  000052          800$:	cmpb	r2,#<'*>		; check for '*' indirection
     289 007456 001427                  	beq	880$			; br if yes
     290 007460 120227  000060          	cmpb	r2,#<'0>		; check for leading '0' character
     291 007464 001002                  	bne	810$			; br if not
     292 007466 110265  177776          	movb	r2,p.fil(r5)		; yes, set a flag
     293 007472 005001                  810$:	clr	r1			; number accumulated here
     294 007474 120227  000060          820$:	cmpb	r2,#<'0>		; check for '0'
     295 007500 002421                  	blt	890$			; br if less that a '0'
     296 007502 120227  000071          	cmpb	r2,#<'9>		; check for '9'
     297 007506 003016                  	bgt	890$			; br if greater than '9'
     298 007510 162702  000060          	sub	#<'0>,r2		; offset to range 0..9
     299 007514 006301                  	asl	r1			; number *= 2.
     300 007516 010100                  	mov	r1,r0			; (number*2.)
     301 007520 006300                  	asl	r0			; (number*4.)
     302 007522 006300                  	asl	r0			; (number*8.)
     303 007524 060001                  	add	r0,r1			; number = number*8. + number*2.
     304 007526 060201                  	add	r2,r1			; add in this digit
     305 007530                         	call	900$			; get next format character
       1 007530 004737  007546          	jsr	pc,900$
     306 007534 000757                  	br	820$			; and loop
     307 007536 012401                  880$:	mov	(r4)+,r1		; get next arg as number
     308 007540                         	call	900$			; get next character
       1 007540 004737  007546          	jsr	pc,900$
     309 007544                         890$:	return				; return
       1 007544 000207                  	rts	pc
     310                                
     311                                	; ---------------------------------------------------------
     312                                	; get next character (or exit) routine; result in r2
     313                                
     314 007546 112302                  900$:	movb	(r3)+,r2		; get next format character
     315 007550 042702  177600          	bic	#^c177,r2		; 7bit ascii only
     316 007554 001403                  	beq	990$			; end of string seen
     317 007556 120227  000101          	cmpb	r2,#<'A>		; check for [A-DEL]
     318 007562                         	return				; leave CC set with result
       1 007562 000207                  	rts	pc
     319                                
     320 007564 010506                  990$:	mov	r5,sp			; flush frame
     321 007566 012605                  	mov	(sp)+,r5		; restore reg
     322 007570 012604                  	mov	(sp)+,r4		;
     323 007572 012603                  	mov	(sp)+,r3		;
     324 007574 012602                  	mov	(sp)+,r2		;
     325 007576 012601                  	mov	(sp)+,r1		;
     326 007600 012600                  	mov	(sp)+,r0		;
     327 007602                         	return				; return
       1 007602 000207                  	rts	pc
     328                                
     329                                	; ---------------------------------------------------------
     330                                	; escaped character table
     331                                1000$:	;	aaa bbb ccc ddd eee fff ggg hhh iii jjj kkk lll mmm
     332                                	;	BEL  BS         ESC  FF
     333 007604    007     010     143  	.byte	007,010,143,144,033,014,147,150,151,152,153,154,155
         007607    144     033     014  
         007612    147     150     151  
         007615    152     153     154  
         007620    155                  
     334                                	;	nnn ooo ppp qqq rrr sss ttt uuu vvv www xxx yyy zzz
     335                                	;	 LF              CR      HT      VT
     336 007621    012     157     160  	.byte	012,157,160,161,015,163,011,165,013,167,170,172,172
         007624    161     015     163  
         007627    011     165     013  
         007632    167     170     172  
         007635    172                  
     337                                	; ---------------------------------------------------------
     338                                
     339                                ; --------------------------------------------------------------------------------
     340                                ;
     341                                ; digit print routine .. print a 32b value as unsigned digits
     342                                ;
     343                                ;	call:	mov	datahi,r0
     344                                ;		mov	datalo,r1
     345                                ;		mov	#radix,r2 ; 2. or 8. or 10. or 16.
     346                                ;		call	prt32u
     347                                ;
     348                                ;		r0 - data msb      (not saved)
     349                                ;		r1 - data lsb      (not saved)
     350                                ;		r2 - radix         (not saved)
     351                                ;		r3 - ptr to format     (saved)
     352                                ;		r4 - ptr to arglist    (saved) [input not used]
     353                                ;		r5 - ptr to flags      (saved)
     354                                ;
     355 007636 010346                  prt32u:	mov	r3,-(sp)		; save regs we use
     356 007640 010446                  	mov	r4,-(sp)		;
     357                                
     358                                	; render all the digits onto the stack (lsd first, msd last)
     359                                
     360 007642 005046                  	clr	-(sp)			; zero flag
     361 007644 010246                  1$:	mov	r2,-(sp)		; radix lsb
     362 007646 005046                  	clr	-(sp)			;   and msb
     363 007650 010146                  	mov	r1,-(sp)		; number lsb
     364 007652 010046                  	mov	r0,-(sp)		;    and msb
     365 007654                         	call	uldiv			; get quo and rem
       1 007654 004737  010454          	jsr	pc,uldiv
     366 007660 016602  000006          	mov	6.(sp),r2		; restore radix from stack
     367 007664 062706  000010          	add	#8.,sp			; flush args
     368 007670 062703  000060          	add	#<'0>,r3		; make rem lsb a digit
     369 007674 020327  000071          	cmp	r3,#<'9>		; still a valid digit?
     370 007700 003402                  	ble	2$			; br if yes
     371 007702 062703  000007          	add	#<'A>-<':>,r3		; offset to 'A...'Z range
     372 007706 010346                  2$:	mov	r3,-(sp)		; save
     373 007710 005265  177770          	inc	p.len(r5)		; count digits
     374 007714 005701                  	tst	r1			; any lsb left?
     375 007716 001352                  	bne	1$			; br if yes
     376 007720 005700                  	tst	r0			; any msb left?
     377 007722 001350                  	bne	1$			; br if yes
     378                                
     379                                	; check if we generated the minimum number of digits requested
     380                                
     381 007724 026565  177770  177772  10$:	cmp	p.len(r5),p.pre(r5)	; compare length to precision
     382 007732 103005                  	bhis	20$			; br we're OK
     383 007734 012746  000060          	mov	#<'0>,-(sp)		; nope, add another digit
     384 007740 005265  177770          	inc	p.len(r5)		; count digits
     385 007744 000767                  	br	10$			; and loop	
     386                                
     387                                	; check for options (#) flag
     388                                
     389 007746 132765  000004  177777  20$:	bitb	#pf.altf,p.flg(r5)	; check for options flag
     390 007754 001422                  	beq	30$			; br if not set
     391 007756 020227  000020          	cmp	r2,#16.			; radix 16?
     392 007762 001407                  	beq	21$			; br if yes
     393 007764 020227  000010          	cmp	r2,#8.			; radix 8?
     394 007770 001014                  	bne	30$			; br if not
     395 007772 022716  000060          	cmp	#<'0>,(sp)		; first digit already zero?
     396 007776 001411                  	beq	30$			; yes, no need to add
     397 010000 000404                  	br	22$			; no, add a leading zero
     398 010002 012746  000170          21$:	mov	#<'x>,-(sp)		; add a '0x' prefix
     399 010006 005265  177770          	inc	p.len(r5)		; count it
     400 010012 012746  000060          22$:	mov	#<'0>,-(sp)		;
     401 010016 005265  177770          	inc	p.len(r5)		; count it
     402                                
     403                                	; check if we need a sign (+/-/none)
     404                                
     405 010022 132765  000020  177777  30$:	bitb	#pf.nega,p.flg(r5)	; was original value negative?
     406 010030 001403                  	beq	31$			; br if not
     407 010032 012746  000055          	mov	#<'->,-(sp)		; minus sign
     408 010036 000406                  	br	32$			;
     409 010040 132765  000002  177777  31$:	bitb	#pf.sign,p.flg(r5)	; sign always requested?
     410 010046 001404                  	beq	50$			; br if not
     411 010050 012746  000053          	mov	#<'+>,-(sp)		; plus sign
     412 010054 005265  177770          32$:	inc	p.len(r5)		; count all chars generated
     413                                
     414                                	; processing for right justification
     415                                
     416 010060 132765  000001  177777  50$:	bitb	#pf.ljus,p.flg(r5)	; check left-justify flag
     417 010066 001020                  	bne	70$			; br if left justified
     418 010070 116501  177776          	movb	p.fil(r5),r1		; get fill character
     419 010074 026565  177770  177774  51$:	cmp	p.len(r5),p.wid(r5)	; compare length to width
     420 010102 103012                  	bhis	70$			; br if we're OK
     421 010104 011600                  	mov	(sp),r0			; copy last character
     422 010106 010146                  	mov	r1,-(sp)		; add a fill character
     423 010110 020100                  	cmp	r1,r0			; check fill/last char order
     424 010112 101403                  	blos	52$			; br if order OK
     425 010114 010016                  	mov	r0,(sp)			; copy sign/last char
     426 010116 010166  000002          	mov	r1,2(sp)		; insert fill after sign
     427 010122 005265  177770          52$:	inc	p.len(r5)		; count it
     428 010126 000762                  	br	51$			; loop
     429                                
     430                                	; print all digits in order (sign..msd..lsd)
     431                                
     432 010130 005001                  70$:	clr	r1			; count characters output
     433 010132 012600                  71$:	mov	(sp)+,r0		; get a digit
     434 010134 001404                  	beq	80$			; br if no more
     435 010136                         	call	@p.out(r5)		; print it
       1 010136 004775  177766          	jsr	pc,@p.out(r5)
     436 010142 005201                  	inc	r1			; count it
     437 010144 000772                  	br	71$			; loop
     438                                
     439                                	; processing for left justification
     440                                
     441 010146 132765  000001  177777  80$:	bitb	#pf.ljus,p.flg(r5)	; check left-justify flag
     442 010154 001411                  	beq	90$			; br if is right justified
     443 010156 012700  000040          	mov	#<' >,r0		; space fill on right
     444 010162 020165  177774          81$:	cmp	r1,p.wid(r5)		; compare length to width
     445 010166 103004                  	bhis	90$			; br we're OK
     446 010170                         	call	@p.out(r5)		; print it
       1 010170 004775  177766          	jsr	pc,@p.out(r5)
     447 010174 005201                  	inc	r1			; count characters
     448 010176 000771                  	br	81$			; and loop	
     449                                
     450                                	; and done
     451                                
     452 010200 012604                  90$:	mov	(sp)+,r4		; restore regs
     453 010202 012603                  	mov	(sp)+,r3		;
     454 010204                         	return				; return
       1 010204 000207                  	rts	pc
     455                                
     456                                ; --------------------------------------------------------------------------------
     457                                ;
     458                                ; asciz string print routine
     459                                ;
     460                                ;	call:	mov	#strptr,r2
     461                                ;		call	prtstr
     462                                ;
     463                                ;		r0 - temp          (not saved)
     464                                ;		r1 - temp          (not saved)
     465                                ;		r2 - ptr to string (not saved)
     466                                ;		r3 - ptr to format     (saved) [input not used]
     467                                ;		r4 - ptr to arglist    (saved) [input not used]
     468                                ;		r5 - ptr to flags      (saved)
     469                                ;
     470 010206 010346                  prtstr:	mov	r3,-(sp)		; save regs
     471 010210 010446                  	mov	r4,-(sp)		;
     472                                
     473                                	; compute length of string
     474                                
     475 010212 010203                  	mov	r2,r3			; copy ptr to string
     476 010214 105723                  1$:	tstb	(r3)+			; check a byte
     477 010216 001376                  	bne	1$			; br if more string
     478 010220 160203                  	sub	r2,r3			; compute length
     479 010222 005303                  	dec	r3			; minus the trailing null	
     480                                
     481                                	; set precision to length if precision is zero
     482                                
     483 010224 005765  177772          	tst	p.pre(r5)		; check requested precision
     484 010230 001002                  	bne	20$			; br if nonzero
     485 010232 010365  177772          	mov	r3,p.pre(r5)		; else set to string length
     486 010236 020365  177772          20$:	cmp	r3,p.pre(r5)		; compare actual length to precision
     487 010242 101402                  	blos	50$			; br if actual <= precision
     488 010244 016503  177772          	mov	p.pre(r5),r3		; else set actual to precision
     489                                
     490                                	; processing for right justification
     491                                
     492 010250 132765  000001  177777  50$:	bitb	#pf.ljus,p.flg(r5)	; check left-justify flag
     493 010256 001002                  	bne	70$			; br if left justified
     494 010260                         	call	100$			; do fill
       1 010260 004737  010326          	jsr	pc,100$
     495                                
     496                                	; print string 
     497                                
     498 010264 010301                  70$:	mov	r3,r1			; copy length
     499 010266 001406                  	beq	80$			; br if no characters
     500 010270 112200                  71$:	movb	(r2)+,r0		; get a character
     501 010272 001404                  	beq	80$			; br if no characters
     502 010274                         	call	@p.out(r5)		; print it
       1 010274 004775  177766          	jsr	pc,@p.out(r5)
     503 010300 005301                  	dec	r1			; count
     504 010302 001372                  	bne	71$			; loop
     505                                
     506                                	; processing for left justification
     507                                
     508 010304 132765  000001  177777  80$:	bitb	#pf.ljus,p.flg(r5)	; check left-justify flag
     509 010312 001402                  	beq	90$			; br if is right justified
     510 010314                         	call	100$			; do fill
       1 010314 004737  010326          	jsr	pc,100$
     511                                
     512                                	; and done
     513                                
     514 010320 012604                  90$:	mov	(sp)+,r4		; restore
     515 010322 012603                  	mov	(sp)+,r3		;
     516 010324                         	return				; return
       1 010324 000207                  	rts	pc
     517                                
     518                                	; ----------------------------------------------------
     519                                	; generate fill characters
     520                                
     521 010326 016501  177774          100$:	mov	p.wid(r5),r1		; requested width
     522 010332 160301                  	sub	r3,r1			; subtract string width
     523 010334 101406                  	blos	102$			; br if no fill needed
     524 010336 116500  177776          	movb	p.fil(r5),r0		; get fill character
     525 010342                         101$:	call	@p.out(r5)		; print a fill character
       1 010342 004775  177766          	jsr	pc,@p.out(r5)
     526 010346 005301                  	dec	r1			; count
     527 010350 001374                  	bne	101$			; loop
     528 010352                         102$:	return				; done
       1 010352 000207                  	rts	pc
     529                                
     530                                ; --------------------------------------------------------------------------------
     531                                
     532                                .include "mac/muldiv.mac"
       1                                ;=================================================================================
       2                                ; muldiv.mac - 32b mul/div routines for macro11 diagnostics
       3                                ; (C) 2009-2016 Donald North. All rights reserved.
       4                                ;=================================================================================
       5                                
       6                                ; --------------------------------------------------------------------------------
       7                                ;
       8                                ; unsigned 32b * 32b => 32b multiplication
       9                                ; 
      10                                ; from the 2.9BSD stdio C lib, using simple shift/add algorithm
      11                                ; 
      12                                ;	call:	mov	#b.lo,-(sp)
      13                                ;		mov	#b.hi,-(sp)
      14                                ;		mov	#a.lo,-(sp)
      15                                ;		mov	#a.hi,-(sp)
      16                                ;		call	ulmul
      17                                ;		add	#8.,sp
      18                                ;		mov	r1,q.lo
      19                                ;		mov	r0,q.hi
      20                                ;
      21 010354 010246                  ulmul::	mov	r2,-(sp)		; save
      22 010356 010346                  	mov	r3,-(sp)		;
      23 010360 010446                  	mov	r4,-(sp)		;
      24 010362 010546                  	mov	r5,-(sp)		;
      25                                
      26 010364 016605  000020          	mov	8.+8.(sp),r5		; b.lo
      27 010370 016604  000016          	mov	6.+8.(sp),r4		; b.hi
      28 010374 016603  000014          	mov	4.+8.(sp),r3		; a.lo
      29 010400 016602  000012          	mov	2.+8.(sp),r2		; a.hi
      30 010404 005001                  	clr	r1			; q.lo
      31 010406 005000                  	clr	r0			; q.hi
      32                                
      33 010410 000241                  1$:	clc				; shiftin zeroes
      34 010412 006004                  	ror	r4			; shift multiplier right one
      35 010414 006005                  	ror	r5			;
      36 010416 103003                  	bcc	2$			; br if shifted out a zero
      37 010420 060301                  	add	r3,r1			; else add multiplicand to product
      38 010422 005500                  	adc	r0			; propagate C
      39 010424 060200                  	add	r2,r0			;
      40 010426 006303                  2$:	asl	r3			; shift multiplicant left one
      41 010430 006102                  	rol	r2			;
      42 010432 005704                  	tst	r4			; any high multiplier bits left?
      43 010434 001365                  	bne	1$			; br if yes
      44 010436 005705                  	tst	r5			; any low multiplier bits left?
      45 010440 001363                  	bne	1$			; br if yes
      46                                
      47 010442 012605                  	mov	(sp)+,r5		; restore
      48 010444 012604                  	mov	(sp)+,r4		;
      49 010446 012603                  	mov	(sp)+,r3		;
      50 010450 012602                  	mov	(sp)+,r2		;
      51 010452                         	return				; done
       1 010452 000207                  	rts	pc
      52                                
      53                                ; --------------------------------------------------------------------------------
      54                                ;
      55                                ; unsigned 32b / 32b => 32b, 32b division with remainder
      56                                ; 
      57                                ; from Hennessey & Patterson Appendix A
      58                                ;
      59                                ;	call:	mov	#den.lo,-(sp)	; 8.(sp)
      60                                ;		mov	#den.hi,-(sp)	; 6.(sp)
      61                                ;		mov	#num.lo,-(sp)	; 4.(sp)
      62                                ;		mov	#num.hi,-(sp)	; 2.(sp)
      63                                ;		call	uldiv
      64                                ;		add	#8.,sp
      65                                ;		mov	r3,rem.lo
      66                                ;		mov	r2,rem.hi
      67                                ;		mov	r1,quo.lo
      68                                ;		mov	r0,quo.hi
      69                                ;
      70 010454 010446                  uldiv::	mov	r4,-(sp)		; save
      71 010456 010546                  	mov	r5,-(sp)		;
      72                                
      73 010460 016601  000010          	mov	4.+4.(sp),r1		; num.lo
      74 010464 016600  000006          	mov	2.+4.(sp),r0		; num.hi
      75                                
      76 010470 005005                  	clr	r5			; tmp.lo
      77 010472 005004                  	clr	r4			; tmp.hi
      78                                
      79 010474 012746  000037          	mov	#31.,-(sp)		; bit count
      80                                
      81 010500 006301                  1$:	asl	r1			; (tmp,num) <<= 1
      82 010502 006100                  	rol	r0			;
      83 010504 006105                  	rol	r5			;
      84 010506 006104                  	rol	r4			;
      85                                
      86 010510 010503                  	mov	r5,r3			; rem = tmp - den
      87 010512 010402                  	mov	r4,r2			;
      88 010514 166603  000016          	sub	8.+6.(sp),r3		;
      89 010520 005602                  	sbc	r2			;
      90 010522 166602  000014          	sub	6.+6.(sp),r2		;
      91                                
      92 010526 100403                  	bmi	2$			; br if rem < 0
      93                                
      94 010530 005201                  	inc	r1			; quo |= 1
      95 010532 010305                  	mov	r3,r5			; tmp = rem
      96 010534 010204                  	mov	r2,r4			;
      97                                
      98 010536 005316                  2$:	dec	(sp)			; count bits
      99 010540 002357                  	bge	1$			; loop if more
     100 010542 005726                  	tst	(sp)+			; flush counter
     101                                
     102 010544 005702                  	tst	r2			; test for rem < 0
     103 010546 002005                  	bge	3$			; br if not
     104                                
     105 010550 066603  000014          	add	8.+4.(sp),r3		; rem += den correction
     106 010554 005502                  	adc	r2			;
     107 010556 066602  000012          	add	6.+4.(sp),r2		;
     108                                
     109 010562 012605                  3$:	mov	(sp)+,r5		; restore
     110 010564 012604                  	mov	(sp)+,r4		;
     111 010566                         	return				; done
       1 010566 000207                  	rts	pc
     112                                
     113                                ; --------------------------------------------------------------------------------
     114                                ;
     115                                ; signed 32b / 32b => 32b, 32b division with remainder
     116                                ; 
     117                                ;	call:	mov	#den.lo,-(sp)	; 8.(sp)
     118                                ;		mov	#den.hi,-(sp)	; 6.(sp)
     119                                ;		mov	#num.lo,-(sp)	; 4.(sp)
     120                                ;		mov	#num.hi,-(sp)	; 2.(sp)
     121                                ;		call	sldiv
     122                                ;		add	#8.,sp
     123                                ;		mov	r3,rem.lo
     124                                ;		mov	r2,rem.hi
     125                                ;		mov	r1,quo.lo
     126                                ;		mov	r0,quo.hi
     127                                ;
     128 010570 010446                  sldiv::	mov	r4,-(sp)		; save
     129                                
     130 010572 016603  000012          	mov	8.+2.(sp),r3		; den.lo
     131 010576 016602  000010          	mov	6.+2.(sp),r2		; den.hi
     132 010602 016601  000006          	mov	4.+2.(sp),r1		; num.lo
     133 010606 016600  000004          	mov	2.+2.(sp),r0		; num.hi
     134                                
     135 010612 005004                  	clr	r4			; pos
     136                                
     137 010614 005700                  	tst	r0			; num sign
     138 010616 002006                  	bge	10$			; br if pos
     139                                
     140 010620 005104                  	com	r4			; neg
     141                                
     142 010622 005101                  	com	r1			; negate num
     143 010624 005100                  	com	r0			;
     144 010626 062701  000001          	add	#1,r1			;
     145 010632 005500                  	adc	r0			; 
     146                                
     147 010634 005702                  10$:	tst	r2			; den sign
     148 010636 002006                  	bge	20$			; br if pos
     149                                
     150 010640 105104                  	comb	r4			; neg
     151                                
     152 010642 005103                  	com	r3			; negate den
     153 010644 005102                  	com	r2			;
     154 010646 062703  000001          	add	#1,r3			;
     155 010652 005502                  	adc	r2			; 
     156                                	
     157 010654 010346                  20$:	mov	r3,-(sp)		; den.lo
     158 010656 010246                  	mov	r2,-(sp)		; den.hi
     159 010660 010146                  	mov	r1,-(sp)		; num.lo
     160 010662 010046                  	mov	r0,-(sp)		; num.hi
     161 010664                         	call	uldiv			;
       1 010664 004737  010454          	jsr	pc,uldiv
     162 010670 062706  000010          	add	#8.,sp			; 
     163                                
     164 010674 005704                  	tst	r4			; invert result
     165 010676 002005                  	bge	30$			;
     166                                
     167 010700 005103                   	com	r3			; negate rem
     168 010702 005102                  	com	r2			;
     169 010704 062703  000001          	add	#1,r3			;
     170 010710 005502                  	adc	r2			; 
     171                                
     172 010712 105704                  30$:	tstb	r4			; invert result
     173 010714 002005                  	bge	40$			;
     174                                
     175 010716 005101                  	com	r1			; negate quo
     176 010720 005100                  	com	r0			;
     177 010722 062701  000001          	add	#1,r1			;
     178 010726 005500                  	adc	r0			; 
     179                                
     180 010730 012604                  40$:	mov	(sp)+,r4		; restore
     181 010732                         	return				; done
       1 010732 000207                  	rts	pc
     182                                
     183                                ;================================================================================
     184                                ; end of muldiv.mac
     185                                ;================================================================================
     185                                
     533                                
     534                                ; --------------------------------------------------------------------------------
     535                                
     536        000000                  .iif ne,pf.sep,	.end
     537                                
     538                                ;=================================================================================
     539                                ; end of printf.mac
     540                                ;=================================================================================
     540                                
     336                                
     337                                ; --------------------------------------------------------------------------------
     338                                
     339                                	.end
     339                                


Symbol table

$$NUM  =000002           215$0  =005652   L       81$10  =010162   L       LK$CSR =177546           RC_WOD =177400           
$$POS  =004000           216$0  =005670   L       810$9  =007472   L       LK$VEC =000100           RC_WOE =170000           
$ENDAD =006010           217$0  =005672   L       82$0   =005050   L       LKINTR =006044           RC_WR  =000004           
$SAV42 =002004           22$10  =010012   L       820$9  =007474   L       LK_IEN =000100           RC_WRD =000014           
.      =******           3$13   =010562   L       84$0   =005116   L       LK_MON =000200           RE_ACL =000010           
1$0    =004132   L       3$9    =006666   L       880$9  =007536   L       LK_PRI =000006           RE_CER =000001           
1$1    =006062   L       30$10  =010022   L       890$9  =007544   L       MSG1   =005724           RE_DDA =000100           
1$10   =007644   L       30$14  =010712   L       9$2    =006172   L       MSG2   =005750           RE_DDE =000040           
1$11   =010214   L       31$10  =010040   L       9$3    =006270   L       N.ARGS =000016           RE_DER =000020           
1$12   =010410   L       32$10  =010054   L       9$4    =006340   L       N.LAST =000014           RE_DON =000004           
1$13   =010500   L       32768$0=004020   L       9$5    =006410   L       NOXXDP =006024           RE_DRD =000200           
1$2    =006126   L       32769$0=004026   L       90$0   =005140   L       P.FIL  =177776           RE_NU9 =001000           
1$3    =006224   L       32770$0=004044   L       90$10  =010200   L       P.FLG  =177777           RE_NXM =004000           
1$4    =006276   L       32771$0=004056   L       90$11  =010320   L       P.LEN  =177770           RE_PER =000002           
1$5    =006346   L       32772$0=005072   L       900$9  =007546   L       P.OUT  =177766           RE_UNI =000400           
1$6    =006416   L       32773$0=005140   L       990$9  =007564   L       P.PRE  =177772           RE_WCO =002000           
1$7    =006530   L       4$9    =006722   L       BASE   =002012           P.PTR  =177764           RX$CS  =177170           
1$8    =006610   L       40$14  =010730   L       BIT0   =000001           P.SR0  =000012           RX$DB  =177172           
1$9    =006636   L       40$9   =007076   L       BIT00  =000001           P.SR1  =000010           RXCS   =006072           
10$0   =004332   L       400$0  =005712   L       BIT01  =000002           P.SR2  =000006           RXDB   =006074           
10$10  =007724   L       400$9  =007146   L       BIT02  =000004           P.SR3  =000004           RXEMPT =006202           
10$14  =010634   L       401$9  =007232   L       BIT03  =000010           P.SR4  =000002           RXFILL =006174           
10$9   =006730   L       405$9  =007246   L       BIT04  =000020           P.SR5  =000000           RXFLEM =006210           
100$11 =010326   L       41$9   =007102   L       BIT05  =000040           P.WID  =177774           RXRD   =006104           
1000$9 =007604   L       410$9  =007264   L       BIT06  =000100           PF.ALT =000004           RXRDES =006272           
101$11 =010342   L       42$9   =007132   L       BIT07  =000200           PF.LJU =000001           RXRDWR =006112           
102$0  =005200   L       420$9  =007276   L       BIT08  =000400           PF.LON =000010           RXRET  =006442           
102$11 =010352   L       430$9  =007316   L       BIT09  =001000           PF.NEG =000020           RXSDEN =006342           
103$0  =005237   L       431$9  =007342   L       BIT1   =000002           PF.SEP =000000           RXSTAT =006412           
104$0  =005276   L       439$9  =007362   L       BIT10  =002000           PF.SIG =000002           RXWR   =006076           
105$0  =005335   L       440$9  =007372   L       BIT11  =004000           PRINTF =006464 G         RX_BPS =000400           
11$9   =006756   L       450$9  =007406   L       BIT12  =010000           PRT32U =007636           RX_SAH =000032           
12$9   =007010   L       460$9  =007422   L       BIT13  =020000           PRTSTR =010206           RX_SAL =000001           
13$9   =007026   L       470$9  =007436   L       BIT14  =040000           PSW    =177776 G         RX_TAH =000114           
2$10   =007706   L       49$0   =004452   L       BIT15  =100000           RC_A16 =010000           RX_TAL =000000           
2$12   =010426   L       50$0   =004532   L       BIT2   =000004           RC_A17 =020000           RX_WPS =000200           
2$13   =010536   L       50$10  =010060   L       BIT3   =000010           RC_ANY =100240           SECTOR =002014           
2$2    =006144   L       50$11  =010250   L       BIT4   =000020           RC_CMD =000016           SLDIV  =010570 G         
2$3    =006242   L       51$10  =010074   L       BIT5   =000040           RC_DEN =000400           SPRINT =006544 G         
2$4    =006312   L       52$10  =010122   L       BIT6   =000100           RC_DON =000040           STACK  =002000           
2$5    =006362   L       59$0   =004604   L       BIT7   =000200           RC_EMP =000002           START  =004000           
2$6    =006432   L       61$0   =004656   L       BIT8   =000400           RC_ERR =100000           SWIREG =177570 G         
2$9    =006656   L       70$0   =004704   L       BIT9   =001000           RC_FIL =000000           SWITCH =002002           
20$0   =004340   L       70$10  =010130   L       BUFFER =002410           RC_GO  =000001           SW_DOT =000002           
20$10  =007746   L       70$11  =010264   L       BUFPTR =002024           RC_HEA =001000           SW_LST =000001           
20$11  =010236   L       71$0   =004774   L       CONSOL =165144 G         RC_IEN =000100           TICKER =002020           
20$14  =010654   L       71$10  =010132   L       COUNT  =002022           RC_INI =040000           TRACK  =002016           
20$9   =007044   L       71$11  =010270   L       CR     =000015           RC_NU1 =002000           TST$NO =000001           
200$0  =005374   L       76$0   =005022   L       DELAY  =006060           RC_RD  =000006           TTRBUF =177562 G         
201$0  =005442   L       8$2    =006162   L       DENSTY =002010           RC_RDE =000016           TTRCSR =177560 G         
202$0  =005516   L       8$3    =006260   L       DONE   =005764           RC_RDS =000012           TTXBUF =177566 G         
203$0  =005570   L       8$4    =006330   L       DPYREG =177570 G         RC_RX0 =004000           TTXCSR =177564 G         
21$0   =004400   L       8$5    =006400   L       ERRBUF =002400           RC_SDE =000010           ULDIV  =010454 G         
21$10  =010002   L       80$10  =010146   L       ERRPTR =002026           RC_TRE =000200           ULMUL  =010354 G         
213$0  =005644   L       80$11  =010304   L       EXIT   =006000           RC_UNI =000020           UNIT   =002006           
214$0  =005647   L       800$9  =007452   L       LF     =000012           RC_WOC =072017           XPRINT =006634           


Program sections:

. ABS.  010734    000   (RW,I,GBL,ABS,OVR,NOSAV)
        000000    001   (RW,I,LCL,REL,CON,NOSAV)
